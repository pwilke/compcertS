(* Require Import Arith. *)
(* Require Import List. *)
(* Require Import Bool. *)
(* Require Import Psatz. *)
(* Import ListNotations. *)
(* Import NPeano. *)
(* Set Implicit Arguments. *)

(* Ltac inv H := inversion H ; try subst ; clear H. *)


(* Section REM. *)

(*   Variable A : Type. *)

(*   Variable P : A -> bool. *)
  
(*   Fixpoint rem_list (l : list bool) (l' : list A) : list A := *)
(*     match l with *)
(*     | nil => l' *)
(*     | e::l => *)
(*       match l' with *)
(*       | nil => nil *)
(*       | v :: l' => if e && P v then rem_list l l' *)
(*                    else v ::(rem_list l l') *)
(*       end *)
(*     end. *)

(* End REM. *)
  
(* Section POWER. *)

(*   Lemma two_power : forall n, 1 <= 2 ^ n. *)
(*   Proof. *)
(*     intro. *)
(*     change 1 with (2^0) at 1. *)
(*     intros. *)
(*     apply Nat.pow_le_mono_r ; lia. *)
(*   Qed. *)

(* End POWER. *)
  
(* Section S. *)

(*   Variable max_alig : nat. *)
(*   Variable sz_box_log : nat. *)
(*   Hypothesis sz_box_small: sz_box_log <= max_alig. *)
(*   Definition sz_box := pow 2 sz_box_log. *)
(*   Definition sz_max_box := pow 2 max_alig. *)
  
(*   Definition addr_aligned (n : nat) (a : nat) :=  *)
(*    n  mod (pow 2 a) = 0. *)
  
(*   (** "big" blocks should be aligned *) *)

(*   Definition log2_ceil (s : nat) := *)
(*     let sz := log2 s in *)
(*       if beq_nat (2^sz) s || beq_nat sz 0 *)
(*       then sz else S sz. *)
    
(*   Definition align_of_size (s : nat) : nat := *)
(*     if ltb s sz_box *)
(*     then log2_ceil s *)
(*     else sz_box_log. *)

(*   Lemma log2_pow2 : *)
(*     forall x, log2 (2^ x) = x. *)
(*   Proof. *)
(*     intros. *)
(*     induction x. *)
(*     - simpl. reflexivity. *)
(*     - rewrite Nat.pow_succ_r'. *)
(*       rewrite Nat.log2_double. lia. *)
(*       generalize (Nat.pow_nonzero 2 x). *)
(*       lia.  *)
(*   Qed. *)

(*   Lemma log2_mono_le : *)
(*     forall x y (LE : x <= y), log2 x <= log2 y. *)
(*   Proof. *)
(*     induction x. *)
(*     - change (log2 0) with 0. intros. lia. *)
(*     - intros. *)
(*       destruct y. lia. *)
(*       assert (x <= y) by lia. *)
(*       apply IHx in H. *)
(*       destruct (Nat.log2_succ_or x); *)
(*         destruct (Nat.log2_succ_or y); try lia. *)
(*       destruct x. *)
(*       + compute in H0. lia. *)
(*       +  *)
(*         rewrite Nat.log2_eq_succ_iff_pow2 in H0 by lia. *)
(*         destruct H0. *)
(*         rewrite H1. *)
(*         rewrite H0 in *. *)
(*         rewrite Nat.log2_le_pow2 in LE; try lia. *)
(*         rewrite log2_pow2. lia. *)
(*   Qed. *)


(*   Lemma align_of_size_bound : *)
(*     forall s, *)
(*       align_of_size s <= sz_box_log. *)
(*   Proof. *)
(*     unfold align_of_size, log2_ceil. *)
(*     intro. *)
(*     case_eq (s <? sz_box). *)
(*     - *)
(*       rewrite ltb_lt. *)
(*       intros. *)
(*       case_eq (beq_nat (2^log2 s) s || beq_nat (log2 s) 0). *)
(*       + *)
(*         intros. *)
(*         rewrite orb_true_iff in H0. *)
(*         assert (s <= sz_box) by lia. *)
(*         unfold sz_box in H1. *)
(*         apply log2_mono_le in H1. *)
(*         rewrite log2_pow2 in H1. auto. *)
(*       +  *)
(*         intros. *)
(*         unfold lt in H. *)
(*         rewrite orb_false_iff in H0. *)
(*         destruct H0. *)
(*         rewrite beq_nat_false_iff in *. *)
(*         destruct (Nat.log2_succ_or s); try lia. *)
(*         *  *)
(*           apply log2_mono_le in H. *)
(*           unfold sz_box in H. rewrite log2_pow2 in H. *)
(*           lia. *)
(*         * *)
(*           change (s < 2 ^sz_box_log) in H. *)
(*           change (log2 s < sz_box_log). *)
(*           apply Nat.log2_lt_pow2; auto. *)
(*           destruct s. compute in * ; lia. *)
(*           lia. *)
(*     - auto. *)
(*   Qed. *)
    

(*   Record ACblock := *)
(*     mk_acmem { *)
(*         ac_addr: nat; *)
(*         ac_size: nat *)
(*       }. *)

(*   Definition ACmem := list ACblock. *)

(*   Record is_aligned (b : ACblock) : Prop := *)
(*     { *)
(*       ac_addr_align : addr_aligned (ac_addr b) (align_of_size (ac_size b)) *)
(*     }. *)

(*   Inductive sorted_ca: ACmem -> Prop := *)
(*   | sorted_ca_nil: sorted_ca nil *)
(*   | sorted_ca_one: forall a, sorted_ca [a] *)
(*   | sorted_ca_cons: forall a b l *)
(*                            (SORTEDTAIL : sorted_ca (b::l)) *)
(*                            (BLOCKSZ    : ac_addr a + ac_size a <= ac_addr b), *)
(*       sorted_ca (a::b::l). *)

(*   Record is_memory (CM : ACmem) := *)
(*     { *)
(*       blocks_aligned : forall b, In b CM -> is_aligned b; *)
(*       size_gt : forall b, In b CM -> ac_size b > 0; *)
(*       is_sorted   : sorted_ca CM *)
(*     }. *)
  
(*   Definition is_max_aligned (l : ACmem) : Prop := *)
(*     forall x, In x l -> addr_aligned (ac_addr x) max_alig. *)

(*   Record Bspec := *)
(*     { *)
(*       size  : nat *)
(*     }. *)

(*   Definition AMem := list Bspec. *)

(*   Definition spec_of_ACblock (ab : ACblock) : Bspec := *)
(*     {| size := ac_size ab |}. *)

(*   Definition spec_of_acmem := List.map spec_of_ACblock. *)

(*   Definition small (ab : ACblock) : bool := *)
(*     leb (ac_size ab) sz_box. *)

(*   Definition abox := {| size := sz_box |}. *)


(*   Definition ceiling (x y : nat) := *)
(*     match x mod y with *)
(*     | O => div x y *)
(*     | _ => S (div x y) *)
(*     end. *)

(*   (** How many boxes are needed to store [s] bytes ? *) *)
(*   (* Doubt number 1: sz_box or sz_max_box ? *) *)
(*   Definition nbox (s:nat) := *)
(*     ceiling s sz_box. *)

(*   Definition nbigbox (s:nat) := *)
(*     ceiling s sz_max_box. *)

  
(*   Fixpoint amem_free_addr (L : AMem)  : nat := *)
(*     match L with *)
(*     | nil  => O *)
(*     | e::l => nbigbox (size e) * sz_max_box + amem_free_addr l *)
(*     end. *)

(*   Definition amem_min_addr (L : ACmem) : nat := *)
(*     match L with *)
(*     | nil => O *)
(*     | e :: l => ac_addr e *)
(*     end. *)

  
(*   Fixpoint cmem_free_addr (M : ACmem) : nat := *)
(*     match M with *)
(*     | nil => O *)
(*     | e::nil => ac_addr e + ac_size e *)
(*     | e::l   => cmem_free_addr l *)
(*     end. *)

(*   (** Construction of a witness memory *) *)
  

(*   Lemma sz_box_not_zero :sz_box <> 0. *)
(*   Proof. *)
(*     unfold sz_box. *)
(*     generalize (two_power sz_box_log). lia. *)
(*   Qed. *)


(*   Lemma sz_max_box_not_zero :sz_max_box <> 0. *)
(*   Proof. *)
(*     unfold sz_max_box. *)
(*     generalize (two_power max_alig). lia. *)
(*   Qed. *)
  
(*   Hint Resolve sz_box_not_zero sz_max_box_not_zero : cp. *)

(*   Lemma aligned_add_boxes : forall n x, *)
(*       addr_aligned n sz_box_log ->  *)
(*       addr_aligned (n + x * sz_box) sz_box_log. *)
(*   Proof. *)
(*     intros. *)
(*     unfold addr_aligned in *. *)
(*     change (2^sz_box_log) with sz_box. *)
(*     rewrite Nat.mod_add; auto. *)
(*     apply sz_box_not_zero. *)
(*   Qed. *)

  
(*   Lemma aligned_add_boxes_max : forall n x, *)
(*       addr_aligned n max_alig ->  *)
(*       addr_aligned (n + x * sz_max_box) max_alig. *)
(*   Proof. *)
(*     intros. *)
(*     unfold addr_aligned in *. *)
(*     change (2^max_alig) with sz_max_box. *)
(*     rewrite Nat.mod_add; auto. *)
(*     auto with cp. *)
(*   Qed. *)

(*   Fixpoint witness_rec (L : AMem) (from : nat) := *)
(*     match L with *)
(*     | nil => nil *)
(*     | e ::l =>  *)
(*       (@mk_acmem from (size e)  ) :: witness_rec l (from + ((nbox (size e)) * sz_box)) *)
(*     end. *)
      

(*   Lemma is_max_aligned_O :  *)
(*     forall a, addr_aligned O a. *)
(*   Proof. *)
(*     unfold addr_aligned. *)
(*     intros; apply Nat.mod_0_l. *)
(*     generalize (two_power a) ; lia. *)
(*   Qed. *)

(*   Lemma addr_align_le : *)
(*     forall a m n *)
(*       (LE : a <= m) *)
(*         (AL : addr_aligned n m), *)
(*         addr_aligned n a. *)
(*   Proof. *)
(*     unfold addr_aligned. *)
(*     intros. *)
(*     assert (DIFF : 2 ^ m <> 0). *)
(*     { generalize (two_power m). lia. *)
(*     } *)
(*     assert (DIFF2 : 2 ^ a <> 0). *)
(*     { generalize (two_power a). lia. *)
(*     } *)
(*     rewrite Nat.mod_divides in AL; auto. *)
(*     destruct AL. *)
(*     subst. *)
(*     replace (2^m * x) with (0 + (x * 2^(m-a)) * 2^a). *)
(*     rewrite Nat.mod_add; auto. *)
(*     rewrite Nat.mod_divides; auto. exists 0 ; ring. *)
(*     rewrite <- mult_assoc. *)
(*     rewrite <- Nat.pow_add_r. *)
(*     replace (m - a + a) with m by lia. *)
(*     ring. *)
(*   Qed. *)

(*   Lemma size_box : *)
(*     forall a,  a <= nbox a * sz_box. *)
(*   Proof. *)
(*     unfold nbox,sz_box. *)
(*     intros. *)
(*     unfold ceiling. *)
(*     case_eq (a mod 2 ^ sz_box_log). *)
(*     intros. *)
(*     rewrite <- Nat.div_exact in H. *)
(*     lia. generalize (two_power sz_box_log) ; lia. *)
(*     intros. *)
(*     assert ( 2^ sz_box_log <> 0). *)
(*     { generalize (two_power sz_box_log). lia. } *)
(*     generalize (div_mod a (2 ^sz_box_log) H0). *)
(*     generalize (mod_bound_pos a (2^sz_box_log)). *)
(*     lia. *)
(*   Qed. *)

    
  
(*   Definition diff (x y : nat) := max x y - min x y. *)


(*   Record is_box (ab : ACblock) := *)
(*     { *)
(*       is_box_aligned : addr_aligned (ac_addr ab) sz_box_log; *)
(*       is_box_size    : ac_size ab = sz_box *)
(*     }. *)

  
(*   Inductive has_more_box : ACmem -> ACmem -> nat -> Prop := *)
(*   | has_more_box_nil  : has_more_box nil nil 0 *)
(*   | has_more_box_add : *)
(*       forall l1 l2 n e *)
(*              (HASMORE : has_more_box l2 l1 n) *)
(*              (ISSMALL : is_box e), *)
(*         has_more_box (e::l2) l1  (S n) *)
(*   | has_more_box_cons : *)
(*       forall l1 l2 n e *)
(*              (HASMORE : has_more_box l1 l2 n), *)
(*         has_more_box (e::l1) (e::l2) n. *)

(*   Definition is_small (M : ACmem) := *)
(*     forall b, In b M -> small b = true. *)


(*   Lemma is_memory_nil : is_memory []. *)
(*   Proof. *)
(*     repeat constructor. *)
(*     - simpl in H. tauto. *)
(*     - simpl ; tauto. *)
(*   Qed. *)

(*   Hint Resolve is_memory_nil : cp. *)

  
(*   Lemma diff_0_0_div : *)
(*     forall x, diff 0 0 / x = 0. *)
(*   Proof. *)
(*     destruct x ; reflexivity. *)
(*   Qed. *)
  
(*   Lemma has_more_box_same : *)
(*     forall M,  has_more_box M M 0. *)
(*   Proof. *)
(*     intro. *)
(*     induction M. *)
(*     constructor. *)
(*     constructor; auto. *)
(*   Qed. *)

  
(*   Lemma has_more_box_app : *)
(*     forall l1 l1' n1 l2 l2' n2 *)
(*            (MORE1 : has_more_box l1 l1' n1) *)
(*            (MORE2 : has_more_box l2 l2' n2), *)
(*       has_more_box (l1++l2) (l1'++l2') (n1+n2). *)
(*   Proof. *)
(*     intros. *)
(*     revert l2 l2' n2 MORE2. *)
(*     induction MORE1. *)
(*     -  simpl ; auto. *)
(*     - *)
(*       intros. *)
(*       simpl. *)
(*       apply has_more_box_add; auto. *)
(*     - intros. *)
(*       simpl. *)
(*       apply has_more_box_cons; auto.       *)
(*   Qed. *)

(*   Lemma diff_spec : *)
(*     forall x y, *)
(*       (x >= y /\ diff x y = x - y) *)
(*       \/ *)
(*       (x <= y /\ diff x y = y - x). *)
(*   Proof. *)
(*     unfold diff. *)
(*     intros. *)
(*     generalize (Max.max_spec x y). *)
(*     generalize (Min.min_spec x y). *)
(*     intuition. *)
(*   Qed.     *)
  
(*   Lemma diff_0 : *)
(*     forall x y,  *)
(*       diff x y  = 0 -> x = y. *)
(*   Proof. *)
(*     intros. *)
(*     generalize (diff_spec x y). *)
(*     lia. *)
(*   Qed. *)
  
(*   Lemma div_0 : *)
(*     forall x y, y <> 0 ->  *)
(*       x / y = 0 -> x < y. *)
(*   Proof. *)
(*     intros. *)
(*     rewrite <- Nat.mod_small_iff; auto. *)
(*     generalize (div_mod x y H). *)
(*     nia. *)
(*   Qed. *)

(*   Lemma case_last : *)
(*     forall (A: Type) (l:list A), *)
(*       l = [] *)
(*       \/ exists e l1,  l = l1 ++ [e]. *)
(*   Proof. *)
(*     induction l. *)
(*     intuition. *)
(*     destruct IHl ; intuition. *)
(*     right. exists a,nil. *)
(*     subst ; reflexivity. *)
(*     destruct H as [e [l1 EQ]]. *)
(*     right. subst. exists e, (a::l1). *)
(*     reflexivity. *)
(*   Qed. *)
    
(*   Lemma spec_of_acmem_length : *)
(*     forall l, *)
(*       List.length (spec_of_acmem l) = List.length l. *)
(*   Proof. *)
(*     induction l ; simpl ; auto. *)
(*   Qed. *)

(*   Lemma amem_free_addr_app : *)
(*     forall L L',  *)
(*       amem_free_addr (L ++ L') = *)
(*       amem_free_addr L + amem_free_addr L'. *)
(*   Proof. *)
(*     induction L ; simpl; auto. *)
(*     intros. rewrite IHL. *)
(*     lia. *)
(*   Qed. *)

(*   Lemma app2_nil : *)
(*     forall (A:Type) (l l':list A), *)
(*       l ++ l' = [] -> l = [] /\ l' = []. *)
(*   Proof. *)
(*     intros. *)
(*     apply (f_equal (@length _)) in H. *)
(*     rewrite app_length in H. *)
(*     simpl in H. *)
(*     destruct l ; destruct l' ; simpl in * ; try congruence. *)
(*     tauto. *)
(*   Qed. *)
  
(*   Lemma cmem_free_addr_app_right : *)
(*     forall L L',  *)
(*       L' <> nil ->  *)
(*       cmem_free_addr (L ++ L') = cmem_free_addr L'. *)
(*   Proof. *)
(*     induction L; simpl; auto. *)
(*     - *)
(*       intros. *)
(*       case_eq (L ++ L'). *)
(*       intros. *)
(*       destruct L ; try congruence. *)
(*       simpl in H0 ; congruence. *)
(*       simpl in H0 ; congruence. *)
(*       intros. *)
(*       rewrite <- H0. *)
(*       auto. *)
(*   Qed. *)

  
(*   Definition cmem_sum_size (L : ACmem) : nat := *)
(*     List.fold_right (fun e acc => ac_size e + acc) O L. *)

(*   Lemma cmem_sum_size_app : *)
(*     forall L L', *)
(*       cmem_sum_size (L ++ L') = cmem_sum_size L + cmem_sum_size L'. *)
(*   Proof. *)
(*     induction L ; simpl ; auto; intros. *)
(*     rewrite IHL ; auto. *)
(*     lia. *)
(*   Qed. *)

(*   Lemma sorted_app_r : *)
(*     forall l l', *)
(*       sorted_ca (l ++ l') -> sorted_ca l'. *)
(*   Proof. *)
(*     induction l; simpl; auto. *)
(*     intros. *)
(*     inv H. *)
(*     symmetry in H2. *)
(*     apply app2_nil in H2. *)
(*     destruct H2 ; subst. constructor. *)
(*     apply IHl; congruence. *)
(*   Qed. *)

(*   Lemma sorted_app_l : *)
(*     forall l l', *)
(*       sorted_ca (l ++ l') -> sorted_ca l. *)
(*   Proof. *)
(*     induction l; simpl; auto. *)
(*     - intros ; constructor. *)
(*     -  *)
(*     intros. *)
(*     inv H. *)
(*     symmetry in H2. *)
(*     apply app2_nil in H2. *)
(*     destruct H2 ; subst. constructor. *)
(*     rewrite H2 in SORTEDTAIL. *)
(*     apply IHl in SORTEDTAIL. *)
(*     destruct l ; simpl in *. *)
(*     constructor. *)
(*     constructor; auto. inv H2 ; congruence. *)
(*   Qed. *)

(*   Lemma sorted_in : *)
(*     forall li l a b l' , *)
(*       sorted_ca (l++a::li++b::l') -> *)
(*       ac_addr a + ac_size a <= ac_addr b. *)
(*   Proof. *)
(*     intro. *)
(*     induction li. *)
(*     - simpl. *)
(*       intros. *)
(*       apply sorted_app_r in H. *)
(*       inv H. auto. *)
(*     - simpl. intros. *)
(*       assert (ac_addr a + ac_size a <= ac_addr b). *)
(*       replace ((l ++ a0 :: a :: li ++ b :: l')) *)
(*       with ((l ++ [a0])++a ::li++b ::l') in H. *)
(*       apply IHli in H. auto. *)
(*       rewrite <- app_assoc. *)
(*       simpl. reflexivity. *)
(*       assert (ac_addr a0 + ac_size a0 <= ac_addr a). *)
(*       apply sorted_app_r in H. *)
(*       inv H ; auto. *)
(*       lia. *)
(*   Qed. *)

(*   Definition ac_zero :=  *)
(*     {| ac_addr := 0 ; ac_size := 0 |}. *)
  
(*   Lemma cmem_free_addr_last : *)
(*     forall L, *)
(*       cmem_free_addr L = ac_addr (last L ac_zero) + ac_size (last L ac_zero). *)
(*   Proof. *)
(*     induction L ; simpl. *)
(*     - reflexivity. *)
(*     -  destruct L. *)
(*        + simpl in IHL. *)
(*          reflexivity. *)
(*        + rewrite IHL. reflexivity. *)
(*   Qed. *)
       
(*   Lemma last_app : *)
(*     forall (A: Type) (L:list A) e d, last (L++[e]) d= e. *)
(*   Proof. *)
(*     induction L ; simpl; auto. *)
(*     intros. *)
(*     case_eq (L ++ [e]). *)
(*     intros. *)
(*     apply (f_equal (@length _)) in H. *)
(*     rewrite app_length in H. simpl in *. lia. *)
(*     intros. *)
(*     rewrite <- H ; auto. *)
(*   Qed. *)


(*   Lemma cmem_free_addr_app_left : *)
(*     forall L b,  *)
(*       sorted_ca (L ++ [b]) ->  *)
(*       cmem_free_addr (L) + ac_size b <=  ac_addr b + ac_size b. *)
(*   Proof. *)
(*     intros. *)
(*     destruct (case_last L). *)
(*     -  *)
(*       subst ; simpl ; auto.  *)
(*       lia. *)
(*     - *)
(*       destruct H0 as [e [l1 EQ]]. *)
(*       subst. rewrite cmem_free_addr_last. *)
(*       rewrite last_app. *)
(*       rewrite <- app_assoc in H. *)
(*       apply sorted_app_r in H. *)
(*       simpl in H. inv H. *)
(*       lia. *)
(*   Qed. *)


(*   Lemma spec_of_acmem_app : *)
(*     forall L L', *)
(*       spec_of_acmem (L ++ L') = spec_of_acmem L ++ spec_of_acmem L'. *)
(*   Proof. *)
(*     intro. *)
(*     induction L ; simpl ; auto. *)
(*     intros. rewrite IHL. *)
(*     reflexivity. *)
(*   Qed. *)

  
(*   Lemma spec_of_acmem_last : *)
(*     forall L b L' b', *)
(*       spec_of_acmem (L ++ [b]) = L' ++ [b'] -> *)
(*       spec_of_acmem L = L' /\ spec_of_ACblock b = b'. *)
(*   Proof. *)
(*     intro. *)
(*     remember (length L) as n eqn:EQ. *)
(*     revert L EQ. *)
(*     induction n ; simpl. *)
(*     - destruct L ; simpl ; try congruence. *)
(*       intros. *)
(*       destruct L' ; simpl in * ; intuition try congruence. *)
(*       apply (f_equal (@length _ )) in H. *)
(*       simpl in H. *)
(*       rewrite app_length in H. simpl in *. *)
(*       destruct L' ; simpl in * ; try lia. *)
(*       apply (f_equal (@length _ )) in H. *)
(*       simpl in H. *)
(*       rewrite app_length in H. simpl in *. *)
(*       destruct L' ; simpl in * ; try lia. *)
(*     -  *)
(*       destruct L ; simpl in * ; try congruence. *)
(*       intros. *)
(*       destruct L' ; simpl in *. *)
(*       apply (f_equal (@length _ )) in H. *)
(*       simpl in H. *)
(*       rewrite spec_of_acmem_length in H. *)
(*       rewrite app_length in H. simpl in *. lia. *)
(*       inv H. *)
(*       apply IHn in H2 ; intuition. *)
(*       congruence. *)
(*   Qed. *)

(*   Lemma size_ablock_pos : *)
(*     forall M B AB,  *)
(*       is_memory (M ++ [B]) ->  *)
(*       spec_of_ACblock B = AB ->  *)
(*       size AB > 0. *)
(*   Proof. *)
(*     intros. *)
(*     destruct H. *)
(*     replace (size AB) with (ac_size B). *)
(*     apply size_gt0. rewrite in_app_iff. simpl ; tauto. *)
(*     destruct B ; destruct AB ; compute in H0 ; simpl ; congruence. *)
(*   Qed. *)

(*   Lemma is_memory_app_r : *)
(*     forall M M', *)
(*       is_memory (M ++ M') -> *)
(*       is_memory M'. *)
(*   Proof. *)
(*     intros. *)
(*     destruct H. *)
(*     constructor. *)
(*     - intros. *)
(*       apply blocks_aligned0. *)
(*       rewrite in_app_iff. tauto. *)
(*     - intros. *)
(*       apply size_gt0. *)
(*       rewrite in_app_iff. tauto. *)
(*     - intros. *)
(*       apply sorted_app_r in is_sorted0. *)
(*       auto. *)
(*   Qed. *)

  
(*   Lemma is_memory_app_l : *)
(*     forall M M', *)
(*       is_memory (M ++ M') -> *)
(*       is_memory M. *)
(*   Proof. *)
(*     intros. *)
(*     destruct H. *)
(*     constructor. *)
(*     - intros. *)
(*       apply blocks_aligned0. *)
(*       rewrite in_app_iff. tauto. *)
(*     - intros. *)
(*       apply size_gt0. *)
(*       rewrite in_app_iff. tauto. *)
(*     - intros. *)
(*       apply sorted_app_l in is_sorted0. *)
(*       auto. *)
(*   Qed. *)

(*   Definition box_spec  : Bspec := *)
(*     {| size := sz_box  *)
(*     |}. *)

(*   Fixpoint boxes (n:nat) : AMem := *)
(*     match n with *)
(*     | O => nil *)
(*     | S n => box_spec :: boxes n *)
(*     end. *)

(*   Definition holes  (k : nat) (from : nat) : ACmem  := *)
(*     witness_rec (boxes k) from. *)

(*   Lemma witness_rec_aligned : *)
(*     forall L n *)
(*            (ACC   : addr_aligned n sz_box_log), *)
(*       forall b : ACblock, In b (witness_rec L n) -> is_aligned b. *)
(*   Proof. *)
(*     induction L ; simpl; try tauto. *)
(*     intros. *)
(*     intuition subst. *)
(*     constructor; simpl ; auto. *)
(*     generalize (align_of_size_bound (size a)). *)
(*     intros. *)
(*     eapply addr_align_le; eauto. *)
(*     apply IHL in H0 ; auto. *)
(*     apply aligned_add_boxes; auto. *)
(*   Qed. *)

(*   Lemma witness_rec_gt : *)
(*     forall L n  *)
(*            (ALIGN : forall x, In x L -> size x > 0), *)
(*       forall b : ACblock, In b (witness_rec L n) -> ac_size b > 0. *)
(*   Proof. *)
(*     induction L ; simpl; try tauto. *)
(*     intros. *)
(*     destruct b; destruct H; simpl in H. *)
(*     inv H ; simpl ; auto. *)
(*     apply IHL  in H ; eauto. *)
(*   Qed. *)
  
(*   Lemma boxes_gt : forall n, *)
(*       forall x : Bspec, In x (boxes n) -> size x > 0. *)
(*   Proof. *)
(*     induction n ; simpl; try tauto. *)
(*     intuition. *)
(*     unfold box_spec in H0. subst ; simpl. *)
(*     generalize sz_box_not_zero; lia. *)
(*   Qed. *)

(*   Lemma witness_rec_sorted : *)
(*     forall L n, *)
(*       sorted_ca (witness_rec L n). *)
(*   Proof. *)
(*     induction L ; simpl ; try constructor. *)
(*     - intros. *)
(*       case_eq (witness_rec L (n + nbox (size a) * sz_box)). *)
(*       constructor. *)
(*       intros. *)
(*       specialize (IHL (n + nbox (size a) * sz_box)). *)
(*       constructor. rewrite <- H. auto. *)
(*       simpl. *)
(*       destruct L ; simpl in * ; try congruence. *)
(*       inv H. simpl. *)
(*       generalize (size_box (size a)). *)
(*       lia. *)
(*   Qed. *)

(*   Lemma is_memory_holes :  *)
(*     forall n a *)
(*       (ACC   : addr_aligned a sz_box_log), *)
(*       is_memory (holes n a). *)
(*   Proof. *)
(*     intros. constructor. *)
(*     unfold holes. *)
(*     - *)
(*       apply witness_rec_aligned. *)
(*       auto. *)
(*     - *)
(*       generalize sz_box_not_zero. *)
(*       intros. *)
(*       unfold holes in H0. *)
(*       eapply witness_rec_gt; eauto. *)
(*       apply boxes_gt. *)
(*     - unfold holes. *)
(*       apply witness_rec_sorted. *)
(*   Qed. *)
    
(*   Definition acmem_first_addr (L : ACmem) : nat := *)
(*     match L with *)
(*     | nil => O *)
(*     | b::_ => ac_addr b *)
(*     end. *)

(*   Lemma is_memory_mk_app : *)
(*     forall M M', *)
(*       is_memory M  -> *)
(*       is_memory M' ->  *)
(*       (cmem_free_addr M <= acmem_first_addr M' \/ M' =[]) ->  *)
(*       is_memory (M++M'). *)
(*   Proof. *)
(*     intros. *)
(*     destruct H ; destruct H0 ; constructor. *)
(*     - intros. *)
(*     rewrite in_app_iff in H ; intuition. *)
(*     - intros. *)
(*       rewrite in_app_iff in H ; intuition. *)
(*     - clear - is_sorted0 is_sorted1 H1. *)
(*       revert  is_sorted0 is_sorted1 H1. *)
(*       revert M'. *)
(*       induction M; simpl; auto. *)
(*       + intros. *)
(*         destruct M ; destruct M'. *)
(*         * simpl ; constructor. *)
(*         * simpl. *)
(*           destruct H1 ; try congruence. *)
(*           constructor ; auto. *)
(*         * simpl. *)
(*           rewrite app_nil_r. auto. *)
(*         * simpl. *)
(*           constructor. *)
(*           apply IHM; auto. *)
(*           inv is_sorted0 ; auto. *)
(*           inv is_sorted0 ; auto. *)
(*   Qed. *)

(*   Definition next_box (a: nat) := *)
(*     nbox a * sz_box. *)

(*   Lemma next_box_aligned : *)
(*     forall n, *)
(*       addr_aligned (next_box n) sz_box_log. *)
(*   Proof. *)
(*     unfold next_box. *)
(*     intros. *)
(*     change (nbox n * sz_box) with (0 + nbox n * sz_box). *)
(*     apply aligned_add_boxes. *)
(*     unfold addr_aligned. *)
(*     apply Nat.mod_0_l. *)
(*     generalize (two_power sz_box_log ). lia. *)
(*   Qed. *)

(*   Hint Resolve next_box_aligned : cp. *)

  
(*   Lemma next_box_le : forall x, *)
(*       x <= next_box x. *)
(*   Proof. *)
(*     unfold next_box, nbox, ceiling. *)
(*     intro. *)
(*     assert (BX := sz_box_not_zero). *)
(*     case_eq (x mod sz_box). *)
(*     intros. *)
(*     rewrite Nat.mod_divides in H; auto. *)
(*     destruct H ; subst. *)
(*     rewrite (mult_comm). *)
(*     rewrite Nat.div_mul; auto. *)
(*     intros. *)
(*     generalize (div_mod x sz_box BX). *)
(*     generalize (mod_bound_pos x sz_box). *)
(*     lia. *)
(*   Qed. *)

(*   Hint Resolve next_box_le : cp. *)
  
  
(*   Lemma div_undef : forall x, 0 / x = 0. *)
(*   Proof. *)
(*     destruct x ; try reflexivity. *)
(*   Qed. *)

(*   Lemma has_more_box_list_nil : *)
(*     forall L N *)
(*       (BOXES : forall x, In x L -> is_box x), *)
(*       length L = N ->  *)
(*       has_more_box L [] N. *)
(*   Proof. *)
(*     induction L ; simpl. *)
(*     - intros ; subst; constructor. *)
(*     - intros. *)
(*       destruct N ; try congruence. *)
(*       constructor. apply IHL ; try congruence. *)
(*       intros ; apply BOXES ; tauto. *)
(*       apply BOXES ; tauto. *)
(*   Qed. *)

(*   Lemma holes_boxes : *)
(*     forall n a *)
(*            (ACC :   addr_aligned a sz_box_log), *)
(*     forall x : ACblock, *)
(*       In x (holes n a) -> is_box x. *)
(*   Proof. *)
(*     unfold holes. *)
(*     induction n ; simpl. *)
(*     - tauto. *)
(*     - intuition. *)
(*       subst. *)
(*       constructor ; auto. *)
(*       apply IHn in H0; eauto. *)
(*       apply aligned_add_boxes. auto. *)
(*   Qed. *)

(*   Lemma length_holes : *)
(*     forall n a, *)
(*       length (holes n a) = n. *)
(*   Proof. *)
(*     unfold holes. *)
(*     induction n; simpl; auto. *)
(*   Qed. *)

(*   Lemma holes_0 : *)
(*     forall a, holes 0 a = []. *)
(*   Proof. *)
(*     unfold holes. *)
(*     simpl. auto. *)
(*   Qed. *)

(*   Lemma div_eq : *)
(*     forall x y, *)
(*       y <> 0 ->  *)
(*       x = (x/y)*y + (x mod y) /\ 0 <= x mod y < y. *)
(*   Proof. *)
(*     intros. *)
(*     generalize (div_mod x y H). *)
(*     generalize (mod_bound_pos x y). *)
(*     intuition. lia. *)
(*   Qed. *)


(*   Lemma sub_ge :  *)
(*     forall L M X *)
(*            (GE : L >= M) *)
(*            (N  : X <> 0), *)
(*       L - M = ((L / X - M / X) * X + L mod X) - M mod X. *)
(*   Proof. *)
(*     intros. *)
(*     destruct (@div_eq L X N) as [HLM HLM']. *)
(*     destruct (@div_eq M X N) as [HM HM']. *)
(*     rewrite HLM at 1. *)
(*     rewrite HM at 1. *)
(*     assert (L / X >= M / X). *)
(*     nia. *)
(*     assert (L / X * X >= M / X * X) by nia. *)
(*     rewrite Nat.sub_add_distr. *)
(*     replace (L / X * X + L mod X - M / X * X) with *)
(*     (L / X * X - M / X * X + L mod X) by lia. *)
(*     rewrite mult_minus_distr_r. reflexivity. *)
(*   Qed. *)
    

(*   Lemma next_block_gap : *)
(*     forall LM MM *)
(*       (D : LM >= MM) *)
(*       (MAX: addr_aligned LM  sz_box_log), *)
(*       next_box MM + (LM - MM) / sz_box * sz_box = LM. *)
(*   Proof. *)
(*     unfold next_box. *)
(*     intros. *)
(*     unfold addr_aligned in MAX. *)
(*     change (2^sz_box_log) with sz_box in *. *)
(*     unfold nbox. *)
(*     unfold ceiling. *)
(*     assert (GT := sz_box_not_zero). *)
(*     intros. *)
(*     rewrite Nat.mod_divides in MAX ; auto. *)
(*     destruct MAX. *)
(*     rewrite H in *. *)
(*     case_eq (MM mod sz_box). *)
(*     *  *)
(*       intros. *)
(*       rewrite <- Nat.div_exact in H0; auto. *)
(*       rewrite H0 at 2. *)
(*       rewrite <- mult_minus_distr_l. *)
(*       rewrite (mult_comm sz_box). *)
(*       rewrite Nat.div_mul. *)
(*       rewrite (mult_comm (x - MM / sz_box)). *)
(*       rewrite mult_minus_distr_l. *)
(*       nia. *)
(*       apply sz_box_not_zero. *)
(*     * *)
(*       intros. *)
(*       subst. *)
(*       destruct (@div_eq MM sz_box GT). *)
(*       rewrite H at 2. *)
(*       replace ((sz_box * x - (MM / sz_box * sz_box + MM mod sz_box))) *)
(*       with ((sz_box * x - MM / sz_box * sz_box) - MM mod sz_box) by lia. *)
(*       replace ((sz_box * x - MM / sz_box * sz_box - MM mod sz_box)) *)
(*       with  ((sz_box - MM mod sz_box) + ((x - (MM / sz_box) - 1)) * sz_box). *)
(*       rewrite Nat.div_add; auto. *)
(*       simpl. ring_simplify. *)
(*       rewrite (Nat.div_small (sz_box - MM mod sz_box)) by lia. *)
(*       nia.  nia. *)
(*   Qed. *)

  
(*   Lemma  next_block_le : *)
(*     forall LM MM *)
(*            (GE : MM <= LM) *)
(*            (MAX: addr_aligned LM  sz_box_log) *)
(*     , *)
(*       next_box MM <= LM. *)
(*   Proof. *)
(*     intros. *)
(*     unfold next_box. *)
(*     unfold nbox. *)
(*     unfold ceiling. *)
(*     assert (GT := sz_box_not_zero). *)
(*     case_eq (MM mod sz_box). *)
(*     *  *)
(*       intros. *)
(*       rewrite <- Nat.div_exact in H; auto. *)
(*       rewrite mult_comm in H. rewrite <- H. *)
(*       lia. *)
(*     * *)
(*       intros. *)
(*       simpl. *)
(*       unfold addr_aligned in MAX. *)
(*       change (2^sz_box_log) with sz_box in *. *)
(*       rewrite Nat.mod_divides in MAX ; auto. *)
(*       destruct MAX. *)
(*       subst. *)
(*       assert (MM / sz_box < x \/ MM / sz_box = x). *)
(*       { generalize (@div_eq MM sz_box GT). *)
(*         nia. *)
(*       } *)
(*       destruct H0. *)
(*       generalize (@div_eq MM sz_box GT). *)
(*       nia. *)
(*       assert (MM / sz_box < x). *)
(*       generalize (@div_eq MM sz_box GT). *)
(*       nia. lia. *)
(*   Qed. *)

(*   Lemma nbox_sz_box : nbox sz_box = 1. *)
(*   Proof. *)
(*     unfold nbox. *)
(*     unfold ceiling. *)
(*     rewrite Nat.mod_same. *)
(*     replace sz_box with (1 * sz_box) at 1. *)
(*     rewrite Nat.div_mul. reflexivity. *)
(*     apply sz_box_not_zero. *)
(*     ring. *)
(*     apply sz_box_not_zero. *)
(*   Qed. *)

(*   Lemma nbox_small : *)
(*     forall x *)
(*            (SMALL : 0 < x < sz_box), *)
(*       nbox x = 1. *)
(*   Proof. *)
(*     unfold nbox. *)
(*     unfold ceiling. *)
(*     intros. *)
(*     rewrite Nat.mod_small ; try lia. *)
(*     destruct x. lia. *)
(*     rewrite Nat.div_small ; try lia. *)
(*   Qed. *)
    
  
(*   Lemma  cmem_free_addr_holes : *)
(*     forall N X *)
(*            (MAX: addr_aligned X  sz_box_log) *)
(*            (GT : N > 0) *)
(*     , *)
(*            cmem_free_addr (holes N X) = X + N * sz_box. *)
(*   Proof. *)
(*     unfold holes. *)
(*     induction N. *)
(*     - intros ;lia. *)
(*     - intros. *)
(*       simpl. *)
(*       case_eq (witness_rec (boxes N) (X + nbox sz_box * sz_box)). *)
(*       intros. *)
(*       change (holes N (X + nbox sz_box * sz_box)=[]) in H. *)
(*       apply (f_equal (@length _)) in H. *)
(*       rewrite length_holes in H. simpl in H ; subst. *)
(*       ring. *)
(*       intros. *)
(*       rewrite <- H. *)
(*       rewrite IHN. *)
(*       rewrite nbox_sz_box. *)
(*       ring. *)
(*       apply aligned_add_boxes. auto. *)
(*       change (holes N (X + nbox sz_box * sz_box)=a::l) in H. *)
(*       apply (f_equal (@length _)) in H. *)
(*       simpl in H. *)
(*       rewrite length_holes in H. simpl in H ; subst. *)
(*       lia. *)
(*   Qed. *)
        
(*   Lemma addr_aligned_amem_free_addr : *)
(*     forall l,  *)
(*       addr_aligned (amem_free_addr l) max_alig. *)
(*   Proof. *)
(*     induction l ; simpl ; auto. *)
(*     - apply is_max_aligned_O. *)
(*     -  rewrite plus_comm. *)
(*        apply aligned_add_boxes_max; auto. *)
(*   Qed. *)

(*   Lemma sorted_app_mk : *)
(*     forall L L', *)
(*       sorted_ca L  -> *)
(*       sorted_ca L' ->  *)
(*       (forall x x', In x L -> In x' L' -> *)
(*                     ac_addr x + ac_size x <= ac_addr x') -> *)
(*       sorted_ca (L ++ L'). *)
(*   Proof. *)
(*     intros until 1. *)
(*     revert L'. *)
(*     induction H. *)
(*     - *)
(*       simpl ; auto. *)
(*     - *)
(*       simpl. *)
(*       destruct L' ; simpl ; constructor; auto. *)
(*     -  *)
(*       simpl. *)
(*       intros ; constructor ; auto. *)
(*       change (b :: l ++ L') with ((b::l) ++ L'). *)
(*       apply IHsorted_ca ; auto. *)
(*   Qed. *)
      
(*   Lemma sorted_holes : forall n a,  *)
(*       sorted_ca (holes n a). *)
(*   Proof. *)
(*     unfold holes. *)
(*     intros. apply witness_rec_sorted. *)
(*   Qed. *)

(*   Lemma in_holes_addr : *)
(*     forall n a x, *)
(*       In x (holes n a) -> *)
(*       a <= ac_addr x. *)
(*   Proof. *)
(*     unfold holes. *)
(*     induction n ; simpl ; auto. *)
(*     - tauto. *)
(*     - intuition subst. *)
(*       +  *)
(*       simpl. auto. *)
(*       + apply IHn in H0; auto. *)
(*         lia. *)
(*   Qed. *)
    
(*   Lemma in_sorted_last : *)
(*     forall L B x, *)
(*       sorted_ca (L++[B]) -> *)
(*       In x (L++[B]) -> *)
(*       ac_addr x + ac_size x <= ac_addr B + ac_size B. *)
(*   Proof. *)
(*     intros until 1. *)
(*     remember (L ++ [B]). *)
(*     revert x L B Heql. *)
(*     induction H. *)
(*     - *)
(*       intros. *)
(*       simpl in H ; tauto. *)
(*     - *)
(*       intros. *)
(*       destruct L; simpl in * ; intuition. *)
(*       inv Heql. subst ; auto. *)
(*       exfalso. *)
(*       apply ((f_equal (@length _))) in Heql. *)
(*       simpl in Heql. *)
(*       rewrite app_length in Heql. simpl in Heql. lia. *)
(*     - *)
(*       intros. *)
(*       destruct L. *)
(*       simpl in Heql ; congruence. *)
(*       inv Heql. *)
(*       assert (forall x, In x (b::l) -> *)
(*                         ac_addr x + ac_size x<= ac_addr B + ac_size B). *)
(*       { *)
(*         intros. *)
(*         eapply IHsorted_ca ; eauto. *)
(*       } *)
(*       assert (x = a0 \/ In x (b ::l)). *)
(*       simpl in * ; intuition. *)
(*       destruct H2 ; subst. *)
(*       assert (ac_addr b + ac_size b <= ac_addr B + ac_size B). *)
(*       apply H1. simpl ; tauto. *)
(*       lia. *)
(*       apply H1 ; auto. *)
(*   Qed. *)
      
(*   Lemma free_block_end : *)
(*     forall *)
(*       (L : AMem) *)
(*       (M : ACmem) *)
(*       (LM MM : nat) *)
(*       (LMax  : LM = amem_free_addr L) *)
(*       (MMax  : MM = cmem_free_addr M) *)
(*       (MEM   : is_memory M) *)
(*       (GE    : LM >= MM) *)
(*       (MATCH : spec_of_acmem M = L) *)
(*     , *)
(*     exists (MA : ACmem), *)
(*       is_memory MA /\ *)
(*       has_more_box MA M  ( (LM - MM) / sz_box) /\ *)
(*       cmem_free_addr MA <= LM. *)
(*   Proof. *)
(*     (**  *)
(*            L  : [------------------] *)
(*            M  : [--------]  (......)   *)
(*      *) *)
(*     intros. *)
(*     destruct (case_last M) as [MCASE | MCASE]; *)
(*       destruct (case_last L) as [LCASE | LCASE]. *)
(*     - subst. simpl in *. *)
(*       exists nil. *)
(*       split ;[|split]. *)
(*       + apply is_memory_nil. *)
(*       + rewrite Nat.div_0_l by auto with cp. *)
(*         constructor. *)
(*       +  simpl ; auto. *)
(*     - subst. simpl in *. *)
(*       destruct LCASE as [E [L' LCASE]]. *)
(*       destruct L' ; simpl in LCASE ;  congruence. *)
(*     - subst. *)
(*       destruct MCASE as [B [M' MCASE]]. *)
(*       subst. destruct M' ; simpl in LCASE ; congruence. *)
(*     -  *)
(*       destruct MCASE as [B [M' MCASE]]. *)
(*       destruct LCASE as [AB [L' LCASE]]. *)
(*       rewrite LCASE in *. rewrite MCASE in *. *)
(*       apply spec_of_acmem_last in MATCH. *)
(*       rewrite amem_free_addr_app in LMax. *)
(*       simpl in LMax. *)
(*       ring_simplify in LMax. *)
(*       rewrite cmem_free_addr_app_right in MMax *)
(*           by (try congruence; destruct MEM ; auto). *)
(*       simpl in MMax. *)
(*       assert (SIZE : size AB = ac_size B). *)
(*         { *)
(*           destruct MATCH. *)
(*           destruct B ; destruct AB ; compute in H0 ; simpl ; congruence. *)
(*         } *)
(*         assert (GT : size AB > 0) by (eapply size_ablock_pos ; eauto; tauto). *)
(*         exists (M ++ holes ((LM - MM) / sz_box) (next_box (ac_addr B + ac_size B))). *)
(*         { *)
(*           split;[|split]. *)
(*           -  *)
(*             apply is_memory_mk_app; auto. *)
(*             congruence. *)
(*             apply is_memory_holes. *)
(*             apply next_box_aligned. *)
(*             rewrite MCASE. *)
(*             rewrite cmem_free_addr_app_right by (destruct MEM ; auto ; congruence). *)
(*             simpl. *)
(*             destruct ((LM - MM) / sz_box). *)
(*             + *)
(*             right ; reflexivity. *)
(*             + left. *)
(*               simpl. *)
(*               apply next_box_le. *)
(*           - rewrite MCASE. *)
(*             change (((LM - MM) / sz_box)) *)
(*             with (0 + (LM - MM) / sz_box). *)
(*             replace (M' ++ [B]) with ((M'++[B]) ++ []) at 2. *)
(*             apply has_more_box_app. *)
(*             apply has_more_box_same. *)
(*             apply has_more_box_list_nil. *)
(*             apply holes_boxes. *)
(*             apply next_box_aligned. *)
(*             apply length_holes. *)
(*             rewrite app_nil_r. auto. *)
(*           - rewrite MCASE. *)
(*               case_eq (((LM - MM) / sz_box)). *)
(*               rewrite holes_0. *)
(*               rewrite app_nil_r. *)
(*               rewrite cmem_free_addr_app_right. *)
(*               simpl. lia. *)
(*               simpl ; congruence. *)
(*               destruct MEM ; auto. *)
(*               intros. *)
(*               rewrite cmem_free_addr_app_right. *)
(*               rewrite <- H. *)
(*               rewrite cmem_free_addr_holes. *)
(*               rewrite <- MMax. *)
(*               rewrite next_block_gap. lia. *)
(*               auto.  *)
(*               subst. *)
(*               eapply addr_align_le. apply sz_box_small. *)
(*               apply aligned_add_boxes_max. *)
(*               apply addr_aligned_amem_free_addr. *)
(*               apply next_box_aligned. *)
(*               lia. *)
(*               unfold holes. *)
(*               simpl. congruence. *)
(*           } *)
(*   Qed. *)


(*   Lemma is_memory_singleton : *)
(*     forall B, *)
(*       is_aligned B ->  *)
(*       ac_size B > 0 ->  *)
(*       is_memory [B]. *)
(*   Proof. *)
(*     intros. constructor ; simpl ; intros ; intuition try congruence. *)
(*     constructor. *)
(*   Qed. *)
    
(*   Lemma has_more_box_holes : *)
(*     forall n a, *)
(*       addr_aligned a sz_box_log ->  *)
(*       has_more_box (holes n a) [] n. *)
(*   Proof. *)
(*     intros. *)
(*     apply has_more_box_list_nil. *)
(*     intros. *)
(*     eapply holes_boxes ; eauto. *)
(*     rewrite length_holes. *)
(*     reflexivity. *)
(*   Qed. *)

(*   Ltac mem_app  := *)
(*     match goal with *)
(*     | |- is_memory ((?A ++ ?B) ++ ?C) => *)
(*       assert (MEMAB : is_memory (A++ B)); *)
(*         [| apply is_memory_mk_app ; auto with cp] *)
(*     end. *)
    
(*   Lemma has_more_box_nil_l : *)
(*     forall M N,  *)
(*       has_more_box [] M N -> N = 0 /\ M = []. *)
(*   Proof. *)
(*     intros. *)
(*     inv H. auto. *)
(*   Qed. *)

(*   Definition cmem_first_addr (L : ACmem) : nat := *)
(*     match L with *)
(*     | nil => O *)
(*     | e::L => ac_addr e *)
(*     end. *)
  
(*   Lemma sorted_first_last : *)
(*     forall L, *)
(*       sorted_ca L ->  *)
(*       cmem_first_addr L <= cmem_free_addr L. *)
(*   Proof. *)
(*     intros. *)
(*     induction H ; simpl. *)
(*     -  auto. *)
(*     - lia. *)
(*     - destruct l. *)
(*       simpl in *. *)
(*       lia. *)
(*       unfold cmem_first_addr in IHsorted_ca. *)
(*       change (b:: (a0::l)) with ([b]++(a0::l)) in IHsorted_ca. *)
(*       rewrite cmem_free_addr_app_right in IHsorted_ca. *)
(*       lia. *)
(*       simpl ; congruence. *)
(*   Qed. *)

(*   Lemma is_memory_first_last : *)
(*     forall L, *)
(*       is_memory L ->  *)
(*       cmem_first_addr L <= cmem_free_addr L. *)
(*   Proof. *)
(*     intros. *)
(*     apply sorted_first_last. *)
(*     destruct H ; auto. *)
(*   Qed. *)
  
(*   Lemma is_box_is_aligned :  *)
(*     forall b, is_box b -> *)
(*          is_aligned b. *)
(*   Proof. *)
(*     intros. *)
(*     destruct H. *)
(*     constructor. *)
(*     eapply addr_align_le with (2:= is_box_aligned0). *)
(*     apply align_of_size_bound. *)
(*   Qed. *)
    
(*   Inductive sublist (A : Type) : list A -> list A -> Prop := *)
(*   | sublist_nil : sublist nil nil *)
(*   | sublist_cons : forall l l' e (SUB : sublist l l'), *)
(*       sublist (e::l) (e::l') *)
(*   | sublist_add : forall l l' e' (SUB : sublist l l'), *)
(*       sublist l (e'::l'). *)
  
(*   Lemma has_more_box_le : *)
(*     forall M' M N N' *)
(*            (MEMM  : is_memory M) *)
(*            (MEMM' : is_memory M') *)
(*            (MORE  : has_more_box M' M N) *)
(*            (LE   : N' <= N), *)
(*     exists M'', has_more_box M'' M N' *)
(*                 /\ sublist M'' M'. *)
(*   Proof. *)
(*     intros until 3. revert  N'. *)
(*     induction MORE;intros. *)
(*     -  replace N' with  0 by lia. *)
(*        exists []. *)
(*        split ; auto.   *)
(*        apply has_more_box_same. *)
(*        constructor. *)
(*     - *)
(*       destruct N'. *)
(*       + *)
(*         change (e::l2) with ([e]++l2) in MEMM'. *)
(*         apply is_memory_app_r in MEMM'. *)
(*         assert (0 <= n) by lia. *)
(*         destruct (IHMORE MEMM MEMM' _ H). *)
(*         exists x ; intuition. *)
(*         apply sublist_add; auto. *)
(*       +  *)
(*         change (e::l2) with ([e]++l2) in MEMM'. *)
(*         apply is_memory_app_r in MEMM'. *)
(*         assert (N' <= n) by lia. *)
(*         destruct (IHMORE MEMM MEMM' _ H). *)
(*         exists (e::x) ; intuition. *)
(*         constructor; auto. *)
(*         apply sublist_cons; auto. *)
(*     -   *)
(*         change (e::l2) with ([e]++l2) in MEMM. *)
(*         apply is_memory_app_r in MEMM. *)
(*         change (e::l1) with ([e]++l1) in MEMM'. *)
(*         apply is_memory_app_r in MEMM'. *)
(*         destruct (IHMORE MEMM MEMM' _ LE). *)
(*         exists (e::x) ; intuition. *)
(*         apply has_more_box_cons. auto. *)
(*         apply sublist_cons; auto. *)
(*   Qed. *)
      
(*   Lemma sublist_in : *)
(*     forall (A:Type) (M M':list A) *)
(*            (SUB : sublist M' M) *)
(*            x, *)
(*       In x M' -> In x M. *)
(*   Proof. *)
(*     intros until 1. *)
(*     induction SUB. *)
(*     -  simpl ; auto. *)
(*     - simpl. intuition. *)
(*     - simpl ; intuition. *)
(*   Qed. *)
    

(*   Lemma sublist_nil_r : *)
(*     forall (A:Type) (M: list A) *)
(*            (SUB : sublist M []), *)
(*       M = []. *)
(*   Proof. *)
(*     intros. *)
(*     induction M; auto. *)
(*     inv SUB. *)
(*   Qed. *)

(*   Lemma sublist_addr : *)
(*     forall L L' *)
(*            (SORT: sorted_ca L) *)
(*            (NOTNIL : L' <> []) *)
(*            (SUB : sublist L' L), *)
(*       acmem_first_addr L <= acmem_first_addr L'. *)
(*   Proof. *)
(*     intros until 1. *)
(*     revert L'. *)
(*     induction SORT. *)
(*     - intros. *)
(*       apply sublist_nil_r in SUB. *)
(*       subst ; simpl ; auto. *)
(*     - intros. *)
(*       inv SUB. *)
(*       simpl ; auto. *)
(*       apply sublist_nil_r in SUB0. *)
(*       congruence. *)
(*     - intros. *)
(*       inv SUB. *)
(*       simpl ; auto. *)
(*       simpl. *)
(*       apply IHSORT in SUB0; auto. *)
(*       simpl in SUB0. lia. *)
(*   Qed. *)
      
(*   Lemma sublist_sorted : *)
(*     forall M M' *)
(*            (SORT : sorted_ca M) *)
(*            (SUB : sublist M' M), *)
(*       sorted_ca M'. *)
(*   Proof. *)
(*     intros. *)
(*     revert SORT. *)
(*     induction SUB. *)
(*     - constructor. *)
(*     - intros. *)
(*       destruct l. *)
(*       constructor. *)
(*       constructor. *)
(*       apply IHSUB. *)
(*       inv SORT ; auto. *)
(*       constructor. *)
(*       inv SORT. *)
(*       inv SUB. *)
(*       apply sublist_addr in SUB; auto. *)
(*       +  simpl in SUB. lia. *)
(*       +  congruence. *)
(*     - intuition. *)
(*       apply IHSUB. *)
(*       inv SORT ; auto. *)
(*       constructor. *)
(*   Qed. *)

(*   Lemma is_memory_sublist : *)
(*     forall M M' *)
(*            (MEM : is_memory M) *)
(*            (SUB : sublist M' M), *)
(*       is_memory M'. *)
(*   Proof. *)
(*     intros. *)
(*     destruct MEM. *)
(*     constructor. *)
(*     - *)
(*       intros. apply blocks_aligned0. *)
(*       eapply sublist_in ; eauto. *)
(*     - intros. *)
(*       eapply size_gt0; eauto. *)
(*       eapply sublist_in ; eauto. *)
(*     - apply sublist_sorted in SUB; auto. *)
(*   Qed. *)
      

(*   Lemma sublist_app_elt : *)
(*     forall (A:Type) (l l':list A) e *)
(*            (SUB : sublist l' (l++[e])), *)
(*       sublist l' l \/ exists l'', l' = l''++[e]. *)
(*   Proof. *)
(*     induction l; intros. *)
(*     - simpl in SUB. *)
(*       inv SUB. *)
(*       inv SUB0. *)
(*       right. exists nil. reflexivity. *)
(*       inv SUB0. left ; constructor. *)
(*     - simpl in SUB. *)
(*       inv SUB. *)
(*       + *)
(*       apply IHl in SUB0. destruct SUB0. *)
(*       * *)
(*       left ; constructor; auto. *)
(*       * *)
(*       destruct H. *)
(*       right ; subst. *)
(*       exists (a::x). reflexivity. *)
(*       +  *)
(*       apply IHl in SUB0. destruct SUB0. *)
(*       * *)
(*       left ; constructor; auto. *)
(*       * *)
(*       destruct H. *)
(*       right ; subst. *)
(*       exists x. reflexivity. *)
(*   Qed. *)
      
(*   Lemma sublist_cmem_free_addr : *)
(*     forall L L' *)
(*            (SORTL : sorted_ca L) *)
(*            (SORTL' : sorted_ca L')            *)
(*            (SUB : sublist L' L), *)
(*       cmem_free_addr L' <= cmem_free_addr L. *)
(*   Proof. *)
(*     intro. *)
(*     remember (length L) as n eqn:EQ. *)
(*     revert L EQ. *)
(*     induction n. *)
(*     - *)
(*       intros. *)
(*       destruct L ; simpl in EQ ; try congruence. *)
(*       inv SUB ; simpl ; auto. *)
(*     -  *)
(*     intros. *)
(*     destruct (case_last L). *)
(*     subst. simpl in EQ ; congruence. *)
(*     destruct H as [e [LL HL]]. *)
(*     subst. *)
(*     apply sublist_app_elt in SUB. *)
(*     destruct SUB. *)
(*     apply IHn in H. *)
(*     apply cmem_free_addr_app_left in SORTL. *)
(*     rewrite  cmem_free_addr_app_right. simpl ; lia. *)
(*     congruence. *)
(*     rewrite app_length in EQ ; simpl in EQ ; lia. *)
(*     apply sorted_app_l in SORTL ; auto. *)
(*     auto. *)
(*     destruct H. *)
(*     subst. *)
(*     repeat rewrite  cmem_free_addr_app_right by congruence. *)
(*     lia. *)
(*   Qed. *)

(*   Lemma max_aligned_box : *)
(*     forall N *)
(*       (MAX  : addr_aligned N sz_box_log), *)
(*     exists K, K * sz_box = N. *)
(*   Proof. *)
(*     unfold addr_aligned. *)
(*     intros. *)
(*     change (2^sz_box_log) with sz_box in MAX. *)
(*     rewrite <- Nat.div_exact in MAX. *)
(*     exists (N / sz_box). *)
(*     lia. *)
(*     apply sz_box_not_zero. *)
(*   Qed. *)
    
(*   Lemma next_box_exact :  *)
(*     forall MM LM *)
(*            (MAX  : addr_aligned LM sz_box_log) *)
(*            (MAX' : addr_aligned MM sz_box_log), *)
(*       (LM - MM) / sz_box * sz_box = LM - MM. *)
(*   Proof. *)
(*     intros. *)
(*     apply max_aligned_box in MAX. *)
(*     apply max_aligned_box in MAX'. *)
(*     destruct MAX as [K MAX]. *)
(*     destruct MAX' as [K' MAX']. *)
(*     subst. *)
(*     rewrite <- mult_minus_distr_r. *)
(*     rewrite Nat.div_mul. reflexivity. *)
(*     apply sz_box_not_zero. *)
(*   Qed. *)

(*   Lemma div_next_box : *)
(*     forall LM MM *)
(*       (D : LM >= MM) *)
(*       (MAX: addr_aligned LM  sz_box_log), *)
(*       (LM - next_box MM) / sz_box = (LM - MM) / sz_box. *)
(*   Proof. *)
(*     intros. *)
(*     apply next_block_gap with (MM := MM) in MAX; auto. *)
(*     assert (LM - next_box MM =  (LM - MM) / sz_box * sz_box) by lia. *)
(*     rewrite H. *)
(*     rewrite Nat.div_mul; auto. *)
(*     apply sz_box_not_zero. *)
(*   Qed. *)

  
(*   Lemma next_box_0 : next_box 0 = 0. *)
(*   Proof. *)
(*     unfold next_box. *)
(*     unfold nbox. *)
(*     unfold ceiling. *)
(*     rewrite Nat.mod_0_l. *)
(*     destruct sz_box ; reflexivity. *)
(*     apply sz_box_not_zero. *)
(*   Qed. *)

(*   (* For aligned adresses *) *)
(*   Lemma nbox_add : *)
(*     forall K B, *)
(*       nbox (K * sz_box + B) = K + nbox B. *)
(*   Proof. *)
(*     unfold nbox, ceiling. *)
(*     intros. *)
(*     assert (NZ := sz_box_not_zero). *)
(*     rewrite plus_comm. *)
(*     rewrite Nat.mod_add; auto. *)
(*     destruct (B mod sz_box). *)
(*     rewrite Nat.div_add; auto. *)
(*     ring. *)
(*     rewrite Nat.div_add; auto. *)
(*     ring. *)
(*   Qed. *)

(*   Lemma ltb_false :  *)
(*     forall n m : nat, (n <? m) = false -> ~ n < m. *)
(*   Proof. *)
(*     repeat intro. *)
(*     case_eq (n <? m) ; intros. *)
(*     congruence. *)
(*     rewrite <- ltb_lt in H0. *)
(*     congruence. *)
(*   Qed. *)
  
(*   Lemma align_of_size_small : *)
(*     forall s *)
(*            (NZ : s > 0) *)
(*            (SMALL : s < sz_box), *)
(*       align_of_size s <= S (log2 s). *)
(*   Proof. *)
(*     unfold align_of_size. *)
(*     intros. *)
(*     case_eq ( s <? sz_box); auto. *)
(*     -  *)
(*       intros. *)
(*       unfold log2_ceil. *)
(*       destruct (beq_nat (2 ^ log2 s) s || beq_nat (log2 s) 0); *)
(*         lia. *)
(*     - *)
(*       intros. *)
(*       apply ltb_false in H. *)
(*       lia. *)
(*   Qed. *)

(*   Lemma mod_divides : *)
(*     forall a b c *)
(*       (NZ : a <> 0) *)
(*       (MUL : c mod a = 0) *)
(*       (DIV : c / a <> 0) *)
(*     , *)
(*       exists r, (a * b) mod c = r * a /\ r * a < c. *)
(*   Proof. *)
(*     intros. *)
(*     rewrite <- Nat.div_exact in MUL; auto. *)
(*     rewrite MUL. *)
(*     rewrite Nat.mul_mod_distr_l; auto. *)
(*     exists (b mod (c / a)). *)
(*     split. *)
(*     -  *)
(*     ring. *)
(*     -  destruct b. *)
(*        + *)
(*          rewrite Nat.mod_0_l ; auto. *)
(*          nia. *)
(*        +  *)
(*          generalize (Nat.mod_bound_pos (S b) (c / a)). *)
(*          nia. *)
(*   Qed. *)
  
(*   Lemma add_eps : *)
(*     forall K L K' B s *)
(*            (GTL   : L > 0) *)
(*            (GTK   : K > 0) *)
(*            (BOX   : K*L = B) *)
(*            (SMALL : s < L), *)
(*            exists Q1, *)
(*              (K'*L + s) mod B  = Q1 * L + s. *)
(*   Proof. *)
(*     intros. *)
(*     subst. *)
(*     assert (KL : K * L <> 0) by nia. *)
(*     remember (K' * L + s) as SB eqn:EQSB. *)
(*     remember (K * L) as B eqn:EQB.     *)
(*     destruct (@div_eq SB B KL). *)
(*     revert H H0. *)
(*     generalize (SB / B) as Q'. *)
(*     generalize (SB mod B) as M'. *)
(*     intros. *)
(*     rewrite EQB in *. *)
(*     destruct (@div_eq (K' * L) (K * L) KL). *)
(*     revert H1 H2. *)
(*     generalize (K'*L / (K * L)) as QK'K. *)
(*     generalize (K'*L mod (K * L)) as MK'K. *)
(*     intros. *)
(*     rewrite H1 in EQSB. *)
(*     rewrite mult_assoc in EQSB. *)
(*     replace (QK'K * K * L + MK'K + s) with *)
(*     ((L * K) * QK'K + (MK'K + s)) in EQSB by lia. *)
(*     apply Nat.mod_unique in EQSB. *)
(*     rewrite mult_comm in H. *)
(*     apply Nat.mod_unique in H; auto. *)
(*     assert (exists I, I * L = MK'K). *)
(*     exists (K' - QK'K * K). *)
(*     nia. *)
(*     destruct H3. exists x. *)
(*     rewrite H. rewrite mult_comm. *)
(*     rewrite <- EQSB. lia. *)
(*     lia. *)
(*     subst. *)
(*     assert (exists I, MK'K = L * I). *)
(*     exists (K' - (QK'K * K)). nia. *)
(*     destruct H3. *)
(*     subst. clear H. clear H1. *)
(*     assert (x <= K - 1) by nia. *)
(*     nia. *)
(*   Qed. *)
 
(*   Lemma nbox_add_small_full : *)
(*     forall A n *)
(*            (SIZE  : addr_aligned A n) *)
(*            (SMALL : 2^n <= sz_box) *)
(*     , *)
(*       next_box (A + 2^n) = (A / sz_box) * sz_box + sz_box. *)
(*   Proof. *)
(*     unfold next_box,nbox. intros. *)
(*     unfold ceiling. *)
(*     unfold addr_aligned in SIZE. *)
(*     assert (POW : 2 ^n <> 0). *)
(*     { generalize (Nat.pow_gt_1 2 n). *)
(*       destruct n ; simpl ; lia. *)
(*     } *)
(*     rewrite <- Nat.div_exact in SIZE; auto. *)
(*     revert SIZE. *)
(*     generalize (A / 2^ n) as K. *)
(*     intros. subst. *)
(*     assert (NZ := sz_box_not_zero). *)
(*     assert (HEX : exists R, (2^n * K) mod sz_box = R * 2^n /\ R * 2^n < sz_box). *)
(*     { *)
(*       clear - SMALL POW. *)
(*       unfold sz_box in *. *)
(*       rewrite Nat.log2_le_pow2 in SMALL; try lia. *)
(*       rewrite Nat.log2_pow2 in SMALL; try lia. *)
(*       assert (exists n' , sz_box_log = n' + n). *)
(*       exists (sz_box_log - n). lia. *)
(*       destruct H as [n' EQ]. subst. *)
(*       rewrite Nat.pow_add_r; auto. *)
(*       apply mod_divides; auto.       *)
(*       rewrite Nat.mod_mul; auto. *)
(*       rewrite Nat.div_mul ; auto. *)
(*       generalize  (two_power  n'); try lia. *)
(*     } *)
(*     assert (HEX' : exists R', (2^n * (K+1)) mod sz_box = R' * 2^n /\ R' * 2^n < sz_box). *)
(*     { *)
(*       clear - SMALL POW. *)
(*       unfold sz_box in *. *)
(*       rewrite Nat.log2_le_pow2 in SMALL; try lia. *)
(*       rewrite Nat.log2_pow2 in SMALL; try lia. *)
(*       assert (exists n' , sz_box_log = n' + n). *)
(*       exists (sz_box_log - n). lia. *)
(*       destruct H as [n' EQ]. subst. *)
(*       rewrite Nat.pow_add_r; auto. *)
(*       apply mod_divides; auto.       *)
(*       rewrite Nat.mod_mul; auto. *)
(*       rewrite Nat.div_mul ; auto. *)
(*       generalize  (two_power  n'); try lia. *)
(*     } *)
(*     destruct HEX as [R [EQ BD]]. *)
(*     destruct HEX' as [R' [EQ' BD']]. *)
(*     replace (2^n * (K+ 1)) with (2^n * K + 2^n) in EQ' by ring. *)
(*     destruct (@div_eq (2^n * K) sz_box NZ) as [KEQ KMOD]. *)
(*     destruct (@div_eq (2^n * K + 2^n) sz_box NZ) as [KEQ' KMOD']. *)
(*     revert EQ BD EQ' BD' KEQ KMOD KEQ' KMOD'. *)
(*     generalize ((2^n * K) mod sz_box) as MK. *)
(*     generalize ((2^n * K + 2^n) mod sz_box) as MKp. *)
(*     generalize ((2^n * K) / sz_box) as DK. *)
(*     generalize ((2^n * K + 2^n) / sz_box) as DKp. *)
(*     intros. *)
(*     rewrite EQ in *. clear EQ. *)
(*     rewrite EQ' in * ; clear EQ'. *)
(*     rewrite KEQ in *. *)
(*     replace (R * 2^n) with *)
(*     (DKp * sz_box + R' * 2 ^ n - DK * sz_box - 2^n) in BD by lia. *)
(*     destruct R'. *)
(*     - *)
(*       simpl in *. *)
(*       assert (DKp = DK \/ (DKp  = 1+DK)) by nia. *)
(*       destruct H. *)
(*       subst. nia. *)
(*       nia. *)
(*     -  *)
(*       case_eq (S R' * 2^n). *)
(*       + *)
(*         nia. *)
(*       +  intros. *)
(*          simpl in *. *)
(*       assert (DKp = DK \/ (DKp  = 1+DK)) by nia. *)
(*       destruct H. *)
(*       subst. nia. *)
(*   Qed. *)

(*   Lemma addr_aligned_mult : *)
(*     forall N A *)
(*            (MAX  : addr_aligned N A), *)
(*     exists K, K * 2^A = N. *)
(*   Proof. *)
(*     unfold addr_aligned. *)
(*     intros. *)
(*     rewrite <- Nat.div_exact in MAX. *)
(*     exists (N / 2^A). *)
(*     lia. *)
(*     generalize (Nat.pow_nonzero 2 A); lia. *)
(*   Qed. *)

(*   Lemma pow_decomp_eq : *)
(*     forall s X *)
(*       (LT : s < 2 ^ X), *)
(*     exists K, X = (log2_ceil s) + K. *)
(*   Proof. *)
(*     intros. *)
(*     exists (X - log2_ceil s) ; try lia. *)
(*     unfold log2_ceil. *)
(*     case_eq (beq_nat (2 ^ log2 s) s || beq_nat (log2 s) 0). *)
(*     - *)
(*       unfold lt in LT. *)
(*       apply log2_mono_le in LT. *)
(*       rewrite log2_pow2 in LT. *)
(*       destruct (Nat.log2_succ_or s); lia. *)
(*     - *)
(*       intros. *)
(*       rewrite orb_false_iff in H. *)
(*       destruct H. *)
(*       rewrite beq_nat_false_iff in *. *)
(*       assert (GTS : 0 < s). *)
(*       { destruct s. *)
(*           compute in H0. lia. *)
(*           lia. *)
(*       } *)
(*       destruct (log2_spec s GTS). *)
(*       assert (log2 s < X). *)
(*       { *)
(*         apply Nat.log2_lt_pow2; auto. *)
(*       } lia. *)
(*   Qed. *)

(*   Lemma log2_ceil_bound : *)
(*     forall s *)
(*            (GT : 0 < s), *)
(*       s <= 2^ log2_ceil s. *)
(*   Proof. *)
(*     intros. *)
(*     unfold log2_ceil. *)
(*     case_eq (beq_nat (2 ^ log2 s) s || beq_nat (log2 s) 0). *)
(*     - intros. *)
(*       rewrite orb_true_iff in H. *)
(*       repeat rewrite beq_nat_true_iff in *. *)
(*       destruct H. *)
(*       lia. *)
(*       destruct s. *)
(*       compute. lia. *)
(*       destruct (Nat.log2_succ_or s). *)
(*       lia. *)
(*       destruct s. *)
(*       compute. lia. *)
(*       generalize (Nat.log2_pos (S (S s))). *)
(*       lia. *)
(*     - intros. *)
(*       rewrite orb_false_iff in H. *)
(*       repeat rewrite beq_nat_false_iff in *. *)
(*       destruct H. *)
(*       destruct (Nat.log2_spec s); auto. *)
(*       lia. *)
(*   Qed. *)

(*   (* The following lemma is fundamental for the proof. *)
(*    * It states that a small block (< sz_box), if correctly aligned, *)
(*    * does not overlap with a box boundary. *)
(*    *  *) *)
  
(*   Lemma in_box : *)
(*     forall X A s *)
(*            (AL : addr_aligned X sz_box_log) *)
(*            (SZ : 0 < s < sz_box) *)
(*            (LC : addr_aligned A (log2_ceil s)) *)
(*            (LT : A < X), *)
(*       A + s <= X. *)
(*   Proof. *)
(*     intros. *)
(*     assert (TNZ : 2 <> 0) by lia. *)
(*     apply max_aligned_box in AL. *)
(*     destruct AL as [K AL]. *)
(*     apply addr_aligned_mult in LC. *)
(*     destruct LC as [K' LC]. *)
(*     subst. *)
(*     unfold sz_box in *. *)
(*     destruct SZ as [GTS LTS]. *)
(*     destruct (@pow_decomp_eq _ _ LTS) as [K2 EQ]. *)
(*     rewrite EQ in *. *)
(*     rewrite Nat.pow_add_r in *. *)
(*     assert (K' < K * 2^K2) by nia. *)
(*     generalize (@log2_ceil_bound _ GTS). *)
(*     intros. *)
(*     nia. *)
(*   Qed. *)
  
(*   Lemma ceiling_mono : *)
(*     forall x y z *)
(*            (Nz : z <> 0) *)
(*            (Le : x <= y), *)
(*       ceiling x z <= ceiling y z. *)
(*   Proof. *)
(*     intros. *)
(*     unfold ceiling. *)
(*     generalize (@div_eq x z Nz). *)
(*     generalize (@div_eq y z Nz). *)
(*     case_eq (x mod z) ; case_eq (y mod z); intros ; nia. *)
(*   Qed. *)
  
(*   Lemma next_box_mono : *)
(*     forall x y *)
(*            (Le : x <= y), *)
(*       next_box x <= next_box y. *)
(*   Proof. *)
(*     unfold next_box. *)
(*     intros. *)
(*     apply mult_le_compat_r. *)
(*     unfold nbox. apply ceiling_mono; auto. *)
(*     apply sz_box_not_zero. *)
(*   Qed. *)
    
(*   Lemma nbox_0 : nbox 0 = 0. *)
(*   Proof. *)
(*     unfold nbox,ceiling. *)
(*     rewrite Nat.mod_0_l ; auto with cp. *)
(*     apply div_undef. *)
(*   Qed. *)

(*   Lemma nbox_add_small : *)
(*     forall A s *)
(*            (SIZE  : addr_aligned A (align_of_size s)) *)
(*            (GT    : 0 < s) *)
(*            (SMALL : s < sz_box) *)
(*     , *)
(*       next_box (A + s) = (A / sz_box) * sz_box + sz_box. *)
(*   Proof. *)
(*     intros. *)
(*     set (B := ((A / sz_box) * sz_box + sz_box)). *)
(*     assert (AL : addr_aligned B sz_box_log). *)
(*     { *)
(*       unfold B. *)
(*       unfold addr_aligned. *)
(*       unfold sz_box. *)
(*       rewrite plus_comm. *)
(*       rewrite Nat.mod_add; auto with cp. *)
(*       apply Nat.mod_same ; auto with cp. *)
(*     } *)
(*     assert (BB : next_box B  = B). *)
(*     { *)
(*       unfold B. *)
(*       unfold next_box. *)
(*       rewrite nbox_add. *)
(*       rewrite nbox_sz_box. lia. *)
(*     } *)
(*     apply le_antisym. *)
(*     -  *)
(*       assert (A < B). *)
(*       { *)
(*         generalize (@div_eq A sz_box sz_box_not_zero). *)
(*         unfold B. lia. *)
(*       } *)
(*       apply in_box with (s:=s) in H; auto. *)
(*       apply next_box_mono in H. *)
(*       lia. *)
(*       revert SIZE. *)
(*       unfold align_of_size. *)
(*       case_eq (s <? sz_box); auto. *)
(*       intros. apply ltb_false in H0 ; lia. *)
(*     - *)
(*       unfold next_box. *)
(*       destruct (@div_eq (A+s) sz_box sz_box_not_zero). *)
(*       rewrite H. *)
(*       rewrite nbox_add. *)
(*       rewrite mult_plus_distr_r. *)
(*       case_eq ((A + s) mod sz_box) ; intros. *)
(*       + *)
(*         rewrite nbox_0. *)
(*         simpl. ring_simplify. *)
(*         unfold B. *)
(*         assert (A / sz_box = (A + s) / sz_box - 1). *)
(*         { *)
(*           generalize (@div_eq A sz_box sz_box_not_zero). *)
(*           nia. *)
(*         } *)
(*         rewrite H2 in *. *)
(*         rewrite mult_minus_distr_r. *)
(*         assert (A + s < sz_box \/ A + s >= sz_box) by lia. *)
(*         destruct H3. *)
(*         rewrite Nat.div_small in H; auto. *)
(*         lia. *)
(*         lia. *)
(*       +  *)
(*         rewrite nbox_small; try lia. *)
(*         unfold B. *)
(*         assert (A / sz_box <= (A + s) / sz_box). *)
(*         { *)
(*           generalize (@div_eq A sz_box sz_box_not_zero). *)
(*           nia. *)
(*         } *)
(*         nia. *)
(*   Qed. *)
    
(*   Lemma aligned_of_size_small :  *)
(*     forall B *)
(*       (ACSIZE : B < sz_box), *)
(*       align_of_size B = log2_ceil B. *)
(*   Proof. *)
(*     unfold align_of_size. intro. *)
(*     case_eq (B <? sz_box); auto. *)
(*     intros. apply ltb_false in ACSIZE ; auto. *)
(*     tauto. *)
(*   Qed. *)
  
(*   Lemma ac_size_case : *)
(*     forall B *)
(*            (A : is_aligned B) *)
(*            (G : ac_size B > 0) *)
(*     , *)
(*       (ac_size B < sz_box /\ exists K, ac_addr B = K * 2^ (log2_ceil (ac_size B))) *)
(*       \/ *)
(*       ac_size B >= sz_box /\ exists K, ac_addr B = K * sz_box. *)
(*   Proof. *)
(*     intros. *)
(*     assert (ACSIZE : ac_size B < sz_box \/ ac_size B>= sz_box) by lia. *)
(*     destruct ACSIZE as [ACSIZE | ACSIZE]. *)
(*     - left. *)
(*       apply ac_addr_align in A. *)
(*       rewrite aligned_of_size_small in A ; auto. *)
(*       unfold addr_aligned in A. *)
(*       split ; auto. *)
(*       exists (ac_addr B / 2 ^ log2_ceil (ac_size B)). *)
(*       rewrite <- Nat.div_exact in A ; auto. *)
(*       lia. apply Nat.pow_nonzero ; lia. *)
(*     -  *)
(*     right. *)
(*     split ; auto. *)
(*     destruct A. *)
(*     unfold align_of_size in ac_addr_align0. *)
(*     revert ac_addr_align0. *)
(*     case_eq ((ac_size B) <? sz_box). *)
(*     + *)
(*       intros. rewrite ltb_lt in H. lia. *)
(*     +  *)
(*     intros. exists (ac_addr B / sz_box). *)
(*     unfold addr_aligned in ac_addr_align0. *)
(*     generalize sz_box_not_zero. *)
(*     change (2^sz_box_log) with sz_box in *. *)
(*     intro. *)
(*     rewrite <- Nat.div_exact in ac_addr_align0; auto. *)
(*     lia. *)
(*   Qed. *)


(*   Lemma ac_size_case_mem : *)
(*     forall B *)
(*            (M : is_memory [B]) *)
(*     , *)
(*       (ac_size B < sz_box /\ *)
(*        exists K, ac_addr B = K * 2^ (log2_ceil (ac_size B))) *)
(*       \/ *)
(*       ac_size B >= sz_box /\ exists K, ac_addr B = K * sz_box. *)
(*   Proof. *)
(*     intros. *)
(*     inv M. *)
(*     assert (A : is_aligned B). *)
(*     { apply blocks_aligned0 ; simpl ; tauto. } *)
(*     assert (G : ac_size B > 0). *)
(*     { apply size_gt0 ; simpl ; tauto. } *)
(*     apply ac_size_case ;auto. *)
(*   Qed. *)
    
(*   Lemma next_box_up : forall M, *)
(*       next_box M < M + sz_box. *)
(*   Proof. *)
(*     unfold next_box, nbox, ceiling. *)
(*     intros. *)
(*     assert (NZ := sz_box_not_zero). *)
(*     case_eq (M mod sz_box) ; intros. *)
(*     rewrite <- Nat.div_exact in H; auto. *)
(*     nia. *)
(*     generalize (@div_eq M sz_box NZ). *)
(*     lia. *)
(*   Qed. *)
  
(*   Lemma non_aligned_address : *)
(*     forall A B *)
(*            (AL : is_aligned B) *)
(*            (GT : ac_size B > 0) *)
(*            (LT : ac_size B < sz_box) *)
(*            (INTER : ac_addr B < next_box A), *)
(*       ac_addr B + ac_size B <= next_box A. *)
(*   Proof. *)
(*     intros. *)
(*     assert (AL' := AL). *)
(*     destruct AL. *)
(*     apply ac_size_case in AL'; auto. *)
(*     destruct AL' as [[SMALL1 SMALL2] | [BIG1 BIG2]]. *)
(*     - *)
(*       rewrite aligned_of_size_small in ac_addr_align0 ; auto. *)
(*       apply in_box; auto. *)
(*       auto with cp. *)
(*     - *)
(*       lia. *)
(*   Qed. *)

(*   Lemma next_box_is_aligned : *)
(*     forall x *)
(*            (AL : addr_aligned x sz_box_log), *)
(*       next_box x = x. *)
(*   Proof. *)
(*     intros. *)
(*     unfold next_box. *)
(*     unfold addr_aligned in AL. *)
(*     unfold nbox. *)
(*     unfold ceiling. change (2 ^sz_box_log) with sz_box in AL. *)
(*     rewrite AL. *)
(*     rewrite <- Nat.div_exact in AL ; try lia. *)
(*     auto with cp. *)
(*   Qed. *)
  
(*   Lemma next_box_idem : forall x,  *)
(*       next_box (next_box x) = next_box x. *)
(*   Proof. *)
(*     intros. *)
(*     rewrite  next_box_is_aligned; auto with cp. *)
(*   Qed. *)

(*   Lemma has_more_box_last :  *)
(*     forall MA M N e *)
(*            (MEM1 : is_memory (M++[e])) *)
(*            (MEM2 : is_memory MA) *)
(*            (MORE : has_more_box MA (M++[e]) N), *)
(*       exists X N' M', *)
(*         has_more_box M' [] N' *)
(*         /\ *)
(*         MA = X ++[e]++ M'. *)
(*   Proof. *)
(*     induction MA. *)
(*     - intros. *)
(*       apply has_more_box_nil_l in MORE. *)
(*       destruct MORE ; subst. *)
(*       apply (f_equal (@length _)) in H0. *)
(*       rewrite app_length in H0. *)
(*       simpl in H0. lia. *)
(*     - intros. *)
(*       inv MORE. *)
(*       + *)
(*         change ((a:: MA)) with ([a]++MA)  in MEM2. *)
(*         assert (MEM2' := MEM2). *)
(*         apply is_memory_app_r in MEM2'. *)
(*         apply IHMA in HASMORE;auto. *)
(*         destruct HASMORE as [X [N [E [MORE EQ]]]]. *)
(*         subst. *)
(*         exists (a::X), N,E ; auto. *)
(*       +  *)
(*         change ((a:: MA)) with ([a]++MA)  in MEM2. *)
(*         assert (MEM2' := MEM2). *)
(*         apply is_memory_app_r in MEM2'. *)
(*         destruct (case_last l2). *)
(*         subst. destruct M. *)
(*         * simpl in H. *)
(*           inv H. *)
(*           exists nil,N, MA. *)
(*           repeat split ; auto. *)
(*         * apply (f_equal (@length _)) in H. *)
(*           simpl in H. rewrite app_length in H. *)
(*           simpl in H. lia. *)
(*         * destruct H0 as [e1 [M1 EQ]]. *)
(*           subst. *)
(*           apply IHMA in HASMORE; auto. *)
(*           destruct HASMORE as [X [N' [E [MORE EQ]]]]. *)
(*           exists (a::X), N', E. *)
(*           repeat split ; auto. *)
(*           apply (f_equal (fun x => last x a)) in H. *)
(*           change (a :: M1 ++ [e1]) with ((a::M1)++ [e1]) in *. *)
(*           repeat rewrite last_app in H. *)
(*           subst ; simpl ; reflexivity. *)
(*           rewrite <- H in MEM1. *)
(*           change (a :: M1 ++ [e1]) with ([a]++(M1++ [e1])) in *. *)
(*           apply is_memory_app_r in MEM1. auto. *)
(*   Qed. *)
      
(*   Lemma has_more_box_only_box : *)
(*     forall B N b *)
(*            (MORE : has_more_box B [] N) *)
(*            (HIN : In b B), *)
(*       is_box b. *)
(*   Proof. *)
(*     induction B. *)
(*     - simpl ; tauto. *)
(*     - intros. *)
(*       inv MORE. *)
(*       simpl in *. destruct HIN  ; try congruence. *)
(*       eapply IHB ; eauto. *)
(*   Qed. *)

(*   Lemma has_more_box_cmem_free_addr : *)
(*     forall MA M' N *)
(*            (MEM1  : is_memory M') *)
(*            (MEM2  : is_memory MA) *)
(*            (MORE  : has_more_box MA M' N) *)
(*            (BOUND : cmem_free_addr MA <= next_box (cmem_free_addr M')), *)
(*       cmem_free_addr MA <= cmem_free_addr M'. *)
(*   Proof. *)
(*     intros. *)
(*     destruct (case_last M'). *)
(*     -  *)
(*       subst. *)
(*       simpl in *. *)
(*       rewrite next_box_0 in BOUND. auto. *)
(*     -  *)
(*       destruct H as [e' [M2 EQ]]. *)
(*       subst. *)
(*       rewrite cmem_free_addr_app_right by congruence. *)
(*       simpl. *)
(*       rewrite cmem_free_addr_app_right in BOUND by congruence. *)
(*       simpl in BOUND. *)
(*       assert (MORE' := MORE). *)
(*       apply has_more_box_last in MORE; auto. *)
(*       destruct MORE as [X [N' [M' [MORE EQ]]]]. *)
(*       subst. *)
(*       assert (M'=[]). *)
(*       { *)
(*         destruct (case_last M'). *)
(*         auto. *)
(*         destruct H as [e [M2' EQ]]. *)
(*         subst. *)
(*         exfalso. *)
(*         rewrite cmem_free_addr_last in BOUND. *)
(*         repeat rewrite app_assoc in BOUND. *)
(*         rewrite last_app in BOUND. *)
(*         clear MORE'. *)
(*         assert (LE : ac_addr e' + ac_size e' <= ac_addr e). *)
(*         { *)
(*           apply is_memory_app_r in MEM2. *)
(*           inv MEM2. *)
(*           apply sorted_in with (li:=M2') (l:= nil) (l':=nil). *)
(*           simpl ; auto. *)
(*         } *)
(*         assert (AL : is_box e). *)
(*         { eapply has_more_box_only_box ; eauto. *)
(*           rewrite in_app_iff. simpl ; tauto. *)
(*         } *)
(*         inv AL. *)
(*         apply next_box_mono in LE. *)
(*         rewrite (@next_box_is_aligned  (ac_addr e) ) in LE; auto. *)
(*         generalize (sz_box_not_zero). lia. *)
(*       } *)
(*       subst. *)
(*       rewrite app_nil_r. *)
(*       rewrite cmem_free_addr_app_right; simpl; auto ; congruence. *)
(*   Qed. *)
  
(*   Lemma nbox_minus : *)
(*     forall B X *)
(*            (Ge : B >= X) *)
(*            (Al : addr_aligned X sz_box_log), *)
(*       (B - X) / sz_box * sz_box = B / sz_box * sz_box - X. *)
(*   Proof. *)
(*     unfold addr_aligned. *)
(*     intros B X. *)
(*     intros. *)
(*     change (2^ sz_box_log) with sz_box in Al. *)
(*     rewrite <- Nat.div_exact in Al; auto with cp. *)
(*     destruct (@div_eq B sz_box sz_box_not_zero). *)
(*     assert ( B / sz_box * sz_box >= X \/ *)
(*              B / sz_box * sz_box < X) by lia. *)
(*     destruct H1. *)
(*     - *)
(*     assert (B - X = (B mod sz_box + (B / sz_box - X / sz_box) * sz_box)). *)
(*     nia. *)
(*     rewrite H2. *)
(*     rewrite Nat.div_add; auto. *)
(*     rewrite mult_plus_distr_r. *)
(*     rewrite mult_minus_distr_r. *)
(*     rewrite mult_comm in Al. *)
(*     rewrite <- Al. *)
(*     rewrite Nat.div_small. *)
(*     lia. *)
(*     lia. *)
(*     apply sz_box_not_zero. *)
(*     - *)
(*       rewrite Nat.div_small. *)
(*       lia. *)
(*       lia. *)
(*   Qed. *)


(*   Lemma nbigbox_small: *)
(*     forall x, 0 < x < sz_max_box -> nbigbox x = 1. *)
(*   Proof. *)
(*     unfold nbigbox. *)
(*     unfold ceiling. *)
(*     intros.  *)
(*     rewrite Nat.mod_small ; try lia. *)
(*     destruct x. lia. *)
(*     rewrite Nat.div_small ; try lia.  *)
(*   Qed. *)

  

(*   Lemma sz_box_sz_max_box: *)
(*     sz_box <= sz_max_box. *)
(*   Proof. *)
(*     unfold sz_box, sz_max_box. *)
(*     apply Nat.pow_le_mono_r; auto. *)
(*   Qed. *)
  
(*   Lemma nbigbox_small': *)
(*     forall x, 0 < x < sz_box -> nbigbox x = 1. *)
(*   Proof. *)
(*     intros. *)
(*     apply nbigbox_small. *)
(*     split. *)
(*     lia. *)
(*     eapply lt_le_trans. apply H. *)
(*     apply sz_box_sz_max_box. *)
(*   Qed. *)

(*   Lemma finer_cut_smaller: *)
(*     forall s,  *)
(*       (nbox s * sz_box <= nbigbox s * sz_max_box)%nat. *)
(*   Proof. *)
(*     unfold nbox, nbigbox. *)
(*     unfold sz_box, sz_max_box. *)
    
(*     intros.   *)

(*     Require Import Coqlib Tactics Psatz PpsimplZ IntFacts Align. *)
(*     Lemma align_mul: *)
(*       forall al (AlPos: al > 0) x, *)
(*         align (x * al) al = x * al. *)
(*     Proof. *)
(*       intros. *)
(*       unfold align. f_equal. *)
(*       eapply Zdiv_unique with (al - 1). lia. lia. *)
(*     Qed. *)
    
(*     Lemma ceiling_align: *)
(*       forall x y (Ynotnull: y <> O), *)
(*         (ceiling x y * y = Z.to_nat (align (Z.of_nat x) (Z.of_nat y)))%nat. *)
(*     Proof. *)
(*       unfold ceiling. *)
(*       intros. *)
(*       destr. *)
(*       rewrite <- Nat.div_exact in Heqn; auto. *)
(*       rewrite mult_comm in Heqn.  *)
(*       rewrite Heqn at 2. *)
(*       rewrite Nat2Z.inj_mul. *)
(*       rewrite div_Zdiv; auto. *)
(*       rewrite align_mul. zify. *)
(*       rewrite Z2Nat.id. f_equal. *)
(*       apply div_Zdiv. zify. auto. *)
(*       elim_div. intros. assert (z >= 0) by nia. nia. lia. *)
(*       unfold align. zify. *)
(*       rewrite Z2Nat.id. *)
(*       transitivity (((Z.of_nat x - 1) / Z.of_nat y + Z.of_nat y / Z.of_nat y) * Z.of_nat y). *)
(*       2: replace (Z.of_nat x + Z.of_nat y - 1) with ((Z.of_nat x - 1) + 1 * Z.of_nat y) by lia. *)
(*       2: rewrite Z_div_plus. 3: lia. *)
(*       rewrite Z.div_same by lia. *)
(*       rewrite Z.mul_add_distr_r. *)
(*       cut (Z.of_nat (x / y) * Z.of_nat y = (Z.of_nat x - 1) / Z.of_nat y * Z.of_nat y). *)
(*       intro A; rewrite A. lia. *)
(*       rewrite div_Zdiv by lia. *)
(*       assert (forall a b, b > 0 -> (a/b)*b = a - a mod b). *)
(*       { *)
(*         intros a b POS. *)
(*         generalize (Z_div_mod_eq a _ POS); lia. *)
(*       } *)
(*       rewrite  ! H7 by lia. *)
(*       cut ((Z.of_nat x) mod (Z.of_nat y) = 1 + (Z.of_nat x-1) mod Z.of_nat y). lia. *)
(*       rewrite mod_Zmod in Heqn. *)
(*       zify.  *)
(*       assert (Z.of_nat x mod Z.of_nat y > 0) by lia. *)
(*       revert Ynotnull H1 H9; clear. *)
(*       generalize (Z.of_nat x) (Z.of_nat y). *)
(*       intros. *)
(*       elim_div. intros. intuition. subst. *)
(*       assert (z2 - 1 - z4 = z0 * (z3 - z1)) by nia. *)
(*       assert (-z0 < z2 - 1 - z4 < z0) by lia. *)
(*       rewrite H0 in H2. *)
(*       assert (z1 = z3) by nia. subst. lia. lia. *)
(*       f_equal. f_equal. *)
(*       apply Z.div_same ; lia. *)
(*       apply Z.mul_nonneg_nonneg; [|lia]. *)
(*       apply Z.div_pos; lia. *)
(*     Qed. *)
(*     rewrite ! ceiling_align by (generalize (two_power sz_box_log) (two_power max_alig); lia). *)
(*     rewrite ! InstanceZ.npow_inj. simpl. *)
(*     rewrite <- ! two_power_nat_equiv. *)

(*     apply Z2Nat.inj_le. *)
(*     etransitivity. 2: apply align_le; auto. lia. apply two_power_nat_pos.  *)
(*     etransitivity. 2: apply align_le; auto. lia. apply two_power_nat_pos.  *)
(*     destruct (align_ge1 (Z.of_nat s) _ (two_power_nat_pos sz_box_log)) *)
(*       as [b [Benc [EQ EQb]]]. *)
(*     rewrite EQ. *)
(*     destruct (align_ge1 (Z.of_nat s) _ (two_power_nat_pos max_alig)) *)
(*       as [b' [Benc' [EQ' EQb']]]. *)
(*     rewrite EQ'. *)
(*     cut (b <= b'). lia. *)
(*     subst. clear EQ EQ'. *)
(*     ring_simplify. *)
(*     cut (two_power_nat sz_box_log * ((Z.of_nat s - 1) / two_power_nat sz_box_log + 1) <= *)
(*          two_power_nat max_alig * ((Z.of_nat s - 1) / two_power_nat max_alig + 1)). lia. *)
(*     assert (two_power_nat max_alig = two_power_nat sz_box_log * two_power_nat (max_alig - sz_box_log)). *)
(*     { *)
(*       rewrite ! two_power_nat_equiv. *)
(*       replace (max_alig) with (sz_box_log + (max_alig - sz_box_log))%nat at 1 by lia. *)
(*       rewrite Nat2Z.inj_add. *)
(*       rewrite Zpower_exp; lia. *)
(*     } *)
(*     rewrite H. *)
(*     rewrite <- Zdiv_Zdiv; auto. *)


(*     Lemma bla : *)
(*       forall x a b, *)
(*         two_power_nat a * ((x-1)/two_power_nat a + 1) <= *)
(*         two_power_nat a * two_power_nat b * ((x-1)/two_power_nat a / two_power_nat b + 1). *)
(*     Proof. *)
(*       intros; generalize (Z_div_mod_eq (x - 1) _ (two_power_nat_pos a)). *)
(*       intros EQ. *)
(*       set (P := (x-1)/two_power_nat a).  *)
(*       rewrite <- Z.mul_assoc. *)
(*       apply Zmult_le_compat_l. 2: generalize (two_power_nat_pos a); lia. *)
(*       rewrite Z.mul_add_distr_l. *)
(*       generalize (Z_div_mod_eq P _ (two_power_nat_pos b)). intros. *)
(*       replace (two_power_nat b * (P/ two_power_nat b)) with *)
(*       (P - P mod two_power_nat b) by lia. clear H. *)
(*       cut (1 <= two_power_nat b - P mod two_power_nat b). lia. *)
(*       generalize (Z_mod_lt P _ (two_power_nat_pos b)). lia. *)
(*     Qed. *)

(*     apply bla. *)
(*     apply two_power_nat_pos. *)
(*     apply two_power_nat_pos. *)
(*   Qed. *)

(* Open Scope nat_scope. *)
  
(*   Lemma AddBlock : *)
(*     forall *)
(*       (L : AMem) *)
(*       (M : ACmem) *)
(*       (LM MM : nat) *)
(*       (LMax  : LM = amem_free_addr L) *)
(*       (MMax  : MM = cmem_free_addr M) *)
(*       (MEM   : is_memory M) *)
(*       (MATCH : spec_of_acmem M = L) *)
(*     , *)
(*     exists (MA : ACmem), *)
(*       is_memory MA /\ *)
(*       has_more_box MA M  ((diff LM (next_box MM)) / sz_box) /\ *)
(*       cmem_free_addr MA <= (max LM (next_box MM)). *)
(*   Proof. *)
(*     intros until 0. *)
(*     remember (length M) as nb eqn:EQ. *)
(*     revert LM MM L M EQ. *)
(*     induction nb using Wf_nat.lt_wf_ind. *)
(*     rename H into IHn. *)
(*     intros. *)
(*     destruct (diff_spec LM (next_box MM)) as [[D1 D2] | [D1 D2]]; *)
(*       rewrite D2; clear D2. *)
(*     - *)
(*       (**  *)
(*         L  : [-------------][-----] *)
(*         M  : [----------][---](...) *)
(*        *) *)
(*       assert (GE : LM >= MM). *)
(*       { generalize (next_box_le MM) ; lia. *)
(*       } *)
(*       rewrite div_next_box;auto. *)
(*       rewrite Max.max_l by lia. *)
(*       eapply free_block_end ; eauto. *)
(*       subst.  *)
(*       eapply addr_align_le. apply sz_box_small. *)
(*       apply addr_aligned_amem_free_addr. *)
(*     - *)
(*       (**  *)
(*         L  : [-------------] *)
(*         M  : [------------------]     *)
(*        *) *)
(*       destruct nb. *)
(*       +  *)
(*       intros. *)
(*       destruct M ; simpl in EQ ; try congruence. *)
(*       simpl in *. subst. *)
(*       simpl. exists nil. *)
(*       split ; auto. *)
(*       rewrite next_box_0. *)
(*       rewrite diff_0_0_div. *)
(*       split ; auto. constructor. *)
(*       +  *)
(*       remember (amem_free_addr (removelast L)) as LM' eqn:EQLM. *)
(*       remember (cmem_free_addr (removelast M)) as MM' eqn:EQMM. *)
(*       destruct (case_last M) as [MCASE | MCASE]; *)
(*         destruct (case_last L) as [LCASE | LCASE]. *)
(*       * subst. simpl in *. lia. *)
(*       * subst.  simpl in *. lia. *)
(*       * subst. *)
(*         destruct MCASE as [E [L' MCASE]]. *)
(*         subst. *)
(*         apply (f_equal (@length _)) in LCASE. *)
(*         rewrite spec_of_acmem_length in LCASE. *)
(*         rewrite app_length in LCASE. *)
(*         simpl in LCASE ; lia. *)
(*       * destruct MCASE as [B [M' MCASE]]. *)
(*         destruct LCASE as [AB [L' LCASE]]. *)
(*         rewrite LCASE in *. rewrite MCASE in *. *)
(*         apply spec_of_acmem_last in MATCH. *)
(*         rewrite removelast_app in EQMM by congruence. *)
(*         simpl in EQMM. rewrite app_nil_r in EQMM. *)
(*         rewrite removelast_app in EQLM by congruence. *)
(*         simpl in EQLM. rewrite app_nil_r in EQLM. *)
(*         rewrite amem_free_addr_app in LMax. *)
(*         simpl in LMax. *)
(*         ring_simplify in LMax. *)
(*         rewrite cmem_free_addr_app_right in MMax *)
(*           by (try congruence; destruct MEM ; auto). *)
(*         simpl in MMax. *)
(*         assert (SIZE : size AB = ac_size B). *)
(*         { *)
(*           destruct MATCH. *)
(*           destruct B ; destruct AB ; compute in H0 ; simpl ; congruence. *)
(*         } *)
(*         assert (GT : size AB > 0) by (eapply size_ablock_pos ; eauto; tauto). *)
(*         assert (SIZEMM' : MM' + ac_size B <= ac_addr B + ac_size B). *)
(*         { *)
(*           rewrite EQMM. *)
(*           apply cmem_free_addr_app_left. *)
(*           destruct MEM ; auto. *)
(*         } *)
(*         assert (HIND : *)
(*                   exists MA : ACmem, *)
(*                     is_memory MA /\ *)
(*                     has_more_box MA M' (diff LM' (next_box MM') / sz_box) /\ *)
(*                     cmem_free_addr MA <= max LM' (next_box MM')). *)
(*         { *)
(*           eapply IHn; eauto. *)
(*           - rewrite app_length in EQ. *)
(*             simpl in EQ. lia. *)
(*           -  *)
(*             apply is_memory_app_l in MEM ; auto. *)
(*           - tauto. *)
(*         } *)
(*         destruct HIND as [MA [HMEM [HMORE HFREE]]]. *)
(*         destruct (diff_spec LM' (next_box MM')) as [[D1' D2'] | [D1' D2']]. *)
(*         { *)
(*           (**  *)
(*            L  : [-------------][----](....) *)
(*            M  : [----------]   (..)[----] *)
(*            *) *)
(*           rewrite Max.max_r  by lia.           *)
(*           rewrite Max.max_l in HFREE by lia. *)
(*           exists (M' ++ (holes ((next_box MM - LM) / sz_box) (amem_free_addr L'))++[B]). *)
(*           assert (is_memory *)
(*                     (M' ++ holes ((next_box MM - LM) / sz_box) (amem_free_addr L') ++ [B])). *)
(*           { *)
(*           apply is_memory_mk_app; auto. *)
(*           apply is_memory_app_l in MEM. *)
(*           congruence. *)
(*           apply is_memory_mk_app; auto. *)
(*           apply is_memory_holes. *)
(*           eapply addr_align_le. apply sz_box_small. *)
(*           apply addr_aligned_amem_free_addr. *)
(*           apply is_memory_app_r in MEM. *)
(*           auto. *)
(*           left. *)
(*           simpl. *)
(*           case_eq ((next_box MM - LM) / sz_box). *)
(*           - simpl. lia. *)
(*           - intros. *)
(*             rewrite cmem_free_addr_holes;[| | lia]. *)
(*             assert (AA : addr_aligned (ac_addr B) *)
(*                                       (align_of_size (ac_size B))). *)
(*             { *)
(*               apply ac_addr_align. *)
(*               apply is_memory_app_r in MEM. *)
(*               destruct MEM. simpl in blocks_aligned0. *)
(*               apply blocks_aligned0 ; auto. *)
(*             } *)
(*             apply is_memory_app_r in MEM. *)
(*             clear EQ MATCH MCASE LCASE HMORE HFREE D2'. *)
(*             generalize (size_box (size AB)). *)
(*             rewrite <- EQLM in *. *)
(*             rewrite SIZE in *. *)
(*             intro. *)
(*             rewrite <- H. *)
(*             assert ( (next_box MM - LM) / sz_box * sz_box = next_box MM - LM). *)
(*             { *)
(*               apply next_box_exact; auto. *)
(*               subst. *)
(*               apply next_box_aligned. *)
(*               subst. *)
(*               eapply addr_align_le. apply sz_box_small. *)
(*               apply aligned_add_boxes_max. *)
(*               apply addr_aligned_amem_free_addr. *)
(*             } *)
(*             rewrite H1. *)
(*             destruct (@ac_size_case_mem B) as [ACSIZE | ACSIZE]; auto. *)
(*             + (* This is a small block *) *)
(*               rewrite MMax in *. destruct ACSIZE as [ACSIZE EX]. *)
(*               rewrite nbox_add_small in *; auto. *)
(*               rewrite LMax. *)
(*               rewrite nbox_small in H0; try lia. *)
(*               rewrite nbigbox_small' ; try lia. *)
(*               rewrite nbigbox_small' in LMax ; try lia. *)
(*               generalize (@div_eq (ac_addr B) sz_box sz_box_not_zero). *)
(*               intros [A C]. *)
(*               generalize (sz_box_sz_max_box); *)
(*               lia.  *)
(*             +  (* This is a big block *) *)
(*               destruct ACSIZE as [ACSIZE  [K HK]]. *)
(*               rewrite MMax in *. *)
(*               rewrite HK in *. *)
(*               unfold next_box in *. *)
(*               rewrite nbox_add in * ; auto. *)
(*               rewrite LMax. *)
(*               cut (nbox (ac_size B) * sz_box <= nbigbox (ac_size B) * sz_max_box). *)
(*               lia. *)
(*               apply finer_cut_smaller. *)
(*             + eapply addr_align_le. apply sz_box_small. *)
(*               apply addr_aligned_amem_free_addr. *)
(*           - left. *)
(*             case_eq ((next_box MM - LM) / sz_box). *)
(*             + simpl. *)
(*               intros. *)
(*               lia. *)
(*             + simpl. *)
(*               intros. *)
(*               generalize (next_box_le MM').  *)
(*               lia. *)
(*           } *)
(*           split; auto ; split. *)
(*           - change ((next_box MM - LM) / sz_box) with *)
(*             (0 + ((next_box MM - LM) / sz_box)) at 2. *)
(*             apply has_more_box_app. *)
(*             apply has_more_box_same. *)
(*             change [B] with ([]++[B]) at 2. *)
(*             replace  ((next_box MM - LM) / sz_box) with *)
(*             (((next_box MM - LM) / sz_box) + 0) at 2 by lia. *)
(*             apply has_more_box_app. *)
(*             apply has_more_box_holes. *)
(*             eapply addr_align_le. apply sz_box_small. *)
(*             apply addr_aligned_amem_free_addr. *)
(*             apply has_more_box_same. *)
(*           - *)
(*             rewrite MMax at 2. *)
(*             rewrite cmem_free_addr_app_right. *)
(*             rewrite cmem_free_addr_app_right. *)
(*             simpl. apply next_box_le. *)
(*             simpl ; congruence. *)
(*             apply is_memory_app_r in H. *)
(*             destruct H ; auto. *)
(*             intro. *)
(*             destruct (((next_box MM - LM) / sz_box)) ; simpl in H ; congruence. *)
(*         } *)
(*         { *)
(*           (* *)
(*            L : [-----------][--------](...) *)
(*            M : [--------------](..)[--------] *)
(*            *) *)
(*           rewrite Max.max_r  by lia.           *)
(*           rewrite Max.max_r in HFREE by lia. *)
(*           rewrite D2' in HMORE. *)
(*           assert (STREN : cmem_free_addr MA <= MM'). *)
(*           { *)
(*             rewrite EQMM. *)
(*             eapply has_more_box_cmem_free_addr; eauto. *)
(*             apply is_memory_app_l in MEM ; auto. *)
(*             congruence. *)
(*           } *)
(*           (* Let use the induction hypothesis. *) *)
(*             set (MH  :=  ((ac_addr B - next_box MM') / sz_box)). *)
(*             set (RES := ((MA++ holes MH (next_box MM'))++ [B] )). *)
(*             assert (MEMHOLES: is_memory RES). *)
(*             { unfold RES. *)
(*               mem_app. *)
(*               apply is_memory_mk_app; auto. *)
(*               apply is_memory_holes. *)
(*               apply next_box_aligned. *)
(*               case_eq MH. *)
(*               - right ; simpl ; auto. *)
(*               - left. simpl. lia. *)
(*               - subst M. apply is_memory_app_r in MEM ; auto. *)
(*               - left. simpl. *)
(*                 case_eq MH. *)
(*                 + rewrite holes_0. *)
(*                   rewrite app_nil_r. *)
(*                   lia. *)
(*                 + intros. *)
(*                   rewrite cmem_free_addr_app_right. *)
(*                   rewrite cmem_free_addr_holes ; try lia. *)
(*                   unfold MH in H. *)
(*                   rewrite <- H. *)
(*                   generalize (@div_eq (ac_addr B -  next_box MM') sz_box sz_box_not_zero). *)
(*                     nia. *)
(*                   apply next_box_aligned. *)
(*                   intro. apply (f_equal (@length _)) in H0. *)
(*                   rewrite length_holes in H0. simpl in H0 ; congruence. *)
(*             } *)
(*             assert (MORE: has_more_box RES (M'++[B]) ((((next_box MM' - LM')) / sz_box) + MH)). *)
(*             { *)
(*               unfold RES. *)
(*               replace (((next_box MM' - LM') / sz_box + MH)) *)
(*               with  ((((next_box MM' - LM') / sz_box + MH)) + 0) by lia. *)
(*               rewrite <- (app_nil_r M'). *)
(*               apply has_more_box_app. *)
(*               apply has_more_box_app. *)
(*               congruence. *)
(*               apply has_more_box_holes ; auto. *)
(*               auto with cp. *)
(*               apply has_more_box_same. *)
(*             } *)
(*             apply has_more_box_le with (N' := ((next_box MM - LM) / sz_box)) in MORE. *)
(*             destruct MORE as [RES' [SUB]]. *)
(*             exists RES'. *)
(*             split;[|split]; auto. *)
(*             eapply is_memory_sublist ; eauto. *)
(*             apply sublist_cmem_free_addr in H. *)
(*             unfold RES in *. *)
(*             rewrite cmem_free_addr_app_right in H by congruence. *)
(*             simpl in H. *)
(*             generalize (next_box_le MM). lia. *)
(*             destruct MEMHOLES ; auto. *)
(*             apply is_memory_sublist in H ; auto. destruct H ; auto. *)
(*             congruence. *)
(*             auto. *)
(*             { (* The interesting stuff *) *)
(*               unfold MH. *)
(*               rewrite SIZE in *. *)
(*               subst M. *)
(*               apply is_memory_app_r in MEM. *)
(*               assert (A :  addr_aligned (ac_addr B) (align_of_size (ac_size B))). *)
(*               { *)
(*                 destruct MEM. *)
(*                 assert (is_aligned B). apply blocks_aligned0. *)
(*                 simpl ; tauto. *)
(*                 destruct H ; auto. *)
(*               } *)
(*               assert (ALM' : addr_aligned LM' max_alig). *)
(*               { *)
(*                 rewrite EQLM. *)
(*                 apply addr_aligned_amem_free_addr. *)
(*               } *)
(*               remember ((next_box MM - LM) / sz_box) as KS eqn:EQKS. *)
(*               remember ((next_box MM' - LM') / sz_box + *)
(*                         (ac_addr B - next_box MM') / sz_box) as KB eqn:EQKB. *)
(*               assert (KS * sz_box <= KB * sz_box). *)
(*               { *)
(*                 destruct (ac_size_case_mem MEM) as [SMALL | BIG]. *)
(*                 - (* SMALL BLOCK *) *)
(*                   destruct SMALL as [SMALL1 [KK SMALL2]]. *)
(*                   assert (ac_addr B < next_box MM' \/ ac_addr B >= next_box MM') by lia. *)
(*                   destruct H. *)
(*                   + (* below MM' *) *)
(*                     assert (next_box MM = next_box MM'). *)
(*                     { *)
(*                       rewrite MMax. *)
(*                       assert (LE : MM' <= ac_addr B) by lia. *)
(*                       apply next_box_mono in LE. *)
(*                       apply in_box with (s:= ac_size B) in H. *)
(*                       apply next_box_mono in H. *)
(*                       rewrite next_box_idem in H. *)
(*                       assert (ac_addr B <= ac_addr B + ac_size B) by lia. *)
(*                       apply next_box_mono in H0.  *)
(*                       lia. *)
(*                       auto with cp. *)
(*                       lia. *)
(*                       rewrite aligned_of_size_small in A ; auto. *)
(*                     } *)
(*                     rewrite H0 in *. *)
(*                     rewrite <- EQLM in LMax. *)
(*                     rewrite nbigbox_small' in LMax; auto. *)
(*                     subst LM. *)
(*                     replace (ac_addr B - next_box MM') with 0 in EQKB by lia. *)
(*                     rewrite div_undef in EQKB. *)
(*                     subst KS KB. *)
(*                     rewrite next_box_exact; auto with cp. *)
(*                     replace ((next_box MM' - LM') / sz_box + 0) with *)
(*                     ((next_box MM' - LM') / sz_box) by lia. *)
(*                     rewrite next_box_exact; auto with cp. *)
(*                     lia. *)
(*                     eapply addr_align_le. apply sz_box_small. auto. *)
(*                     eapply addr_align_le. apply sz_box_small.  *)
(*                     red; rewrite aligned_add_boxes_max; auto. *)
(*                   + (* There is some slack *) *)
(*                     subst KS. *)
(*                     rewrite next_box_exact; auto with cp. *)
(*                     subst KB. *)
(*                     rewrite mult_plus_distr_r. *)
(*                     rewrite next_box_exact; auto with cp. *)
(*                     rewrite <- EQLM in LMax. *)
(*                     subst LM. *)
(*                     assert (NBnbox : (nbox (ac_size B) = 1)). *)
(*                     { rewrite nbox_small ; auto. } *)
(*                     assert (NBignbox : (nbigbox (ac_size B) = 1)). *)
(*                     { rewrite nbigbox_small' ; auto. } *)
(*                     assert (NSMALL : next_box MM = ac_addr B / sz_box*sz_box + sz_box). *)
(*                     { rewrite MMax. *)
(*                       rewrite nbox_add_small ; auto. *)
(*                     } *)
(*                     rewrite NBignbox in *. *)
(*                     rewrite NSMALL in *. *)
(*                     rewrite nbox_minus; auto. *)
(*                     generalize sz_box_sz_max_box. *)
(*                     lia. *)
(*                     apply next_box_aligned. *)
(*                     eapply addr_align_le. apply sz_box_small. auto. *)
(*                     rewrite LMax. *)
(*                     eapply addr_align_le. apply sz_box_small.  *)
(*                     apply aligned_add_boxes_max. *)
(*                     apply addr_aligned_amem_free_addr. *)
(*               -  (* BIG BLOCK *) *)
(*                 destruct BIG as [BIG [KK ADDR]]. *)
(*                 subst KS KB. *)
(*                 assert (AL : addr_aligned (ac_addr B) sz_box_log). *)
(*                 { *)
(*                   unfold addr_aligned. *)
(*                   rewrite ADDR. *)
(*                   unfold sz_box. *)
(*                   rewrite Nat.mod_mul; auto. *)
(*                   apply sz_box_not_zero. *)
(*                 } *)
(*                 assert (NBLE : next_box MM' <= ac_addr B). *)
(*                 { *)
(*                   rewrite <- next_box_is_aligned; auto. *)
(*                   apply next_box_mono ; lia. *)
(*                 } *)
(*                 rewrite MMax. *)
(*                 rewrite LMax. *)
(*                 rewrite ADDR in *. *)
(*                 unfold next_box at 1. *)
(*                 rewrite nbox_add; auto. *)
(*                 repeat   rewrite mult_plus_distr_r. *)
(*                 rewrite next_box_exact; auto with cp. *)
(*                 rewrite next_box_exact; auto with cp. *)
(*                 rewrite next_box_exact; auto with cp. *)
(*                 cut (nbox (ac_size B) * sz_box <= nbigbox (ac_size B) * sz_max_box). *)
(*                 lia. *)
(*                 apply finer_cut_smaller. *)
(*                 eapply addr_align_le. apply sz_box_small. auto. *)
(*                 apply aligned_add_boxes. *)
(*                 red. rewrite Nat.mod_mul. auto. *)
(*                 generalize (two_power sz_box_log); lia. *)
(*                 eapply addr_align_le. apply sz_box_small. *)
(*                 apply aligned_add_boxes_max. *)
(*                 apply addr_aligned_amem_free_addr. *)
(*               } *)
(*               apply Nat.div_le_mono with (c:= sz_box) in H ; auto. *)
(*               rewrite Nat.div_mul in H. *)
(*               rewrite Nat.div_mul in H. auto. *)
(*               apply sz_box_not_zero. *)
(*               apply sz_box_not_zero. *)
(*               apply sz_box_not_zero. *)
(*               } *)
(*         } *)
(*   Qed. *)

      
    
    

(* End S.     *)
      
  