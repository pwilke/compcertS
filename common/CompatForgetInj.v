(* Require Import Coqlib. *)
(* Require Import Memory. *)
(* Require Import Compat. *)
(* Require Import Align. *)
(* Require Import Values. *)
(* Require Import Integers. *)
(* Require Import ZArith. *)
(* Require Import Tactics. *)

(* Open Scope Z_scope. *)

(* Definition inj_injective (f: meminj) := *)
(*   forall b1 b2 (diff: b1 <> b2), f b1 = None \/ f b1 <> f b2. *)

(* Definition forget_bound (f:meminj) m1 : Prop := *)
(*   forall b, f b = None -> Mem.size_block m1 b <= 8. *)

(* Section Sorted. *)
(*   Require Import List. *)
(*   Variable  A : Type. *)
(*   Variable le : A -> A -> bool. *)

(*   Fixpoint insert (e :A) (l : list A) : list A := *)
(*     match l with *)
(*       | nil => e ::l *)
(*       | e' ::l => if le e e' then e :: e' :: l *)
(*                  else  e' :: (insert e l) *)
(*     end. *)

(*   Lemma In_insert : *)
(*     forall l e a, *)
(*       In e (insert a l) <-> *)
(*       (e = a \/ In e l). *)
(*   Proof. *)
(*     induction l ; simpl ; intros. *)
(*     intuition. *)
(*     destr. *)
(*     red; split; intros; destr. *)
(*     des H. *)
(*     rewrite IHl in i. des i. *)
(*     des H.  *)
(*     right. rewrite IHl. auto. *)
(*     des o. *)
(*     right. rewrite IHl. auto.  *)
(*   Qed. *)


(*   Fixpoint sort (l : list A) := *)
(*     match l with *)
(*       | nil => nil *)
(*       | e :: l => insert e (sort l) *)
(*     end. *)

(*   Lemma In_sort : *)
(*     forall l e, *)
(*       In e l <-> In e (sort l). *)
(*   Proof. *)
(*     induction l ; simpl. *)
(*     - tauto. *)
(*     - *)
(*       intros. *)
(*       rewrite IHl. *)
(*       rewrite In_insert. *)
(*       intuition. *)
(*   Qed. *)


(*   Inductive Sorted: list A -> Prop := *)
(*   | Sorted_nil: *)
(*       Sorted nil *)
(*   | Sorted_cons: forall hd tl, *)
(*       (forall x, In x tl -> le hd x = true) -> *)
(*       Sorted tl -> *)
(*       Sorted (hd :: tl). *)

(*   Hypothesis le_trans: forall a b c, le a b = true -> le b c = true -> le a c = true. *)
(*   Hypothesis le_false: forall a b, le a b = false -> le b a = true. *)
  
(*   Lemma insert_sorted: *)
(*     forall l (s: Sorted l) a, *)
(*       Sorted (insert a l). *)
(*   Proof. *)
(*     induction 1; simpl; intros. *)
(*     - constructor. easy. constructor. *)
(*     - destr. *)
(*       + constructor; auto. *)
(*         * simpl; intros. des H0. apply H in i. *)
(*           eapply le_trans; eauto. *)
(*         * constructor; auto. *)
(*       + constructor; auto. *)
(*         simpl; intros. *)
(*         rewrite In_insert in H0. *)
(*         des H0. apply le_false; auto. *)
(*         apply H; auto. *)
(*   Qed. *)

(*   Lemma sort_sorted: *)
(*     forall l, Sorted (sort l). *)
(*   Proof. *)
(*     induction l; simpl; intros. *)
(*     - constructor. *)
(*     - apply insert_sorted; auto. *)
(*   Qed. *)

(*   Lemma insert_split: *)
(*     forall a l, *)
(*     exists l1 l2, insert a l = l1 ++ a::l2 /\ l = l1 ++ l2. *)
(*   Proof. *)
(*     induction l; simpl; intros. *)
(*     - exists nil, nil. split; reflexivity. *)
(*     - destruct IHl as [l1 [l2 [B C]]]. *)
(*       destr. *)
(*       exists nil, (a0::l); split; reflexivity. *)
(*       rewrite B. *)
(*       exists (a0::l1), l2; split. reflexivity. rewrite C; reflexivity. *)
(*   Qed. *)
  
(*   Require Import Permutation. *)
  
(*   Lemma sort_permut: *)
(*     forall l, Permutation l (sort l). *)
(*   Proof. *)
(*     induction l; simpl; intros. *)
(*     auto. *)
(*     destruct (insert_split a (sort l)) as [l1 [l2 [B C]]]. *)
(*     rewrite B. *)
(*     rewrite <- Permutation_middle. *)
(*     constructor. rewrite <- C. auto. *)
(*   Qed. *)

(*   Lemma filter_if: *)
(*     forall A (f: A -> bool) (a:bool) b c, *)
(*       filter f (if a then b else c) = if a then filter f b else filter f c. *)
(*   Proof. *)
(*     intros; destr. *)
(*   Qed. *)

(*   Lemma insert_le: *)
(*     forall l a0 a,  *)
(*       le a0 a = true ->  *)
(*       (forall x : A, In x l -> le a x = true) -> *)
(*       insert a0 l = a0::l. *)
(*   Proof. *)
(*     induction l; simpl; intros; auto. *)
(*     destr. *)
(*     erewrite le_trans in Heqb. congruence. *)
(*     eauto. apply H0. auto. *)
(*   Qed. *)
  
(*   Lemma filter_insert: *)
(*     forall f l a, Sorted l -> filter f (insert a l) = *)
(*              (if f a then insert a (filter f l) else filter f l). *)
(*   Proof. *)
(*     induction l; simpl; intros; auto. *)
(*     rewrite filter_if. *)
(*     simpl. rewrite IHl by (inv H; auto). *)
(*     repeat destr. *)
(*     inv H. *)
(*     erewrite insert_le. auto. eauto. *)
(*     intros. apply  H2. *)
(*     rewrite filter_In in H. destr. *)
(*   Qed. *)
  
(*   Lemma filter_sort: *)
(*     forall f l, *)
(*       filter f (sort l) = sort (filter f l). *)
(*   Proof. *)
(*     induction l; simpl; intros. *)
(*     - auto. *)
(*     - transitivity (if f a then sort (a::filter f l) else sort (filter f l)); [|now destr]. *)
(*       simpl. *)
(*       rewrite <- IHl. *)
(*       intros; apply filter_insert. *)
(*       apply sort_sorted. *)
(*   Qed. *)
  
(* End Sorted. *)


(* (* *)

(* Definition le_acblock (a b : ACblock) : bool := *)
(*   NPeano.leb (ac_addr a) (ac_addr b). *)

(* Definition sort_cmem := sort _ le_acblock. *)
(* Require Import PP.PpsimplZ. *)
(* Require Import Psatz. *)
(* Lemma scmem_trans : forall a b c, le_acblock a b = true -> le_acblock b c = true -> le_acblock a c = true. *)
(* Proof. *)
(*   - unfold le_acblock. intros. ppsimpl.  lia. *)
(* Qed. *)
(* Lemma scmem_antisym : forall a b, le_acblock a b = false -> le_acblock b a = true. *)
(* Proof. *)
(*   unfold le_acblock. intros. ppsimpl. lia. *)
(* Qed. *)

(* Lemma scmem_sorted : forall l, Sorted _ le_acblock (sort_cmem l). *)
(* Proof. *)
(*   apply sort_sorted. *)
(*   apply scmem_trans. *)
(*   apply scmem_antisym. *)
(* Qed. *)

(* Lemma scmem_permut : forall l, Permutation l (sort_cmem l). *)
(* Proof. *)
(*   apply sort_permut. *)
(* Qed. *)

(* Lemma scmem_filter : forall l f, filter f (sort_cmem l) = sort_cmem (filter f l). *)
(* Proof. *)
(*   intros. *)
(*   apply filter_sort. *)
(*   apply scmem_trans. *)
(*   apply scmem_antisym. *)
(* Qed. *)

(* Lemma alloc_blocks_aligned: *)
(*   forall z bl al *)
(*     (lnr: list_norepet (map fst bl)) *)
(*     (AB: Alloc.alloc_blocks MA z bl = Some al) *)
(*     (LE: z <= Int.max_unsigned) *)
(*     b, *)
(*     (two_power_nat MA | Int.unsigned (al b)). *)
(* Proof. *)
(*   intros. *)
(*   unfold Alloc.alloc_blocks, Alloc.alloc_mem_aux in AB. *)
(*   revert AB; repeat destr. intro AB; inv AB. *)
(*   revert Heqp. *)
(*   destruct (in_dec peq b (map fst bl)). *)
(*   intro A. *)
(*   generalize (Alloc.compat_alloc_aligned_al *)
(*                 _ (two_power_nat_pos MA) _ _ _ _ _ _ i A). *)
(*   rewrite Int.unsigned_repr. auto. *)
(*   rewrite in_map_iff in i. destruct i as [[bb zz] [EQ i]]. subst; simpl in *.  *)
(*   generalize (fun ge => Alloc.compat_alloc_range_al' *)
(*                        _ (two_power_nat_pos MA) _ lnr _ _ _ _ ge A _ _ i). *)
(*   generalize (two_power_nat_pos MA). *)
(*   lia. *)
(*   intro A. eapply Alloc.alloc_mem_al_pos in A. rewrite A. *)
(*   apply Zdivide_0. auto. *)
(* Qed. *)
    
(* Lemma nin_list_ints: *)
(*   forall n m (ME: (m > n)%nat), *)
(*     ~ *)
(*       In (Pos.of_nat m) *)
(*       (map (fun x : nat => Pos.of_nat x) (Alloc.list_ints n)). *)
(* Proof. *)
(*   Local Opaque Pos.of_nat. *)
(*   induction n; simpl; intros; eauto. *)
(*   trim (IHn m). lia. *)
(*   intro IN. destruct IN as [IN|IN]; eauto. *)
(*   apply Nat2Pos.inj in IN. lia. auto. lia. *)
(* Qed. *)

  
(* Lemma lnr_mbl: *)
(*   forall m, *)
(*     list_norepet (map fst (Mem.mk_block_list m)). *)
(* Proof. *)
(*   unfold Mem.mk_block_list. *)
(*   intros. *)
(*   generalize (pred (Pos.to_nat (Mem.nextblock m))). *)
(*   Local Opaque Pos.of_nat. *)
(*   induction n; simpl; intros; eauto. *)
(*   constructor. *)
(*   constructor; auto. *)
(*   rewrite map_map. simpl. *)
(*   apply nin_list_ints. lia. *)
(* Qed. *)

(* Lemma sorted_ca_filter: *)
(*   forall P l *)
(*     (S: sorted_ca l), *)
(*     sorted_ca (filter P l). *)
(* Proof. *)
(*   intros. *)
(*   eapply sublist_sorted. eauto. *)
(*   apply S. *)
(*   clear. *)
(*   induction l. constructor. *)
(*   simpl; destr. constructor; auto. *)
(*   constructor. auto. *)
(*   Grab Existential Variables. *)
(*   exact O. *)
(* Qed. *)

(* Lemma sorted_noov_sorted_ca: *)
(*   forall l *)
(*     (S: Sorted _ le_acblock l) *)
(*     (NOOV: forall a b (i1: In a l) (i2: In b l) *)
(*              (diff: ac_addr a <> ac_addr b), *)
(*         (ac_addr a + ac_size a <= ac_addr b \/ *)
(*          ac_addr b + ac_size b <= ac_addr a)%nat) *)
(*     (NZ: list_norepet (map ac_addr l)), *)
(*   sorted_ca l. *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   - constructor. *)
(*   - inv S. constructor. *)
(*     trim IHS. *)
(*     { intros. apply NOOV; auto. } *)
(*     trim IHS. *)
(*     { inv NZ; auto. } *)
(*     constructor. auto. *)
(*     specialize (NOOV hd hd0 (or_introl eq_refl) (or_intror (or_introl eq_refl))). *)
(*     inv NZ. simpl in H4. *)
(*     trim NOOV; auto.  *)
(*     destruct NOOV; auto. *)
(*     specialize (H _ (or_introl eq_refl)). *)
(*     unfold le_acblock in H. clear - H4 H H2. *)
(*     apply NPeano.leb_le in H. lia. *)
(* Qed. *)

(* Lemma ama_range: *)
(*   forall m z z0 *)
(*     (AMA: Alloc.alloc_mem_aux MA (Mem.mk_block_list m) =  *)
(*           (z, z0)) (ge: 0 <= z), *)
(*   forall b, 0 <= z0 b <= z. *)
(* Proof. *)
(*   intros. *)
(*   destruct (in_dec peq b (map fst (Mem.mk_block_list m))). *)
(*   rewrite in_map_iff in i. destruct i as [[bb zz] [EQ i]]. subst; simpl in *.  *)
(*   trim (fun lnr ge => Alloc.compat_alloc_range_al' *)
(*                      _ (two_power_nat_pos MA) _ lnr _ _ _ _ ge AMA _ _ i). *)
(*   apply lnr_mbl. *)
(*   generalize (two_power_nat_pos MA). *)
(*   lia. *)
(*   unfold Alloc.alloc_mem_aux in AMA. *)
(*   eapply Alloc.alloc_mem_al_pos in AMA. rewrite AMA.  lia. auto.  *)
(* Qed. *)

(* Lemma szmem_mu: *)
(*   Mem.__szmem <= Int.max_unsigned. *)
(* Proof. *)
(*   generalize Mem.size31_inf. unfold Mem.__szmem. auto. *)
(* Qed. *)

(* Lemma ama_range': *)
(*   forall m z z0 *)
(*     (AMA: Alloc.alloc_mem_aux MA (Mem.mk_block_list m) =  *)
(*           (z, z0)) (ge: 0 <= z) (lt: z < Mem.__szmem), *)
(*   forall b, Int.unsigned (Int.repr (z0 b)) = z0 b. *)
(* Proof. *)
(*   intros. *)
(*   rewrite Int.unsigned_repr. auto. *)
(*   generalize (ama_range _ _ _ AMA ge b). *)
(*   generalize (szmem_mu); lia. *)
(* Qed. *)

(* Lemma in_bl: *)
(*   forall m b1 z1 *)
(*     (i: In (b1, z1) (Mem.mk_block_list m)), *)
(*     (Pos.to_nat b1 <= pred (Pos.to_nat (Mem.nextblock m)))%nat. *)
(* Proof. *)
(*   intro m. *)
(*   unfold Mem.mk_block_list. *)
(*   generalize (pred (Pos.to_nat (Mem.nextblock m))). *)
(*   intros. *)
(*   destruct (le_dec (Pos.to_nat b1) n); auto. *)
(*   apply (in_map fst) in i. *)
(*   contradict i. *)
(*   eapply Alloc.mbla_not_above. simpl. lia. *)
(* Qed. *)

(* Lemma map_filter: *)
(*   forall A B (g: A -> B) f l, *)
(*   filter f (map g l) = map g (filter (fun x => f (g x)) l). *)
(* Proof. *)
(*   induction l; repeat destr. *)
(* Qed. *)

(* Lemma lnr_map_filter: *)
(*   forall A B (f: A -> B) g (l: list A)  *)
(*     (lnr : list_norepet (map f l)), *)
(*     list_norepet (map f (filter g l)). *)
(* Proof. *)
(*   induction l; repeat destr. *)
(*   constructor; auto. *)
(*   inv lnr. *)
(*   intro IN. *)
(*   rewrite in_map_iff in *. *)
(*   dex; destr. *)
(*   rewrite filter_In in IN. *)
(*   apply H1; exists x; split; destr. *)
(*   apply IHl. inv lnr; auto. *)
(*   intro; apply IHl. inv lnr; auto.   *)
(* Qed. *)

(* Lemma lnr_map_map: *)
(*   forall A B C  (f: (A*B) -> C) (l: list (A*B)) *)
(*     (lnr: list_norepet (map fst l)) *)
(*     (inj: forall x y (i1: In x l) (i2: In y l) *)
(*             (diff: fst x <> fst y), f x <> f y), *)
(*     list_norepet (map f l). *)
(* Proof. *)
(*   intros. *)
(*   apply list_map_norepet. *)
(*   eapply Maps.PTree_Properties.list_norepet_map; eauto. *)
(*   intros. *)
(*   apply inj; auto. *)
(*   destruct x as [x1 x2]. destruct y as [y1 y2]. simpl in *. *)
(*   intro; subst. *)
(*   generalize (Alloc.norepet_eq _ lnr _ _ _ H0 H). intro; subst; congruence. *)
(* Qed. *)

(* Lemma insert_nnil: *)
(*   forall A (le: A -> A -> bool) e l, *)
(*     insert _ le e l = nil -> False. *)
(* Proof. *)
(*   induction l. destr. *)
(*   simpl. destr. *)
(* Qed. *)

(* Definition acm_of_mem (m: mem) (al: block -> int) := *)
(*   let bl := Mem.mk_block_list m in *)
(*   let acm := List.map *)
(*                (fun (bsz: block * Z) => *)
(*                   let (b,sz) := bsz in *)
(*                   mk_acmem (Z.to_nat (Int.unsigned (al b))) (Z.to_nat sz)) *)
(*                bl in *)
(*   let acm' := filter (fun b => (NPeano.ltb 0 (ac_size b))) (sort_cmem acm) in *)
(*   acm'. *)

(* Definition acm_of_mem_max (m: mem) := *)
(*   match Mem.alloc_mem m with *)
(*     None => None *)
(*   | Some al => Some (acm_of_mem m al) *)
(*   end. *)



(* Lemma mask_spec: *)
(*   forall m b, *)
(*     (Alloc.alignment_of_size (Mem.size_block m b) <= Mem.mask m b  <= MA)%nat. *)
(* Proof. *)
(*   intros. *)
(*   unfold Mem.size_block, Alloc.get_size, Mem.mask. *)
(*   repeat destr. *)
(*   - exploit Mem.alignment_ok; eauto.  *)
(*     unfold Alloc.get_size. rewrite Heqo.  lia. *)
(*   - exploit Mem.bounds_mask_consistency; eauto. congruence. *)
(*   - exploit Mem.alignment_ok; eauto.  *)
(*     unfold Alloc.get_size. rewrite Heqo.  lia. *)
(*   - unfold Alloc.alignment_of_size. destr; lia. *)
(* Qed. *)

(* Lemma align_of_size_add: *)
(*   forall a b, *)
(*     (a <= b)%nat -> *)
(*     forall s, *)
(*       (align_of_size a s <= align_of_size b s)%nat. *)
(* Proof. *)
(*   unfold align_of_size. *)
(*   intros. *)
(*   destr. *)
(*   rewrite (proj2 (NPeano.ltb_lt _ _)). lia. *)
(*   rewrite NPeano.ltb_lt in Heqb0. *)
(*   eapply lt_le_trans. apply Heqb0. *)
(*   unfold sz_box. *)
(*   apply NPeano.Nat.pow_le_mono_r; lia. *)
(*   apply ltb_false in Heqb0. *)
(*   destr. *)
(*   rewrite NPeano.ltb_lt in Heqb1. *)
(*   assert (sz_box a <= s)%nat. lia. clear Heqb0. *)
(*   unfold sz_box in H0. *)
(*   unfold log2_ceil. *)
(*   apply NPeano.Nat.log2_le_mono in H0. *)
(*   erewrite log2_pow2 in H0; eauto. *)
(*   etransitivity. *)
(*   apply H0. destr; lia. *)
(* Qed. *)

(* Ltac nattac := *)
(*   repeat *)
(*     match goal with *)
(*       H: NPeano.ltb ?a ?b = true |- _ => rewrite NPeano.ltb_lt in H *)
(*     | H : NPeano.ltb ?a ?b = false |- _ => apply ltb_false in H *)
(*     end. *)

(* Lemma log2_ceil_le: *)
(*   forall s, *)
(*     (align_of_size 3 s <= *)
(*     Alloc.alignment_of_size (Z.of_nat s))%nat. *)
(* Proof. *)
(*   intros. *)
(*   unfold align_of_size, Alloc.alignment_of_size. *)
(*   change (sz_box 3) with 8%nat. *)
(*   destr; nattac. *)
(*   assert (Z.of_nat s < 8). lia. *)
(*   intros; destr. *)
(*   assert (Z.of_nat s = 0 \/ Z.of_nat s = 1). *)
(*   lia. *)
(*   unfold log2_ceil. *)
(*   rewrite (proj2 (NPeano.Nat.log2_null _)). 2: lia. *)
(*   rewrite <- beq_nat_refl. rewrite orb_true_r. lia. *)
(*   destr. *)
(*   assert (s = 2%nat) by lia. subst. vm_compute. lia. *)
(*   destr. *)
(*   assert (s = 3%nat \/ s = 4%nat) by lia. destruct H0; subst; vm_compute; lia. *)
(*   assert (s = 5%nat \/ s = 6%nat \/ s = 7%nat) by lia. destruct H0 as [H0|[H0|H0]]; subst; vm_compute; lia. *)
(*   repeat (destr; try lia). *)
(* Qed. *)

(* Lemma log2_mono: *)
(*   forall a b, *)
(*     (0 < a -> a < NPeano.pow 2 b -> *)
(*      NPeano.log2 a < b)%nat. *)
(* Proof. *)
(*   intros. rewrite <- NPeano.Nat.log2_lt_pow2. auto. auto.  *)
(* Qed. *)


(* Lemma alloc_size_mem_al_le: *)
(*   forall al (alpos: al > 0) l z m, *)
(*     0 <= z -> *)
(*     Alloc.size_mem_al al l z = m -> *)
(*     Forall (fun x => snd x <= m) l. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   des a. *)
(*   constructor. *)
(*   simpl. *)
(*   etransitivity. 2: apply Alloc.size_mem_al_pos. *)
(*   etransitivity. 2: apply align_le. *)
(*   rewrite Z.add_comm. *)
(*   etransitivity. 2: apply Alloc.Zle_add. *)
(*   apply Z.le_max_r. etransitivity. 2: apply align_le. auto. *)
(*   apply alpos. *)
(*   apply alpos. *)
(*   apply alpos. *)
(*   etransitivity. 2: apply align_le ; try (apply alpos). *)
(*   generalize (align_le z _ alpos). *)
(*   generalize (Z.le_max_l 0 z0). lia. *)
(*   eapply IHl. 2: eauto. *)
(*   etransitivity. 2: apply align_le ; try (apply alpos). *)
(*   generalize (align_le z _ alpos). *)
(*   generalize (Z.le_max_l 0 z0). lia. *)
(* Qed. *)

(* Lemma in_bound_unsigned: *)
(*   forall o m b, *)
(*     Mem.in_bound_m o m b ->  *)
(*     Int.unsigned (Int.repr o) = o. *)
(* Proof. *)
(*   intros. *)
(*   apply Int.unsigned_repr. *)
(*   repeat red in H. *)
(*   generalize (Mem.bounds_lo_0 m b). *)
(*   des (Mem.bounds_of_block m b). intro; subst. *)
(*   split; auto. lia. *)
(*   cut (z0 <= Int.max_unsigned). lia. *)
(*   generalize (Mem.wfm_alloc_ok m). *)
(*   unfold Alloc.alloc_blocks, Alloc.alloc_mem_aux. *)
(*   destr. destr. intros _. *)
(*   apply Alloc.alloc_size_mem_al in Heqp0. *)
(*   apply alloc_size_mem_al_le in Heqp0. *)
(*   2: apply two_power_nat_pos. *)
(*   2: generalize (two_power_nat_pos MA); lia. *)
(*   rewrite Forall_forall in Heqp0. *)
(*   transitivity Mem.__szmem. 2: apply szmem_mu. *)
(*   specialize (fun pf => Heqp0 _ (Alloc.mbla_below_in' _ _ b pf)). *)
(*   simpl in *. *)
(*   change (Alloc.get_size (Mem.mem_blocksize m) b) with *)
(*   (Mem.size_block m b) in Heqp0. *)
(*   erewrite Mem.bounds_size in Heqp0. 2: eauto. *)
(*   rewrite Z.sub_0_r in Heqp0. *)
(*   etransitivity. apply Heqp0. *)
(*   exploit Mem.bounds_of_block_valid. *)
(*   apply Heqp. lia. unfold Mem.valid_block. *)
(*   rewrite Pos2Nat.inj_lt. lia. lia. *)
(* Qed. *)

(* Lemma compat_no_overlap: *)
(*   forall m cm (COMP: Mem.compat_m m Mem.M32 cm),  *)
(*   forall b1 b2, *)
(*     b1 <> b2 -> *)
(*     (0 < Z.to_nat (Mem.size_block m b1))%nat -> *)
(*     (0 < Z.to_nat (Mem.size_block m b2))%nat -> *)
(*     (~ Z.to_nat (Int.unsigned (cm b1)) <= Z.to_nat (Int.unsigned (cm b2)) < *)
(*      Z.to_nat (Int.unsigned (cm b1)) + Z.to_nat (Mem.size_block m b1))%nat. *)
(* Proof. *)
(*   intros m cm COMP b1 b2 n  LT1 LT2 A. *)
(*   assert (exists o, Z.to_nat (Int.unsigned (cm b1)) + o = Z.to_nat (Int.unsigned (cm b2)))%nat. *)
(*   exists (Z.to_nat (Int.unsigned (cm b2)) - Z.to_nat (Int.unsigned (cm b1)))%nat. lia. *)
(*   dex. rewrite <- H in A. *)

(*   assert (IN2: Mem.in_bound_m 0 m b2). *)
(*   { *)
(*     red; red; intros. *)
(*     generalize (Mem.size_block_pos m b2). intros. *)
(*     generalize (Mem.bounds_lo_0 m b2). intro. *)
(*     des (Mem.bounds_of_block m b2). subst. *)
(*     split. lia. *)
(*     erewrite Mem.bounds_size in * by eauto. des z0; lia. *)
(*   } *)

(*   assert (IN1: Mem.in_bound_m (Z.of_nat o) m b1). *)
(*   { *)
(*     red; red; intros. *)
(*     generalize (Mem.size_block_pos m b1). intros. *)
(*     generalize (Mem.bounds_lo_0 m b1). intro. *)
(*     des (Mem.bounds_of_block m b1). subst. *)
(*     erewrite Mem.bounds_size in * by eauto. *)
(*     split.  lia. *)
(*     assert (o < Z.to_nat (z0-0))%nat by lia. *)
(*     rewrite Z.sub_0_r in H1. *)
(*     apply inj_lt in H1. *)
(*     rewrite Z2Nat.id in H1. auto. lia. *)
(*   } *)
  
(*   generalize IN1 IN2. intros. *)
(*   rewrite <- (in_bound_unsigned _ _ _ IN1) in IN1. *)
(*   rewrite <- (in_bound_unsigned _ _ _ IN2) in IN2.  *)
(*   apply (NormaliseSpec.overlap _ _ _ _ COMP _ _ _ _ n IN1 IN2). *)
(*   rewrite Int.add_zero. *)
(*   apply Z2Nat.inj. apply Int.unsigned_range. apply Int.unsigned_range. *)
(*   rewrite <- H. rewrite <- IntFacts.int_add_rew. *)

(*   rewrite (in_bound_unsigned _ _ _ IN0). *)
(*   rewrite Int.unsigned_repr. *)
(*   rewrite Z2Nat.inj_add. *)
(*   f_equal. apply Nat2Z.id. *)
(*   apply Int.unsigned_range. *)
(*   lia. *)
(*   split. generalize (Int.unsigned_range (cm b1)). lia. *)
(*   apply f_equal with (f:=Z.of_nat) in H. *)
(*   rewrite Nat2Z.inj_add in H. *)
(*   rewrite ! Z2Nat.id in H. rewrite H. *)
(*   apply Int.unsigned_range_2. *)
(*   apply Int.unsigned_range_2. *)
(*   apply Int.unsigned_range_2. *)
(* Qed. *)

(* Lemma mem_is_memory: *)
(*   forall m cm (COMP: Mem.compat_m m Mem.M32 cm), *)
(*     is_memory 3 (acm_of_mem m cm). *)
(* Proof. *)
(*   intros. *)
(*   (* destruct (Mem.alloc_compat m) as [al [EQ COMP]]. *) *)
(*   (* unfold Mem.alloc_mem in EQ. *) *)
(*   set (bl := Mem.mk_block_list m). *)
(*   set (acm := List.map (fun (bsz: block * Z) => *)
(*                           let (b,sz) := bsz in *)
(*                           mk_acmem (Z.to_nat (Int.unsigned (cm b))) (Z.to_nat sz)) bl). *)
(*   set (acm' := filter (fun b => (NPeano.ltb 0 (ac_size b))) (sort_cmem acm)). *)
(*   assert (blocks_aligned: forall b (IN: In b acm'), is_aligned 3%nat b). *)
(*   { *)
(*     intros b IN. *)
(*     unfold acm' in IN. rewrite filter_In in IN. *)
(*     destruct IN as [IN _]. *)
(*     apply (Permutation_in _ (Permutation_sym (scmem_permut _))) in IN. *)
(*     unfold acm in IN. rewrite in_map_iff in IN. *)
(*     dex.  des x. destruct IN as [EQ IN]. subst. *)
(*     assert (Mem.valid_block m b0). exploit in_bl. apply IN. red. rewrite Pos2Nat.inj_lt. lia. *)
(*     generalize (NormaliseSpec.alignment _ _ _ _ COMP b0). *)
(*     constructor. simpl. rename H0 into A.  *)
(*     red. rewrite <- Nat2Z.id. *)
(*     rewrite <- (Nat2Z.id (NPeano.modulo _ _)). *)
(*     f_equal. *)
(*     rewrite mod_Zmod. *)
(*     2: generalize (two_power (align_of_size 3 (Z.to_nat z))); lia. *)
(*     rewrite InstanceZ.npow_inj. *)
(*     rewrite Z2Nat.id. 2: apply Int.unsigned_range. *)
(*     Opaque two_power_nat. simpl. *)
(*     simpl. *)
(*     unfold  Int.and in A. rewrite <- A. *)
(*     rewrite Int.unsigned_repr. *)
(*     - rewrite <- Z.land_ones by lia. *)
(*       unfold Mem.nat_mask. *)
(*       apply Int.equal_same_bits. intros. *)
(*       rewrite ! Z.land_spec. *)
(*       rewrite Byte.Ztestbit_0.  *)
(*       destruct (zlt i  (Z.of_nat (align_of_size 3 (Z.to_nat z)))). *)
(*       rewrite Z.ones_spec_low; auto. *)
(*       {  *)
(*         cut (i < Int.zwordsize). intro. *)
(*         rewrite <- (Int.testbit_repr (Int.unsigned (Int.not _))); auto. *)
(*         rewrite Int.repr_unsigned. *)
(*         rewrite Int.bits_not; auto. *)
(*         rewrite Int.testbit_repr; auto. *)
(*         rewrite two_power_nat_two_p. *)
(*         rewrite Int.Ztestbit_two_p_m1; auto. 2: lia. destr. rewrite andb_false_r. reflexivity. *)
(*         cut (Z.of_nat (Mem.mask m b0) >= Z.of_nat (align_of_size 3 (Z.to_nat z))). lia. *)
(*         apply Zle_ge. *)
(*         apply inj_le.  *)
(*         generalize (mask_spec m b0). *)
        
(*         cut ((align_of_size 3 (Z.to_nat z) <= Alloc.alignment_of_size (Mem.size_block m b0))%nat). lia. *)
(*         unfold bl, Mem.mk_block_list in IN. *)
(*         eapply Alloc.mbla_in in IN. subst. *)
(*         clear. *)
(*         etransitivity. *)
(*         apply log2_ceil_le. *)
(*         rewrite Z2Nat.id. lia. *)
(*         apply Mem.size_block_pos. *)

(*         eapply Z.lt_le_trans. apply l. *)
(*         etransitivity. *)
(*         apply Nat2Z.inj_le. *)
(*         eapply align_of_size_bound. apply MA_bound. *)
(*         vm_compute. destr. *)
(*       } *)
(*       rewrite Z.ones_spec_high. 2: lia. apply andb_false_r. *)

(*     - *)
(*       split. *)
(*       rewrite Z.land_nonneg. *)
(*       left. apply Int.unsigned_range. *)
(*       apply Int.Ztestbit_le. *)
(*       vm_compute; destr. *)
(*       intros. *)
(*       rewrite Z.land_spec in H1. *)
(*       unfold Int.max_unsigned, Int.modulus. *)
(*       rewrite two_power_nat_two_p. *)
(*       rewrite Int.Ztestbit_two_p_m1; try lia. *)
(*       destr. *)
(*       erewrite Int.Ztestbit_above in H1. *)
(*       simpl in H1. destr. *)
(*       apply Int.unsigned_range. simpl. auto. *)
(*   } *)
(*   assert (size_gt: forall b (IN: In b acm'), (ac_size b > 0)%nat). *)
(*   { *)
(*     unfold acm'. *)
(*     intro b; rewrite filter_In. *)
(*     intros [IN LTB]. *)
(*     ppsimpl; lia. *)
(*   } *)
(*   assert (sca: *)
(*             Sorted ACblock le_acblock *)
(*                    (filter *)
(*                       (fun b : ACblock => NPeano.ltb 0 (ac_size b)) *)
(*                       (sort_cmem acm))). *)
(*   { *)
(*     rewrite scmem_filter. apply scmem_sorted. *)
(*   } *)
(*   assert (noov: *)
(*             forall a b : ACblock, *)
(*             forall *)
(*               (i1: In a *)
(*                       (filter (fun b0 : ACblock => NPeano.ltb 0 (ac_size b0)) (sort_cmem acm))) *)
(*               (i2: In b *)
(*                       (filter (fun b0 : ACblock => NPeano.ltb 0 (ac_size b0)) (sort_cmem acm))) *)
(*               (diff: ac_addr a <> ac_addr b), *)
(*               (ac_addr a + ac_size a <= ac_addr b)%nat \/ *)
(*               (ac_addr b + ac_size b <= ac_addr a)%nat). *)
(*   { *)
(*     intros. *)
(*     rewrite filter_In in i1, i2. *)
(*     destruct i1 as [i1 LT1]; destruct i2 as [i2 LT2]. *)
(*     rewrite NPeano.ltb_lt in LT1, LT2. *)
(*     apply (Permutation_in _ (Permutation_sym (scmem_permut _))) in i1. *)
(*     apply (Permutation_in _ (Permutation_sym (scmem_permut _))) in i2. *)
(*     unfold acm in i1, i2. rewrite in_map_iff in i2, i1. *)
(*     destruct i1 as [[b1 z1] [eq1 i1]]. *)
(*     destruct i2 as [[b2 z2] [eq2 i2]]. subst. *)
(*     simpl in *. *)

(*     exploit Alloc.mbla_in. apply i1. *)
(*     exploit Alloc.mbla_in. apply i2. *)
(*     intros; subst. *)

(*     des (peq b1 b2). *)

(*     generalize (compat_no_overlap _ _ COMP _ _ n LT1 LT2). *)
(*     generalize (compat_no_overlap _ _ COMP _ _ (not_eq_sym n) LT2 LT1). *)
(*     intros A B. *)
(*     lia. *)
(*   } *)
(*   assert (lnr: list_norepet (map ac_addr acm')). *)
(*   { *)
(*     apply permutation_norepet *)
(*     with (l:=map ac_addr (filter (fun b => NPeano.ltb 0 (ac_size b)) acm)). *)
(*     apply Permutation_map. *)
(*     apply Mem.permut_filter. apply scmem_permut. *)
(*     unfold acm. *)
(*     apply list_map_norepet. *)
(*     - unfold bl, Mem.mk_block_list. *)
(*       generalize (Alloc.mbla_norepet (Mem.size_block m) *)
(*                                      (pred (Pos.to_nat (Mem.nextblock m)))). *)
(*       rewrite map_filter. *)
(*       rewrite Mem.filter_ext with (p':=fun (x:block*Z) => Z.ltb 0 (snd x)). *)
(*       2: intros [b z]; simpl; ppsimpl; lia. *)
(*       intro lnr; apply lnr_map_map. *)
(*       apply lnr_map_filter. auto. *)
(*       intros x y i1 i2 diff. *)
(*       rewrite filter_In in i1, i2. *)
(*       destruct i1 as [i1 LT1]; destruct i2 as [i2 LT2]. *)
(*       rewrite Z.ltb_lt in LT1, LT2. *)
(*       destruct x as [b1 z1]. *)
(*       destruct y as [b2 z2].  *)
(*       simpl in *. *)
(*       clear sca. clear noov. clear size_gt blocks_aligned acm'. *)
(*       clear - i1 i2 LT1 LT2 diff COMP. *)
(*       intro EQ. inv EQ. *)
(*       eapply Alloc.mbla_in in i2. *)
(*       eapply Alloc.mbla_in in i1. subst. *)
(*       assert (NV :=compat_no_overlap _ _ COMP _ _ diff). *)
(*       trim NV. apply Z2Nat.inj_lt in LT1; lia. *)
(*       trim NV. apply Z2Nat.inj_lt in LT2; lia. *)
(*       apply NV. clear NV. *)
(*       rewrite H0. *)
(*       split. lia.  *)
(*       apply Z2Nat.inj_lt in LT1; lia. *)
(*     - intros x y i1 i2 diff. *)
(*       rewrite filter_In in i1, i2. *)
(*       destruct i1 as [i1 LT1]; destruct i2 as [i2 LT2]. *)
(*       rewrite NPeano.ltb_lt in LT1, LT2. *)
(*       rewrite in_map_iff in i2, i1. *)
(*       destruct i1 as [[b1 z1] [eq1 i1]]. *)
(*       destruct i2 as [[b2 z2] [eq2 i2]]. subst. *)
(*       simpl in *. *)
(*       destruct (peq b1 b2). *)
(*       + subst. *)
(*         replace z1 with z2 in *. congruence. *)
(*         eapply Alloc.norepet_eq. apply (lnr_mbl m). *)
(*         unfold bl in *; eauto. *)
(*         unfold bl in *; eauto. *)
(*       + clear sca. clear noov. clear size_gt blocks_aligned acm'.  *)
(*         clear - i1 i2 LT1 LT2 n COMP. *)
(*         unfold bl, Mem.mk_block_list in *. *)
(*         eapply Alloc.mbla_in in i2. *)
(*         eapply Alloc.mbla_in in i1. subst. *)
(*         assert (NV :=compat_no_overlap _ _ COMP _ _ n). *)
(*         trim NV. auto. trim NV. auto. *)
(*         intro. *)
(*         apply NV. clear NV. *)
(*         rewrite H. lia. *)
(*   } *)
(*   assert (is_sorted: sorted_ca acm') by (apply sorted_noov_sorted_ca; auto). *)
(*   constructor; auto. *)
(* Qed. *)

(* Lemma max_al_mem_is_memory: *)
(*   forall m, *)
(*   exists cm, *)
(*     is_memory 3 (acm_of_mem m cm). *)
(* Proof. *)
(*   intros. *)
(*   destruct (Mem.concrete_mem m). *)
(*   exists x. *)
(*   apply mem_is_memory. auto. *)
(* Qed. *)

(* Definition list_blocks m : list block:= *)
(*   filter_map  (fun n => let b := Pos.of_nat n in *)
(*                     if zlt 0 (Mem.size_block m b) *)
(*                     then Some b else None) *)
(*              (Alloc.list_ints (pred (Pos.to_nat (Mem.nextblock m)))). *)

(* Fixpoint reduce {A: Type} (f: A -> A -> A) (default: A) (l: list A) : A := *)
(*   match l with *)
(*     nil => default *)
(*   | a::r => reduce f (f a default) r *)
(*   end. *)

(* Definition next_addr m cm := *)
(*   reduce (Zmax) 0 *)
(*          (List.map *)
(*             (fun b => Int.unsigned (cm b) + Mem.size_block m b) *)
(*             (list_blocks m)). *)


(* Definition simpl_inj := block -> option block. *)

(* Definition g_inj (g: simpl_inj) := *)
(*   forall b1 b2 b1' b2' *)
(*     (diff: b1 <> b2) *)
(*     (g1: g b1 = Some b1') *)
(*     (g2: g b2 = Some b2'), *)
(*     b1' <> b2'. *)

(* Definition eq_align x y := *)
(*   forall al, (al >= 3)%nat -> *)
(*         align x (two_power_nat al) = *)
(*         align y (two_power_nat al). *)

(* Definition eq_mask x y := max 3 x = max 3 y. *)
(* (* l1 is the list of blocks present in m1 but not injected into m2 *) *)
(* (* l2 is the list of blocks present in m2 but not injected from m1 *) *)
(* Record sinj (g: simpl_inj) (m1 m2: mem) (l1 l2: list block) := *)
(*   { *)
(*     sinj_inj: g_inj g; *)
(*     sinj_bounds: forall b b', g b = Some b' -> *)
(*                          eq_align (Mem.size_block m1 b) (Mem.size_block m2 b'); *)
(*     sinj_bounds': forall b b', g b = Some b' -> *)
(*                           Mem.size_block m1 b <= Mem.size_block m2 b'; *)
(*     sinj_mask: forall b b', g b = Some b' -> eq_mask (Mem.mask m1 b) (Mem.mask m2 b'); *)
(*     sinj_mask': forall b b', g b = Some b' -> (Mem.mask m1 b <= Mem.mask m2 b')%nat; *)
(*     sinj_fb: forall b, g b = None -> 0 <= Mem.size_block m1 b <= 8 /\ (Mem.mask m1 b <= 3)%nat; *)
(*     sinj_in: forall b, In b l1 -> g b = None /\ Mem.valid_block m1 b /\ 0 < Mem.size_block m1 b <= 8; *)
(*     sinj_in': forall b', In b' l2 -> Mem.valid_block m2 b' /\ Mem.size_block m2 b' = 8 *)
(*                                /\ Mem.mask m2 b' = 3%nat /\ ~ exists b, g b = Some b'; *)
(*     sinj_valid: forall b b', g b = Some b' -> Mem.valid_block m1 b /\ Mem.valid_block m2 b' /\ ~ In b' l2; *)
(*     sinj_injection: forall b', Mem.valid_block m2 b' -> (exists b, g b = Some b') \/ In b' l2; *)
(*     sinj_inject: forall b, Mem.valid_block m1 b -> (exists b', g b = Some b') \/ In b l1 \/ Mem.size_block m1 b = 0; *)
(*     sinj_lnr1: list_norepet l1; *)
(*     sinj_lnr2: list_norepet l2 *)
(*   }. *)




(* Ltac rewbnd := *)
(*   try rewrite <- ! Mem.size_block_snd; *)
(*   repeat *)
(*     match goal with *)
(*       H: Mem.storebytes ?m ?b ?o ?l = Some ?m' |- *)
(*       context [Mem.bounds_of_block ?m' ?b']  => *)
(*       rewrite <- (Mem.bounds_of_block_storebytes _ _ _ _ _ H b') *)
(*     | H: Mem.drop_perm ?m ?b ?lo ?hi ?p = Some ?m' |- *)
(*       context [Mem.bounds_of_block ?m' ?b']  => *)
(*       rewrite <- (Mem.drop_perm_bounds _ _ _ _ _ _ H b') *)
(*     | H: Mem.alloc ?m ?lo ?hi ?bt = Some (?m',?b) |- *)
(*       context [Mem.bounds_of_block ?m' ?b]  => *)
(*       rewrite (Mem.bounds_of_block_alloc _ _ _ _ _ _ H) *)
(*     | H: Mem.alloc ?m ?lo ?hi ?bt = Some (?m',?b), *)
(*          H1: ?b <> ?b' |- *)
(*       context [Mem.bounds_of_block ?m' ?b']  => *)
(*       rewrite <- (Mem.bounds_of_block_alloc_other _ _ _ _ _ _ H _ H1) *)
(*     | H: Mem.alloc ?m ?lo ?hi ?bt = Some (?m',?b), *)
(*          H1: ?b' <> ?b |- *)
(*       context [Mem.bounds_of_block ?m' ?b']  => *)
(*       rewrite <- (Mem.bounds_of_block_alloc_other _ _ _ _ _ _ H _ (not_eq_sym H1)) *)
(*     end; *)
(*   try rewrite ! Mem.size_block_snd. *)

(* Ltac rewmsk := *)
(*   repeat *)
(*     match goal with *)
(*       H: Mem.storebytes ?m ?b ?o ?l = Some ?m' |- *)
(*       context [Mem.mask ?m' ?b']  => *)
(*       rewrite <- (Mem.mask_storebytes _ _ _ _ _ H b') *)
(*     | H: Mem.drop_perm ?m ?b ?lo ?hi ?p = Some ?m' |- *)
(*       context [Mem.mask ?m' ?b']  => *)
(*       rewrite <- (Mem.mask_drop_perm _ _ _ _ _ _ H b') *)
(*     | H: Mem.alloc ?m ?lo ?hi ?bt = Some (?m',?b) |- *)
(*       context [Mem.mask ?m' ?b]  => *)
(*       rewrite (Mem.alloc_mask _ _ _ _ _ _ H) *)
(*     | H: Mem.alloc ?m ?lo ?hi ?bt = Some (?m',?b), *)
(*          H1: ?b <> ?b' |- *)
(*       context [Mem.mask ?m' ?b']  => *)
(*       rewrite <- (Mem.mask_alloc_other _ _ _ _ _ _ H _ H1) *)
(*     | H: Mem.alloc ?m ?lo ?hi ?bt = Some (?m',?b), *)
(*          H1: ?b' <> ?b |- *)
(*       context [Mem.mask ?m' ?b']  => *)
(*       rewrite <- (Mem.mask_alloc_other _ _ _ _ _ _ H _ (not_eq_sym H1)) *)
(*     end. *)

(* Ltac rewvb := *)
(*   repeat *)
(*     match goal with *)
(*       H: Mem.storebytes ?m ?b ?o ?l = Some ?m' |- *)
(*       Mem.valid_block ?m' ?b' => *)
(*       apply (Mem.storebytes_valid_block_1 _ _ _ _ _ H b') *)
(*     | H: Mem.drop_perm ?m ?b ?lo ?hi ?p = Some ?m' |- *)
(*       Mem.valid_block ?m' ?b' => *)
(*       apply (Mem.drop_perm_valid_block_1 _ _ _ _ _ _ H) *)
(*     | H: Mem.alloc ?m ?lo ?hi _ = Some (?m',?b) |- *)
(*       Mem.valid_block ?m' ?b => *)
(*       apply (Mem.valid_new_block _ _ _ _ _ _ H) *)
(*     | H: Mem.alloc ?m ?lo ?hi _ = Some (?m',?b), *)
(*          H1: ?b <> ?b' |- *)
(*       Mem.valid_block ?m' ?b' => *)
(*       apply (Mem.valid_block_alloc _ _ _ _ _ _ H) *)
(*     | H: Mem.alloc ?m ?lo ?hi _ = Some (?m',?b), *)
(*          H1: ?b' <> ?b |- *)
(*       Mem.valid_block ?m' ?b' => *)
(*       apply (Mem.valid_block_alloc _ _ _ _ _ _ H) *)
(*     | H: Mem.alloc ?m ?lo ?hi _ = Some (?m',?b) *)
(*       |- *)
(*       Mem.valid_block ?m' ?b' => *)
(*       let i := fresh in *)
(*       set (i := b' <> b); exfalso *)
(*     end. *)


(* Definition is_injected (g: simpl_inj) (b: block * Z) := *)
(*   match g (fst b) with *)
(*     Some b2  => true *)
(*   | None => false *)
(*   end. *)
  
(* Definition part_inj l (g:simpl_inj) := *)
(*   partition (is_injected g) l. *)

(* Lemma partition_app_perm: *)
(*   forall {A: Type} f (l: list A) a b, *)
(*     partition f l = (a,b) -> *)
(*     Permutation l (a ++ b). *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - inv H. simpl; constructor. *)
(*   - repeat destr_in H. *)
(*     + inv H. specialize (IHl _ _ eq_refl). *)
(*       simpl. constructor. auto. *)
(*     + inv H. specialize (IHl _ _ eq_refl). *)
(*       eapply perm_trans. apply perm_skip. eauto. *)
(*       apply Permutation_middle. *)
(* Qed. *)

(* Lemma reduce_max: *)
(*   forall a  *)
(*     l dfl  *)
(*     (lt: a <= dfl), *)
(*     a <= reduce Z.max dfl l. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   apply IHl. rewrite Z.max_le_iff. auto. *)
(* Qed. *)

(* Lemma next_addr_spec: *)
(*   forall cm2 m2 b, *)
(*     In b (list_blocks m2) -> *)
(*     Int.unsigned (cm2 b) + Mem.size_block m2 b <= *)
(*     next_addr m2 cm2. *)
(* Proof. *)
(*   unfold next_addr. *)
(*   intros cm2 m2. *)
(*   generalize 0. *)
(*   generalize (list_blocks m2). *)
(*   induction l; simpl; intros; eauto. easy. *)
(*   destruct (peq a b). *)
(*   - subst. apply reduce_max. *)
(*     rewrite Z.max_le_iff. *)
(*     left. lia.  *)
(*   - des H. eapply IHl; eauto. *)
(* Qed. *)


(* Lemma in_map_filter: *)
(*   forall {A B} b0 (f: A -> option B) l, *)
(*     In b0 (filter_map f l) <-> *)
(*     (exists a0, In a0 l /\ f a0 = Some b0). *)
(* Proof. *)
(*   induction l; simpl; intros. split; intros; dex; easy. *)
(*   des (f a); eauto. *)
(*   - split; intros. *)
(*     + destruct H; subst; eauto. *)
(*       rewrite IHl in H. dex. *)
(*       exists a0; destr. *)
(*     + dex. destruct H as [[C|C] D]. *)
(*       subst; auto. left; congruence. right; rewrite IHl. *)
(*       exists a0; destr. *)
(*   - rewrite IHl. *)
(*     split; intros [a0 [C D]]; exists a0; destr. *)
(* Qed. *)

(* Lemma below_in_list_ints: *)
(*   forall m b0, *)
(*     (0 < b0 <= m)%nat -> *)
(*     In b0 (Alloc.list_ints m). *)
(* Proof. *)
(*   induction m; simpl; intros; eauto. lia. *)
(*   destruct (eq_nat_dec (S m) b0); auto. *)
(*   right. apply IHm. lia. *)
(* Qed. *)

(* Lemma valid_in_list_ints: *)
(*   forall m2 b0, *)
(*     Mem.valid_block m2 b0 -> *)
(*     In (Pos.to_nat b0) (Alloc.list_ints (pred (Pos.to_nat (Mem.nextblock m2)))). *)
(* Proof. *)
(*   intros. *)
(*   apply below_in_list_ints. split. lia. *)
(*   red in H. *)
(*   apply Pos2Nat.inj_lt in H. lia. *)
(* Qed. *)

(* Lemma in_bound_in_list: *)
(*   forall o m2 b0 *)
(*     (IB : NormaliseSpec.in_bound (Int.unsigned o) (Mem.bounds_of_block m2 b0)), *)
(*     In b0 (list_blocks m2). *)
(* Proof. *)
(*   unfold list_blocks. *)
(*   intros. rewrite in_map_filter. *)
(*   exists (Pos.to_nat b0). split. *)
(*   2: rewrite Pos2Nat.id. *)
(*   2: destruct (Mem.bounds_of_block m2 b0) eqn:?. *)
(*   2: erewrite Mem.bounds_size; eauto. 2: destr; red in IB; simpl in IB; try lia. *)
(*   eapply valid_in_list_ints; eauto. *)
(*   eapply Mem.in_bound_valid; eauto. *)
(* Qed. *)

(* Lemma part_inj_cm_below: *)
(*   forall m2 cm2 *)
(*     (COMP: Mem.compat_m m2 Mem.M32 cm2) *)
(*     (NextLe: next_addr m2 cm2 <= Mem.size_mem m2) *)
(*     b0 o *)
(*     (IB : NormaliseSpec.in_bound (Int.unsigned o) (Mem.bounds_of_block m2 b0)), *)
(*     Int.unsigned (cm2 b0) + Int.unsigned o < Mem.size_mem m2. *)
(* Proof. *)
(*   intros. *)
(*   eapply Z.lt_le_trans. *)
(*   apply Zplus_lt_compat_l. apply IB. *)
(*   etransitivity. 2: apply NextLe. *)
(*   rewrite Mem.size_block_snd. apply next_addr_spec. eapply in_bound_in_list; eauto. *)
(* Qed. *)

(* Lemma fst_ama: *)
(*   forall tpma l z cm, *)
(*     fst (Alloc.alloc_mem_al tpma l (z,cm)) = *)
(*     Alloc.size_mem_al tpma l z. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   des a. apply IHl. *)
(* Qed. *)


(* Lemma lnr_nin: *)
(*   forall {A: Type} (f: A -> bool) l a b, *)
(*     partition f l = (a, b) -> *)
(*     forall x, ~ In x l -> *)
(*          ~ In       x a /\ ~ In x b. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - inv H; destr. *)
(*   - repeat destr_in H; inv H; specialize (IHl _ _ eq_refl); destr. *)
(*     trim (IHl x). destr. split; destr. *)
(*     trim (IHl x). destr. split; destr. *)
(* Qed. *)

(* Lemma lnr_partition: *)
(*   forall {A: Type} (f: A -> bool) l a b, *)
(*     partition f l = (a, b) -> *)
(*     list_norepet l -> *)
(*     list_norepet a /\ list_norepet b. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - inv H. split; constructor. *)
(*   - repeat destr_in H; inv H; specialize (IHl _ _ eq_refl); inv H0; split; trim IHl; auto. *)
(*     constructor; auto. *)
(*     eapply lnr_nin in H2; eauto. destr. *)
(*     destr. destr. destr. *)
(*     constructor; auto. *)
(*     eapply lnr_nin in H2; eauto. destr. destr. *)
(* Qed. *)

(* Lemma in_partition_l: *)
(*   forall {A: Type} (f: A -> bool) l a b, *)
(*     partition f l = (a, b) -> *)
(*     forall x, *)
(*       In x a <-> *)
(*       In x l /\ f x = true. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - inv H. simpl; tauto.  *)
(*   - repeat destr_in H; inv H; specialize (IHl _ _ eq_refl). *)
(*     simpl. *)
(*     + split; intros. *)
(*       destruct H; auto. destr. apply IHl in H. destr. *)
(*       destruct H. destruct H; auto. right; rewrite IHl. destr. *)
(*     + split; intros. *)
(*       apply IHl in H. destr. *)
(*       destruct H. rewrite IHl.  destruct H; auto. congruence.    *)
(* Qed. *)

(* Lemma sma_eq_snd: *)
(*   forall al l l' z, *)
(*     map snd l = map snd l' -> *)
(*     Alloc.size_mem_al al l z = *)
(*     Alloc.size_mem_al al l' z. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - des l'. *)
(*   - des l'. inv H. des a; des p. *)
(*     apply IHl; auto. *)
(* Qed. *)

(* Lemma perm_map_snd: *)
(*   forall (l': list Z), *)
(*   exists (x: list (block*Z)), l' = map snd x. *)
(* Proof. *)
(*   intros. *)
(*   exists (map (fun x => (xH,x)) l'). *)
(*   rewrite map_map. simpl. *)
(*   induction l'; destr. *)
(* Qed. *)

(* Lemma size_mem_al_permut: *)
(*   forall (al : Z) (lb lb' : list (Z)), *)
(*   al > 0 -> *)
(*   Permutation lb lb' -> *)
(*   forall (l l': list (block*Z)), map snd l = lb -> map snd l' = lb' -> *)
(*   forall b : Z, Alloc.size_mem_al al l b = Alloc.size_mem_al al l' b. *)
(* Proof. *)
(*   induction 2; simpl; intros. *)
(*   - des l; des l'. *)
(*   - des l0; des l'0. des p; des p0. *)
(*     inv H1; inv H2. *)
(*     apply IHPermutation; auto. *)
(*   - des l0; des l'. des l1; des l0. inv H0; inv H1. *)
(*     des p1; des p; des p2; des p0. *)
(*     erewrite (sma_eq_snd _ _ _ _ H4). *)
(*     f_equal. *)
(*     generalize (align_divides b al H). *)
(*     generalize (align b al). *)
(*     intros. *)
(*     rewrite ! align_align; auto.  *)
(*     destruct (align_divides (z1 + Z.max 0 z0) al H). *)
(*     destruct (align_divides (z1 + Z.max 0 z) al H). *)
(*     rewrite H1; rewrite H2. *)
(*     destruct H0 as [x1 H0]. subst. *)
(*     assert (forall x z a (apos: a > 0), *)
(*               align (x*a+z) a = x*a + align z a). *)
(*     { *)
(*       clear; intros. *)
(*       unfold align. *)
(*       rewrite <- Z.add_opp_r. *)
(*       rewrite <- ! Z.add_assoc. *)
(*       rewrite Z_div_plus_full_l; try omega. *)
(*       rewrite Z.add_assoc. *)
(*       rewrite Z.add_opp_r. *)
(*       rewrite Z.mul_add_distr_r.  *)
(*       auto. *)
(*     } *)
(*     rewrite H0 in H1; auto. *)
(*     rewrite H0 in H2; auto. *)
(*     rewrite ! H0; auto. *)
(*     rewrite <- H1; auto. rewrite <- H2; auto. omega. *)
(*   - subst. *)
(*     destruct (perm_map_snd l'). subst. *)
(*     erewrite IHPermutation1. apply IHPermutation2; eauto. auto. auto.     *)
(* Qed. *)

(* Lemma inj_injective_impl: *)
(*   forall f, *)
(*     (* Mem.inject ei f m1 m2 -> *) *)
(*     Mem.one2oneinject f -> *)
(*     inj_injective f -> *)
(*     forall x x' b z z', *)
(*       f x = Some (b,z) -> *)
(*       f x' = Some (b,z') -> *)
(*       x = x'. *)
(* Proof. *)
(*   intros. *)
(*   exploit H. eexact H1. *)
(*   exploit H. eexact H2. *)
(*   intros; subst. *)
(*   des (peq x x'). *)
(*   generalize (H0 x x' n). rewrite H1; destr. *)
(* Qed. *)

(* Lemma lnr_nin': *)
(*   forall {A B: Type} (f: A * B -> bool) (l: list (A*B)) a b, *)
(*     partition f l = (a, b) -> *)
(*     forall x, ~ In x (map fst l) -> *)
(*          ~ In       x (map fst a) /\ ~ In x (map fst b). *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - inv H; destr. *)
(*   - repeat destr_in H; inv H; specialize (IHl _ _ eq_refl); destr. *)
(*     trim (IHl x). destr. split; destr. *)
(*     trim (IHl x). destr. split; destr. *)
(* Qed. *)


(* Lemma lnr_partition': *)
(*   forall {A B: Type} (f: A * B -> bool) (l: list (A * B)) a b, *)
(*     partition f l = (a, b) -> *)
(*     list_norepet (map fst l) -> *)
(*     list_norepet (map fst a) /\ list_norepet (map fst b). *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - inv H. split; constructor. *)
(*   - repeat destr_in H; inv H; specialize (IHl _ _ eq_refl); inv H0; split; trim IHl; auto; simpl. *)
(*     constructor; auto. *)
(*     eapply lnr_nin' in H2; eauto. destr. *)
(*     destr. destr. destr. *)
(*     constructor; auto. *)
(*     eapply lnr_nin' in H2; eauto. destr. destr. *)
(* Qed. *)


(* Lemma permut_filter_map: *)
(*   forall {A B} (f: A -> option B) (l l': list A), *)
(*     Permutation l l' -> *)
(*     Permutation (filter_map f l) (filter_map f l'). *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   - destr; auto. *)
(*   - repeat destr; auto. apply perm_swap. *)
(*   - rewrite IHPermutation1; auto. *)
(* Qed. *)
         
(* Lemma in_partition_r: *)
(*   forall {A: Type} (f: A -> bool) l a b, *)
(*     partition f l = (a, b) -> *)
(*     forall x, *)
(*       In x b <-> *)
(*       In x l /\ f x = false. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - inv H. simpl; tauto.  *)
(*   - repeat destr_in H; inv H; specialize (IHl _ _ eq_refl). *)
(*     simpl. *)
(*     + split; intros. *)
(*       apply IHl in H. destr. *)
(*       destruct H. rewrite IHl.  destr.  *)
(*     + split; intros. *)
(*       destruct H; auto. destr. apply IHl in H. destr. *)
(*       destruct H. destr. destruct H; auto. right; rewrite IHl. destr. *)
(* Qed. *)

(* Lemma not_inj_filter_map: *)
(*   forall l0 m1 f *)
(*     (SpecL0 : forall x : block * Z, *)
(*         In x l0 -> *)
(*         In x (Mem.mk_block_list m1) /\ is_injected f x = false), *)
(*     (filter_map *)
(*         (fun x : block * Z => *)
(*          match f (fst x) with *)
(*          | Some b' => Some (b', align (snd x) (two_power_nat 3)) *)
(*          | None => None *)
(*          end) l0) = nil. *)
(* Proof. *)
(*   induction l0; simpl; intros; eauto. *)
(*   repeat destr. *)
(*   specialize (SpecL0 _ (or_introl eq_refl)). unfold is_injected in SpecL0. *)
(*   destr_in Heqo. *)
(*   generalize (SpecL0 _ (or_introl eq_refl)). unfold is_injected. *)
(*   destr_in Heqo. *)
(*   intro; eapply IHl0; eauto. *)
(* Qed. *)
            

(* Lemma sinj_injective: *)
(*   forall g m1 m2 l tl, *)
(*     sinj g m1 m2 l tl -> *)
(*     forall b1 b2 b', *)
(*       g b1 = Some b' -> *)
(*       g b2 = Some b' -> *)
(*       b1 = b2. *)
(* Proof. *)
(*   intros. *)
(*   des (peq b1 b2). *)
(*   exploit sinj_inj; eauto. easy. *)
(* Qed. *)

(* Ltac use_inj := *)
(*   match goal with *)
(*     SI: sinj ?g _ _ _ _, *)
(*         H: ?g ?b = Some ?b', *)
(*            H': ?g ?b2 = Some ?b' |- _ => *)
(*     generalize (sinj_injective _ _ _ _ _ SI _ _ _ H H') *)
(*   end. *)

(* Definition align_list_blocks (l: list (block * Z)) := *)
(*   map (fun bz => (fst bz, align (snd bz) (two_power_nat 3))) l. *)

(* Lemma align_plus: *)
(*   forall al al' (ORD: (0 < al <= al')%nat) z, *)
(*     align (align z (two_power_nat al)) (two_power_nat al') = *)
(*     align z (two_power_nat al'). *)
(* Proof. *)
(*   intros. *)
(*   destruct ORD as (ORD1 & ORD2). *)
  
(*   unfold align. *)
(*   assert (two_power_nat al' = two_power_nat al * two_power_nat (al' - al)). *)
(*   { *)
(*     rewrite ! two_power_nat_equiv. *)
(*     rewrite <- Zpower_exp. f_equal. *)
(*     rewrite <- Nat2Z.inj_add. f_equal; lia. lia. lia. *)
(*   } *)
(*   rewrite H. *)
(*   generalize (al' - al)%nat as b. clear. *)

(*   intro.  *)

(*   replace ((z + two_power_nat al - 1) / two_power_nat al) with *)
(*   ((z-1)/two_power_nat al + 1). *)
(*   Focus 2.  IntFacts.elim_div. ppsimpl. generalize (two_power_nat_pos al). *)
(*   intros; assert (two_power_nat al <> 0) by lia. intuition subst; nia. *)

(*   replace ((z + two_power_nat al * two_power_nat b - 1) / (two_power_nat al * two_power_nat b)) with *)
(*   ((z-1)/(two_power_nat al * two_power_nat b) + 1). *)
(*   Focus 2.  IntFacts.elim_div. ppsimpl.  *)
(*   intros; assert (two_power_nat al * two_power_nat b <> 0). *)
(*   generalize (two_power_nat_pos al) (two_power_nat_pos b); *)
(*   nia. intuition subst; nia. *)

(*   f_equal. *)

(*   rewrite <- ! Zdiv_Zdiv by auto. *)

(*   set (X := (z-1)/two_power_nat al). *)
(*   transitivity ( (two_power_nat al * (X + 1 + two_power_nat b) - 1) *)
(*                    / *)
(*                    two_power_nat al / two_power_nat b). *)
(*   f_equal. f_equal. *)
(*   f_equal.   lia. *)
(*   symmetry. *)
(*   transitivity ((X + two_power_nat b)/ two_power_nat b). *)
(*   IntFacts.elim_div. *)
(*   assert (two_power_nat b <> 0). *)
(*   generalize (two_power_nat_pos b); lia. *)
(*   ppsimpl; intuition subst; nia. *)
(*   IntFacts.elim_div. *)
(*   assert (two_power_nat b <> 0). *)
(*   generalize (two_power_nat_pos b); lia. *)
(*   des (Z.div_eucl (z - 1) (two_power_nat al)). *)
(*   unfold X. *)
(*   generalize (two_power_nat_pos al). intro; *)
(*   assert (two_power_nat al <> 0) by lia. *)
(*   ppsimpl. intros. trim H4; auto. trim H5; auto. trim H6; auto. *)
(*   des H4. des H5. des H6. *)
  
(*   assert (two_power_nat b * (z0 - 1) = z6 - z1) by lia.   *)
(*   assert (z5 = two_power_nat al * (z6 + 1 + two_power_nat b - two_power_nat b * z2 - z3) - 1) by lia.  *)
(*   assert (z6 = two_power_nat b * (z2 - 1) + z3) by nia. *)
(*   assert (z6 = two_power_nat b * (z0 - 1) + z1) by lia. *)
(*   apply Z.div_unique in  H7; auto. *)
(*   apply Z.div_unique in  H6; auto. *)
(*   lia. *)
(* Qed. *)

(* Lemma part_inj_permut: *)
(*   forall f m1 m2 sil  *)
(*     (SI: sinj f m1 m2 sil nil), *)
(*     let (l1,l2) := partition (is_injected f) (Mem.mk_block_list m1) in *)
(*     Permutation (Mem.mk_block_list m1) (l1 ++ l2) -> *)
(*     Permutation *)
(*       (align_list_blocks (Mem.mk_block_list m2)) *)
(*       (filter_map (fun x => *)
(*                      match f (fst x) with *)
(*                        Some b' => (Some (b',align (snd x) (two_power_nat 3))) *)
(*                      | None => None *)
(*                      end) (Mem.mk_block_list m1)). *)
(* Proof. *)
(*   intros. *)
(*   destr. *)
(*   rename l into l1. *)
(*   rename Heqp into PI. *)
(*   intro P. *)
(*   assert (Forall (fun x => exists b', *)
(*                       f (fst x) = Some b' /\ *)
(*                       eq_align (Mem.size_block m1 (fst x)) (Mem.size_block m2 b') /\ *)
(*                       In (b',align (Mem.size_block m2 b') (two_power_nat 3)) *)
(*                          (align_list_blocks (Mem.mk_block_list m2))) l1). *)
(*   { *)
(*     rewrite Forall_forall. *)
(*     intros x IN. *)
(*     erewrite in_partition_l in IN. 2: eauto. *)
(*     destruct IN as [IN FB]. *)
(*     unfold is_injected in FB. destr_in FB.  *)
(*     exists b. repSplit; auto. *)
(*     eapply sinj_bounds; eauto. *)
(*     des x. *)
(*     exploit in_bl.  apply IN. intro LE. *)
(*     assert (Mem.valid_block m1 b0). red. *)
(*     apply Pos2Nat.inj_lt. lia. *)
(*     unfold Mem.mk_block_list in IN. *)
(*     eapply Alloc.mbla_in in IN. *)
(*     subst. *)
(*     unfold align_list_blocks. rewrite in_map_iff. *)
(*     eexists; split.  *)
(*     2: apply Alloc.mbla_below_in'. simpl; eauto. *)
(*     eapply sinj_valid in Heqo; eauto. destruct Heqo as [_ [Vb _]]. *)
(*     red in Vb. *)
(*     rewrite Pos2Nat.inj_lt in Vb. lia. *)
(*   } *)

(*   assert (Forall *)
(*             (fun x => exists b, f b = Some (fst x) /\ *)
(*                         eq_align (Mem.size_block m1 b) (snd x) /\ *)
(*                         In (b, align (Mem.size_block m1 b) (two_power_nat 3)) *)
(*                            (align_list_blocks l1) *)
(*             ) *)
(*             (Mem.mk_block_list m2)). *)
(*   { *)
(*     rewrite Forall_forall. intros x IN. des x. *)
(*     exploit in_bl.  apply IN. intro LE. *)
(*     assert (Mem.valid_block m2 b). red. *)
(*     apply Pos2Nat.inj_lt. lia. *)
(*     assert (exists b0, f b0 = Some b). *)
(*     destruct (sinj_injection _ _ _ _ _ SI _ H0). auto. destr. *)
(*     dex. *)
(*     exists b0; repSplit; auto. *)
(*     unfold Mem.mk_block_list in IN. *)
(*     eapply Alloc.mbla_in in IN. subst. *)
(*     eapply sinj_bounds; eauto. *)
(*     unfold align_list_blocks; apply in_map_iff. eexists; split. *)
(*     2 : erewrite in_partition_l. 3: eauto. 2: split. *)
(*     2: apply Alloc.mbla_below_in'. simpl; eauto. *)
(*     2: unfold is_injected; simpl; rewrite H1; auto. *)
(*     destruct (Mem.valid_block_dec m1 b0). red in v. rewrite Pos2Nat.inj_lt in v. lia. *)
(*     elim n. *)
(*     eapply sinj_valid in H1; eauto. destr. *)
(*   } *)
  
(*   assert (list_norepet (map fst l1)). *)
(*   { *)
(*     eapply lnr_partition' in PI. destr. *)
(*     apply lnr_mbl. *)
(*   } *)
(*   assert (list_norepet (map fst (Mem.mk_block_list m2))). *)
(*   { *)
(*     apply lnr_mbl. *)
(*   } *)
  
(*   rewrite <- permut_filter_map. *)
(*   2: apply Permutation_sym; apply P. *)

(*   generalize (in_partition_r _ _ _ _ PI). *)
  
(*   revert H H0 H1 H2. *)
(*   generalize (Mem.mk_block_list m2). clear - SI. *)
(*   induction l1; simpl; intros l Fl1 Fl LNR1 LNR2 SpecL0; eauto. *)
(*   - inv Fl1. erewrite not_inj_filter_map. inv Fl. constructor. dex; destr. *)
(*     intro; rewrite SpecL0. eauto. *)
(*   - inv Fl1. inv Fl. *)
(*     destruct H1 as [b' [FB [BND IN]]]. *)
(*     destr. *)
(*     destruct H1 as [b' [FB [BND IN]]]. *)
(*     destruct H as [b [FB' [SZ IN']]]. *)
(*     simpl in *. des x. des a. *)
(*     rewrite FB. *)
(*     des (peq b b1). *)
(*     + rewrite FB in FB'. inv FB'. *)
(*       assert (~ In (b0, align (Mem.size_block m2 b0) (two_power_nat 3)) (align_list_blocks l2)). *)
(*       { *)
(*         unfold align_list_blocks. intro NIN. inv LNR2. apply H3. rewrite in_map_iff. *)
(*         rewrite in_map_iff in NIN. dex. des x. des NIN. inv e. *)
(*         eexists; split; eauto; destr. *)
(*       } *)
(*       assert (~ In (b1, align (Mem.size_block m1 b1) (two_power_nat 3)) (align_list_blocks l1)). *)
(*       { *)
(*         unfold align_list_blocks. *)
(*         intro NIN. inv LNR1. apply H4. rewrite in_map_iff. *)
(*         rewrite in_map_iff in NIN; dex. des x. des NIN. inv e. *)
(*         eexists; split; eauto;destr. *)
(*       } *)
(*       des IN. des IN'. inv e. inv e0. *)
(*       rewrite H4, H5. *)
(*       rewrite (sinj_bounds _ _ _ _ _ SI _ _ FB). constructor. *)
(*       apply IHl1; auto. *)
(*       * rewrite Forall_forall in *. *)
(*         intros x IN. *)
(*         exploit H2. apply IN. *)
(*         intros [b'0 [A [B C]]]. *)
(*         exists b'0; repSplit; auto. des C. inv e. *)
(*         des x. *)
(*         use_inj. intro; subst. *)
(*         inv LNR1. exfalso; apply H8.  rewrite in_map_iff; eexists; split; eauto; destr.  *)
(*       * rewrite Forall_forall in *. *)
(*         intros x IN. *)
(*         exploit H0. apply IN. *)
(*         intros [b'0 [A [B C]]]. *)
(*         exists b'0; repSplit; auto. des C. inv e. *)
(*         des x. *)
(*         assert (b= b0) by congruence. subst. *)
(*         inv LNR2. exfalso; apply H8.  rewrite in_map_iff; eexists; split; eauto; destr.          *)
(*       * inv LNR1; auto. *)
(*       * inv LNR2; auto. *)
(*       * lia. *)
(*     + des IN'. *)
(*       generalize (sinj_inj _ _ _ _ _ SI _ _ _ _ n FB' FB). intro diff. *)
(*       des IN. *)
(*       rewrite Forall_forall in H2. *)
(*       generalize (in_split _ _ i0). intros [l2' [l3 EQ]]. *)
(*       generalize (in_split _ _ i). intros [l4 [l5 EQ']]. *)
(*       subst. simpl in *. *)
(*       rewrite <- SZ. *)
(*       rewrite Forall_forall in H0. *)
(*       unfold align_list_blocks in i0; rewrite in_map_iff in i0. dex. des i0. *)
(*       generalize (H0 _ i1). *)
(*       intros [b2 [Fb2 [EQAL OR]]]. simpl in *. des x. inv e. use_inj. intro; subst. *)
(*       inv LNR1; des OR. Focus 2. exfalso; apply H4; rewrite in_map_iff. *)
(*       unfold align_list_blocks in i0; rewrite in_map_iff in i0. dex; des i0. *)
(*       eexists; split; eauto; destr. inv e. rewrite H1. 2: lia. *)
(*       rewrite EQ. *)
(*       rewrite EQAL, <- H3. *)

(*       Lemma filter_map_app: *)
(*         forall {A B:Type} (f: A -> option B) a b, *)
(*           filter_map f (a ++ b) = filter_map f a ++ filter_map f b. *)
(*       Proof. *)
(*         induction a; simpl; intros; eauto. *)
(*         destr. *)
(*       Qed. *)
(*       rewrite filter_map_app. *)

(*       Lemma filter_map_align_list_blocks: *)
(*         forall (f: block -> option block) a, *)
(*           filter_map (fun x => match f (fst x) with *)
(*                               Some b'0 => Some (b'0, align (snd x) (two_power_nat 3)) *)
(*                             | None => None *)
(*                             end) a = *)
(*           filter_map *)
(*             (fun x => match f (fst x) with *)
(*                      Some b'0 => Some (b'0, align (snd x) (two_power_nat 3)) *)
(*                    | None => None *)
(*                    end) *)
(*             (align_list_blocks a). *)
(*       Proof. *)
(*         induction a; simpl; intros; eauto. *)
(*         des a. des (f b). rewrite Align.align_align; auto. f_equal. eauto.         *)
(*       Qed. *)

(*       rewrite filter_map_align_list_blocks. *)
(*       rewrite EQ', H3. simpl. *)
(*       cut (Permutation (l2' ++ l3) *)
(*                        (filter_map (fun x => match f (fst x) with *)
(*                                             Some b'0 => Some (b'0, align (snd x) (two_power_nat 3)) *)
(*                                           | None => None *)
(*                                           end) (l4 ++ l5 ++ l0))). *)
(*       { *)
(*         clear - FB'. *)
(*         simpl; intros. *)
(*         eapply perm_trans. *)
(*         apply perm_skip. *)
(*         eapply perm_trans. *)
(*         apply Permutation_sym. *)
(*         apply Permutation_middle. apply Permutation_refl. *)
(*         eapply perm_trans. apply perm_swap. *)
(*         apply perm_skip. *)
(*         rewrite <- filter_map_app. *)
(*         erewrite permut_filter_map. *)
(*         Focus 2. *)
(*         apply Permutation_sym. apply Permutation_app. apply Permutation_middle. *)
(*         apply Permutation_refl. simpl. rewrite FB'. *)
(*         rewrite Align.align_align; auto. *)
(*         apply perm_skip. *)
(*         rewrite app_ass. auto. *)
(*       } *)
 
(*       specialize (IHl1 (l2' ++ (b0,align (Mem.size_block m1 b) (two_power_nat 3)) :: l3)). *)
      
(*       trim IHl1. *)
(*       { *)
(*         clear IHl1. *)
(*         rewrite Forall_forall. intros x IN. *)
(*         exploit H2.  apply IN. *)
(*         intros [b'0 [A [B C]]]. *)
(*         exists b'0; repSplit; auto. simpl. rewrite EQ in C. unfold align_list_blocks. *)
(*         rewrite in_map_iff. exists (b'0, align (Mem.size_block m2 b'0) (two_power_nat 3)). *)
(*         simpl. split; auto. f_equal. apply Align.align_align; auto. *)
(*         des x. clear FB. *)
(*         des (peq b0 b'0). use_inj. intro; subst. clear A. *)
(*         rewrite in_app. right; simpl; left. f_equal. *)
(*         rewrite B; auto. *)
(*         des C. *)
(*         rewrite in_app_iff in i0 |- *. des i0. des i2. inv e. use_inj. intro; subst. clear A. *)
(*         elim H4. rewrite in_map_iff. eexists; split; eauto. *)
(*         destr. *)
(*       } *)
(*       trim IHl1. *)
(*       { *)
(*         clear IHl1. *)
(*         rewrite Forall_forall. intros x IN. *)
(*         des x. clear Fb2. *)
(*         assert (In (b1, z2) (l2' ++ l3) \/ (b1,z2) = (b0, align (Mem.size_block m1 b) (two_power_nat 3))). *)
(*         { *)
(*           rewrite in_app in IN |- *; destr. *)
(*         } *)
(*         clear IN. *)
(*         des (peq b1 b0). *)
(*         { *)
(*           des H. *)
(*           inv LNR2. *)
(*           assert (NIN: ~ In b0 (map fst (align_list_blocks l2))). *)
(*           { *)
(*             rewrite in_map_iff. *)
(*             intro NIN; dex. des x. des NIN. *)
(*             unfold align_list_blocks in i2. *)
(*             rewrite in_map_iff in i2. *)
(*             dex. des x. des i2. inv e. *)
(*             elim H7. rewrite in_map_iff. exists (b0,z4); split; destr. *)
(*           } *)
(*           elim NIN. rewrite EQ. rewrite in_map_iff. exists (b0,z2); split; destr. *)
(*           rewrite in_app in i0 |- *; destr. *)
(*           inv e. *)
(*           exists b; repSplit; auto. *)
(*           red; intros; symmetry. apply align_plus; auto. *)
(*         } *)
(*         { *)
(*           des H.  *)
(*           assert (In (b1, z2) (align_list_blocks l2)). *)
(*           rewrite EQ. rewrite in_app in i0 |- *; destr. *)
(*           assert (exists z, In (b1, z) l2 /\ eq_align z z2). *)
(*           { *)
(*             unfold align_list_blocks in H; rewrite in_map_iff in H. *)
(*             dex; des x. des H. inv e. eexists; split; eauto. *)
(*             red; symmetry; intros; apply align_plus. lia. *)
(*           } *)
(*           destruct H6 as [z3 [IN EQAL']]. *)
(*           specialize (H0 _ IN). *)
(*           destruct H0 as [b3 [FB3 [SZ' OR]]]. simpl in *. *)
(*           exists b3; repSplit; auto. *)
(*           red; intros; rewrite SZ', EQAL'; auto. *)
(*           des OR. *)
(*           inv e.  *)
(*           rewrite FB in FB3; inv FB3. *)
(*           repeat match goal with *)
(*                    H: In _ _ |- _ => revert H *)
(*                  | H: ~ In _ _ |- _ => revert H *)
(*                  end; intros. *)
(*           exfalso. inv LNR2. *)
(*           Lemma fst_align: *)
(*             forall l, *)
(*               map fst (align_list_blocks l) = map fst l. *)
(*           Proof. *)
(*             induction l; simpl; intros; eauto. *)
(*             f_equal; eauto. *)
(*           Qed. *)
(*           rewrite <- fst_align in H9. eapply permutation_norepet in H9. *)
(*           revert H9. instantiate (1 := map fst ((b1, align (Mem.size_block m2 b1) (two_power_nat 3))::l2'++l3)). *)
(*           intro. simpl in *. inv H9. *)
(*           apply H10. rewrite in_map_iff. eexists; split; eauto. destr. *)
(*           rewrite EQ. *)
(*           repeat (rewrite ! map_app; simpl). *)
(*           apply Permutation_sym. apply Permutation_middle. *)
(*       } *)
(*       }  *)
(*       trim IHl1. auto. *)
(*       trim IHl1. *)
(*       { *)
(*         clear - LNR2 EQ. *)
(*         inv LNR2.  *)
(*         rewrite <- fst_align in H2, H1. rewrite EQ in H2, H1. *)
(*         rewrite map_app in *. simpl in *. *)
(*         apply list_norepet_app in H2. *)
(*         apply list_norepet_append; destr. *)
(*         constructor. intro IN. *)
(*         apply H1. rewrite in_app. destr. *)
(*         destruct H2 as [A [B C]]; inv B; auto. *)
(*         red; intros. intro; subst. *)
(*         simpl in H0; des H0. *)
(*         apply H1. rewrite in_app; destr. *)
(*         destruct H2 as [A [B C]]. *)
(*         specialize (C y y). *)
(*         apply C; auto. destr. *)
(*       } *)

(*       trim IHl1. *)
(*       auto. 2: lia. *)

(*       move IHl1 at bottom. *)

(*       rewrite filter_map_app in IHl1. *)
(*       rewrite filter_map_align_list_blocks in IHl1. *)
(*       rewrite EQ' in IHl1. *)
(*       rewrite <- filter_map_app in IHl1. *)

(*       assert (l2' = align_list_blocks l2'). *)
(*       { *)
(*         revert EQ. unfold align_list_blocks. generalize l2 l2'. *)
(*         clear. induction l2; simpl; intros; eauto. apply f_equal with (f := (length (A:=block*Z))) in EQ. rewrite app_length in EQ. destr. lia. *)
(*         des l2'. inv EQ. *)
(*         f_equal; eauto. f_equal. simpl. symmetry; apply Align.align_align; auto.         *)
(*       } *)

(*       assert (l3 = align_list_blocks l3). *)
(*       { *)
(*         revert EQ. unfold align_list_blocks. generalize l2 l2' l3. *)
(*         clear. induction l2; simpl; intros; eauto. *)
(*         apply f_equal with (f := (length (A:=block*Z))) in EQ. rewrite app_length in EQ. destr. lia. *)
(*         des l2'. inv EQ. *)
(*         rewrite map_map. apply map_ext. *)
(*         simpl. intros. rewrite Align.align_align; auto. *)
(*         inv EQ. *)
(*         rewrite H1 in IHl2. *)

(*         specialize (IHl2 _ _ eq_refl). auto. *)
(*       } *)
      
(*       clear - FB' IHl1 H H6. *)
(*       rewrite permut_filter_map in IHl1. *)
(*       Focus 2. *)
(*       apply Permutation_app. 2: auto. *)
(*       apply Permutation_sym. apply Permutation_middle. *)
(*       simpl in IHl1. *)
(*       rewrite FB' in IHl1. *)
(*       apply Permutation_sym in IHl1. *)
(*       unfold align_list_blocks in IHl1. rewrite map_app in IHl1. eapply Permutation_trans in IHl1. *)
(*       simpl in IHl1. *)
(*       2: apply Permutation_sym. 2: rewrite filter_map_app. 2: simpl; eapply Permutation_middle. *)

(*       apply Permutation_sym in IHl1. eapply Permutation_trans in IHl1. *)
(*       apply Permutation_cons_app_inv in IHl1. rewrite <- filter_map_app in IHl1. *)
(*       rewrite <- app_assoc in IHl1. apply IHl1. *)
(*       simpl. *)
(*       unfold align_list_blocks in *. rewrite <- H, <- H6. *)
(*       eapply Permutation_middle. *)
(* Qed. *)

(* Lemma filter_map_spec: *)
(*   forall {â ß} (f: â -> option ß) l x, *)
(*     In x (filter_map f l) <-> exists y, In y l /\ f y = Some x. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. split; intros; dex; destr. *)
(*   destr. *)
(*   - split; intros. *)
(*     des H. exists a; split; auto. *)
(*     rewrite IHl in i. dex. exists y; destr. *)
(*     dex. destruct H as [[A|A] H]. subst. destr. *)
(*     right; rewrite IHl. exists y; auto. *)
(*   - rewrite IHl. *)
(*     split; intros; dex. *)
(*     exists y; destr. *)
(*     des H. des o. *)
(*     exists y; destr.     *)
(* Qed. *)

(* Lemma part_inj_permut': *)
(*   forall f m1 m2 sil *)
(*     (SI : sinj f m1 m2 sil nil), *)
(*     let (l1,l2) := partition (is_injected f) (Mem.mk_block_list m1) in *)
(*     Permutation (Mem.mk_block_list m1) (l1 ++ l2) -> *)
(*     Permutation (map snd (align_list_blocks l1)) (map snd (align_list_blocks (Mem.mk_block_list m2))). *)
(* Proof. *)
(*   intros. *)
(*   destr. intros. *)
(*   generalize (part_inj_permut _ _ _ _ SI). rewrite Heqp. intro A. trim A. exact H. *)
(*   eapply Permutation_map with (f:=snd) in A. *)

(*   assert (Permutation (map snd (align_list_blocks (Mem.mk_block_list m2))) *)
(*                       (map snd (filter_map (fun x => match f (fst x) with *)
(*                                                     Some b' => Some (b', align (snd x) (two_power_nat 3)) *)
(*                                                   | None => None *)
(*                                                   end) (l ++ l0)))). *)
(*   { *)
(*     rewrite A. *)
(*     apply Permutation_map. *)
(*     apply permut_filter_map; auto. *)
(*   } *)
(*   clear A. *)
(*   rewrite filter_map_app in H0. *)
(*   generalize (in_partition_r _ _ _ _ Heqp); intro X. *)
(*   erewrite (not_inj_filter_map l0) in H0. 2: apply X. rewrite app_nil_r in H0. *)
(*   rewrite H0. *)
(*   generalize (fun x => (proj1 (in_partition_l _ _ _ _ Heqp x))); intro Y. *)
(*   generalize l Y; clear. induction l; simpl; intros; eauto. *)
  
(*   destruct (Y _ (or_introl eq_refl)) as [IN II]. *)
(*   unfold is_injected in II. destr_in II. *)
(*   apply perm_skip. *)
  
(*   apply IHl. intros; apply Y; auto.   *)
(* Qed. *)

(* Lemma sma_eq_snd': *)
(*   forall l l' z, *)
(*     map snd (align_list_blocks l) = map snd (align_list_blocks l') -> *)
(*     Forall (fun x => snd x >= 0) l -> *)
(*     Forall (fun x => snd x >= 0) l' -> *)
(*     Alloc.size_mem_al (two_power_nat MA) l z = *)
(*     Alloc.size_mem_al (two_power_nat MA) l' z. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - des l'. *)
(*   - des l'. inv H. des a; des p. *)
(*     erewrite IHl. f_equal. 2: auto. *)
(*     rewrite <- ! Align.align_distr; auto. *)
(*     f_equal. *)
(*     rewrite ! Zmax_spec. repeat destr; auto. inv H0; simpl in *; lia. *)
(*     inv H1; simpl in *; lia. *)
(*     apply f_equal with (f:= fun x => align x (two_power_nat MA)) in H3. *)
(*     rewrite ! align_plus in H3; auto. generalize (MA_bound); lia. *)
(*     generalize (MA_bound); lia. *)
(*     inv H0; auto. *)
(*     inv H1; auto.     *)
(* Qed. *)


(* Lemma size_mem_al_permut': *)
(*   forall (lb lb' : list (Z)), *)
(*     Permutation lb lb' -> *)
(*     forall (l l': list (block*Z)), *)
(*       map snd (align_list_blocks l) = lb -> map snd (align_list_blocks l') = lb' -> *)
(*       Forall (fun x => snd x >= 0) l -> *)
(*       Forall (fun x => snd x >= 0) l' -> *)
(*   forall b : Z, Alloc.size_mem_al (two_power_nat MA) l b = Alloc.size_mem_al (two_power_nat MA) l' b. *)
(* Proof. *)
(*   induction 1; simpl; intros. *)
(*   - des l; des l'. *)
(*   - des l0; des l'0. des p; des p0. *)
(*     inv H0; inv H1. *)
(*     erewrite IHPermutation; auto. *)
(*     f_equal. *)
(*     rewrite <- ! Align.align_distr; auto. *)
(*     f_equal. *)
(*     rewrite ! Zmax_spec. repeat destr; auto. inv H2; simpl in *; lia. *)
(*     inv H3; simpl in *; lia. *)
(*     apply f_equal with (f:= fun x => align x (two_power_nat MA)) in H4. *)
(*     rewrite ! align_plus in H4; auto. generalize (MA_bound); lia. *)
(*     generalize (MA_bound); lia. *)
(*     inv H2; auto. *)
(*     inv H3; auto.     *)
(*   - des l0; des l'. des l1; des l0. inv H; inv H0; inv H1; inv H2. *)
(*     inv H7; inv H8. *)
(*     des p1; des p; des p2; des p0. *)
(*     erewrite (sma_eq_snd' _ _ _ H5); auto. *)
(*     f_equal. *)
(*     rewrite <- ! Align.align_distr; auto. *)
(*     rewrite ! Align.align_align; auto. *)
(*     rewrite ! Zmax_spec. *)
(*     repeat destr; try lia. *)
(*     assert (0 < 3 <= MA)%nat by (generalize MA_bound; lia). *)
(*     apply f_equal with (f:= fun x => align x (two_power_nat MA)) in H4. *)
(*     rewrite ! align_plus in H4; auto. *)
(*     apply f_equal with (f:= fun x => align x (two_power_nat MA)) in H3. *)
(*     rewrite ! align_plus in H3; auto. *)
(*     rewrite H3,H4. lia.  *)
(*   - subst. *)


(*     Lemma Forall_Permutation: *)
(*       forall {A: Type} (P: A -> Prop) l l' *)
(*         (Pe: Permutation l l') *)
(*         (F: Forall P l),  *)
(*         Forall P l'. *)
(*     Proof. *)
(*       induction 1; simpl; intros; eauto. *)
(*       inv F; constructor; eauto. *)
(*       inv F. inv H2. *)
(*       repeat constructor; eauto. *)
(*     Qed. *)

(*     assert (Forall (fun x => exists y, x = align y (two_power_nat 3) /\ y >= 0) l'). *)
(*     { *)
(*       eapply Forall_Permutation. apply Permutation_sym. apply H0. *)
(*       clear - H4; induction l'0; simpl; intros; eauto. *)
(*       inv H4; trim IHl'0; auto. *)
(*       constructor; auto. *)
(*       exists (snd a); auto. *)
(*     } *)


(*     (* assert (POS: Forall (fun x => x >= 0) l'). *) *)
(*     (* { *) *)
(*     (*   eapply Forall_Permutation. apply Permutation_sym. apply H0. *) *)
(*     (*   clear - H4; induction l'0; simpl; intros; eauto. *) *)
(*     (*   inv H4. *) *)
(*     (*   constructor; auto. *) *)
(*     (*   apply Zle_ge. etransitivity. *) *)
(*     (*   2: apply align_le; auto. lia. *) *)
(*     (* } *) *)

    
(*     assert (exists x', l' = map snd (align_list_blocks x') /\ Forall (fun x => snd x >= 0) x'). *)
(*     { *)
(*       revert H1; clear. induction l'; simpl; intros; eauto. *)
(*       exists nil; split.  reflexivity. constructor. *)
(*       inv H1. trim IHl'; auto. dex. des IHl'.   *)
(*       des H2.  *)
(*       exists ((xH,y)::x'); simpl. *)
(*       split; auto. *)
(*     } *)
(*     dex. des H2.  *)
(*     erewrite IHPermutation1. apply IHPermutation2; eauto. 2:auto. 2:auto. *)
(*     auto.  *)
(*     auto. *)
(* Qed. *)


(* Lemma part_inj_size_mem: *)
(*   forall f m1 m2 sil l1 l2 *)
(*     (SI: sinj f m1 m2 sil nil) *)
(*     (PI : part_inj (Mem.mk_block_list m1) f = (l1, l2)), *)
(*     fst (Alloc.alloc_mem_al (two_power_nat MA) l1 *)
(*                             (two_power_nat MA, fun _ : block => 0)) = Mem.size_mem m2. *)
(* Proof. *)
(*   intros. *)
(*   unfold Mem.size_mem. *)
(*   unfold Alloc.size_mem_aux. *)
(*   rewrite fst_ama. *)
(*   eapply size_mem_al_permut'.  *)
(*   2: eauto. 2: eauto. *)
(*   unfold part_inj in PI. *)
(*   exploit (partition_app_perm (A := (block*Z))). eauto. intro P. *)
(*   generalize (part_inj_permut' _ _ _ _ SI). *)
(*   rewrite PI. intro A; trim A; auto. *)
(*   unfold part_inj in PI. *)
(*   rewrite Forall_forall. intros x IN. eapply in_partition_l in PI. *)
(*   rewrite PI in IN. *)
(*   des IN. *)
(*   des x. unfold Mem.mk_block_list in i. apply Alloc.mbla_in in i. subst. *)
(*   apply Zle_ge. apply Mem.size_block_pos. *)
(*   rewrite Forall_forall. intros x IN.  *)
(*   des x. unfold Mem.mk_block_list in IN. apply Alloc.mbla_in in IN. subst. *)
(*   apply Zle_ge. apply Mem.size_block_pos. *)
    
(* Qed. *)


         
(* Lemma part_inj_cm_above: *)
(*   forall f m2 m1 sil *)
(*     (SI: sinj f m1 m2 sil nil) *)
(*     l1 l2 (PI: part_inj (Mem.mk_block_list m1) f = (l1, l2)) *)
(*     cm (AB: Alloc.alloc_blocks MA Mem.__szmem (l1 ++ l2) = Some cm) *)
(*     b *)
(*     (NINJ: In b (map fst l2)), *)
(*     Mem.size_mem m2 <= Int.unsigned (cm b) /\ *)
(*     forall o, Mem.in_bound_m o m1 b -> Int.unsigned (cm b) + o <= Int.max_unsigned. *)
(* Proof. *)
(*   intros. *)
(*   unfold Alloc.alloc_blocks in AB. *)
(*   repeat destr_in AB. inv AB. *)
(*   unfold Alloc.alloc_mem_aux in Heqp. *)

(*   assert (Alloc.alloc_mem_al (two_power_nat MA) (l1 ++ l2) *)
(*                              (two_power_nat MA, fun _ => 0) =  *)
(*           Alloc.alloc_mem_al (two_power_nat MA) l2 *)
(*                              (  Alloc.alloc_mem_al (two_power_nat MA) l1 *)
(*                                                    (two_power_nat MA, fun _ => 0))). *)
(*   unfold Alloc.alloc_mem_al. *)
(*   rewrite fold_left_app. auto. *)
(*   rewrite H in Heqp. *)
(*   erewrite <- part_inj_size_mem; eauto. *)
(*   des ((Alloc.alloc_mem_al (two_power_nat MA) l1 *)
(*               (two_power_nat MA, fun _ : block => 0))). *)
(*   generalize (fun lnr pf => *)
(*                 Alloc.compat_alloc_range_al' *)
(*                   _ (two_power_nat_pos MA) *)
(*                   l2 lnr _ _ _ _ pf *)
(*                   Heqp *)
(*              ).   *)
(*   intro A. trim A. *)
(*   unfold part_inj in PI; eapply lnr_partition' in PI. *)
(*   destr. *)
(*   apply lnr_mbl. *)
(*   assert (0 <= z1). *)
(*   apply Alloc.alloc_size_mem_al in Heqp0. subst. *)
(*   etransitivity. 2: apply Alloc.size_mem_al_pos. *)
(*   generalize (two_power_nat_pos MA); lia. *)
(*   generalize (two_power_nat_pos MA); lia. *)
(*   generalize (two_power_nat_pos MA); lia. *)
(*   trim A; auto. *)
(*   rewrite in_map_iff in NINJ. *)
(*   destruct NINJ as [[bb zz] [EQ IN]]. *)
(*   simpl in *. subst. *)
(*   specialize (A _ _ IN). destruct A as [A B]. *)
(*   split.  *)
(*   etransitivity. apply A. *)
(*   rewrite Int.unsigned_repr. lia. *)
(*   split. lia. *)
(*   transitivity z. *)
(*   rewrite Zmax_spec in B. destr_in B; lia. *)
(*   revert l. *)
(*   generalize szmem_mu. lia. *)

(*   assert (zz = Mem.size_block m1 b). *)
(*   { *)
(*     unfold part_inj in PI.  *)
(*     erewrite in_partition_r in IN. 2: eauto. *)
(*     destruct IN as [IN NINJ]. *)
(*     unfold Mem.mk_block_list in IN. eapply Alloc.mbla_in in IN. auto. *)
(*   } *)
(*   subst. *)
(*   intros. *)
(*   rewrite Int.unsigned_repr. *)
(*   Focus 2. *)
(*   split. lia. *)
(*   transitivity z. *)
(*   rewrite Zmax_spec in B. destr_in B; lia. *)
(*   revert l. *)
(*   generalize szmem_mu. lia. *)
(*   transitivity z.  *)
(*   Focus 2.  revert l. *)
(*   generalize szmem_mu. lia. *)
(*   cut (o < Z.max 0 (Mem.size_block m1 b)). lia. *)
(*   red in H1. *)
(*   revert H1. unfold Mem.bounds_of_block, Mem.size_block, Alloc.get_size. *)
(*   repeat destr; intros [C D]; simpl in *. rewrite Zmax_spec; destr. lia. *)
(*   exploit Mem.bounds_lo_inf0. apply Heqo0. intros [E F]; subst; lia. lia.   *)
(* Qed. *)
    
(* Lemma in_bound_in_list': *)
(*   forall o m1 b *)
(*     (IB : NormaliseSpec.in_bound (Int.unsigned o) (Mem.bounds_of_block m1 b)), *)
(*     In (b, Mem.size_block m1 b) (Mem.mk_block_list m1). *)
(* Proof. *)
(*   unfold Mem.mk_block_list. *)
(*   intros. *)
(*   apply Alloc.mbla_below_in'. *)
(*   apply Mem.in_bound_valid in IB. red in IB. *)
(*   rewrite Pos2Nat.inj_lt in IB. lia. *)
(* Qed. *)



(* Lemma size_mem_pos: *)
(*   forall m, *)
(*     0 < Mem.size_mem m. *)
(* Proof. *)
(*   intros. *)
(*   unfold Mem.size_mem. *)
(*   generalize (Mem.size_mem_aux_sup1 (Mem.mk_block_list m)). *)
(*   generalize (two_power_nat_pos MA); lia. *)
(* Qed. *)


(* Lemma amem_free_addr_permut: *)
(*   forall l l', *)
(*     Permutation l l' -> *)
(*     amem_free_addr MA l = amem_free_addr MA l'. *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   - lia. *)
(*   - lia. *)
(* Qed. *)


(* Lemma nbox_align: *)
(*   forall z1 *)
(*     (LT: (0 < (Z.to_nat z1))%nat), *)
(*     Z.of_nat (nbox MA (Z.to_nat z1) * sz_box MA) = *)
(*     align (Z.max 0 z1) (two_power_nat MA). *)
(* Proof. *)
(*   intros. *)
(*   unfold nbox. *)
(*   rewrite Zmax_spec. *)
(*   destr. des z1; lia. *)
(*   unfold sz_box. *)
(*   rewrite Nat2Z.inj_mul. *)
(*   unfold ceiling. *)
(*   rewrite InstanceZ.npow_inj. *)
(*   generalize (mod_Zmod (Z.to_nat z1) (NPeano.pow 2 MA)). *)
(*   intro A; trim A. generalize (two_power MA); lia. *)
(*   destr. *)
(*   - rewrite div_Zdiv. 2: generalize (two_power MA); lia. *)
(*     revert A. *)
(*     rewrite Z2Nat.id by lia. *)
(*     rewrite InstanceZ.npow_inj. simpl. *)
(*     rewrite <- two_power_nat_equiv. *)
(*     intros. *)
(*     symmetry in A. *)
(*     apply Zmod_divide in A. *)
(*     2: generalize (two_power_nat_pos MA); lia. *)
(*     destruct A as [x A]; rewrite A. *)
(*     rewrite Z_div_mult_full. *)
(*     2: generalize (two_power_nat_pos MA); lia. *)
(*     rewrite Mem.align_mul. auto. *)
(*     apply two_power_nat_pos. *)
(*   - generalize (Z.pow_pos_nonneg 2 (Z.of_nat MA)). *)
(*     intro B. trim B. lia. *)
(*     trim B. generalize (MA_bound). lia. *)
(*     destr; try lia. *)
(*     rewrite Pos2Z.inj_mul. *)
(*     rewrite Zpos_P_of_succ_nat. *)
(*     rewrite <- Heqz. *)
(*     rewrite div_Zdiv. 2: generalize (two_power MA); lia. *)
(*     revert A. *)
(*     rewrite Z2Nat.id by lia. *)
(*     rewrite InstanceZ.npow_inj. simpl. *)
(*     rewrite <- two_power_nat_equiv. *)
(*     generalize (Z_div_mod_eq z1 _ (two_power_nat_pos MA)). *)
(*     intros C D. rewrite <- D in C. *)
(*     rewrite C. *)

(*     assert (((two_power_nat MA * (z1 / two_power_nat MA) + *)
(*               Z.pos (Pos.of_succ_nat n)) / two_power_nat MA) *)
(*             = (z1 / two_power_nat MA) + *)
(*               Z.pos (Pos.of_succ_nat n) / two_power_nat MA). *)
(*     { *)
(*       rewrite (Z.add_comm (Z.mul _ _) (Z.pos _)). *)
(*       rewrite Z.mul_comm. *)
(*       rewrite Z_div_plus. *)
(*       2: apply two_power_nat_pos. *)
(*       apply Z.add_comm. *)
(*     } *)
(*     rewrite H. clear H. *)
(*     rewrite (Zdiv_small (Z.pos (Pos.of_succ_nat n))). *)
(*     2: split; [lia|]. *)
(*     2: rewrite D; apply Z_mod_lt. 2: apply two_power_nat_pos. *)
(*     rewrite Z.add_0_r. *)
(*     rewrite (Z.mul_comm (two_power_nat MA)). *)
(*     rewrite <- (Mem.align_mul _ (two_power_nat_pos MA) (z1/two_power_nat MA)). *)
(*     rewrite <- align_distr. 2: apply two_power_nat_pos. *)
(*     rewrite Mem.align_mul. *)
(*     unfold Z.succ. *)
(*     rewrite Z.mul_add_distr_r. f_equal. *)
(*     rewrite Mem.align_small. reflexivity. *)
(*     apply two_power_nat_pos. 2: apply two_power_nat_pos. *)
(*     split. lia. *)
(*     rewrite D. *)
(*     generalize (Z_mod_lt z1 _ (two_power_nat_pos MA)). lia. *)
(* Qed. *)

(* Lemma perm_list_blocks: *)
(*   forall m, *)
(*     Permutation (list_blocks m) (map fst (filter (fun x => snd x >? 0) (Mem.mk_block_list m))). *)
(* Proof. *)
(*   unfold list_blocks, Mem.mk_block_list. *)
(*   unfold Alloc.mk_block_list_aux. *)
(*   intros. *)
(*   generalize (Alloc.list_ints (pred (Pos.to_nat (Mem.nextblock m)))). *)
(*   induction l; simpl; intros; eauto. *)
(*   destr. *)
(*   - rewrite (proj1 (Zgt_is_gt_bool _ _)). 2: lia. *)
(*     simpl. constructor. *)
(*     apply IHl. *)
(*   - destr. *)
(*     apply Zgt_is_gt_bool in Heqb. lia. *)
(* Qed. *)

(* Lemma amem_free_addr_szmem: *)
(*   forall m2 cm2 *)
(*     (* (Q : acm_of_mem m2 = Some m2') *), *)
(*     two_power_nat MA + Z.of_nat (amem_free_addr MA (spec_of_acmem (acm_of_mem m2 cm2))) = *)
(*     Mem.size_mem m2. *)
(* Proof. *)
(*   unfold acm_of_mem. intros m2 cm2. *)
(*   Opaque Z.add. *)
(*   erewrite amem_free_addr_permut. *)
(*   2: apply Permutation_map. *)
(*   2: apply Mem.permut_filter. *)
(*   2: apply Permutation_sym. *)
(*   2: apply scmem_permut. *)
(*   unfold Mem.size_mem. *)
(*   unfold Alloc.size_mem_aux. *)
(*   generalize (align_refl _ (two_power_nat_pos MA)). *)
(*   generalize (two_power_nat MA) at 1 3 4 6. *)
(*   generalize (Mem.mk_block_list m2). clear. *)
(*   induction l; simpl; intros; eauto. *)
(*   lia. *)
(*   des a. *)
(*   rewrite <- IHl. *)
(*   destr. *)
(*   - match goal with *)
(*       |- context[amem_free_addr ?a ?b] => generalize (amem_free_addr a b) *)
(*     end. *)
(*     clear IHl. *)
(*     intros. *)
(*     rewrite Nat2Z.inj_add. *)
(*     rewrite <- align_distr. *)
(*     rewrite H. *)
(*     rewrite <- Z.add_assoc. f_equal. f_equal. *)
(*     rewrite nbox_align. auto. *)
(*     rewrite NPeano.ltb_lt in Heqb0. auto. *)
(*     apply two_power_nat_pos. *)
(*   - f_equal.  *)
(*     rewrite <- align_distr. 2: apply two_power_nat_pos. *)
(*     apply ltb_false in Heqb0. *)
(*     rewrite H. rewrite Zmax_l. rewrite align_0. lia. *)
(*     apply two_power_nat_pos. des z0; lia. *)
(*   - rewrite align_align. auto. *)
(*     apply two_power_nat_pos. *)
(* Qed. *)


(* Lemma cmem_free_addr_reduce: *)
(*   forall l, *)
(*     sorted_ca l -> *)
(*     cmem_free_addr l = *)
(*     reduce max O (map (fun x => ac_addr x + ac_size x)%nat l). *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   rewrite Max.max_l; auto. lia. *)
(*   simpl in *. *)
(*   rewrite IHsorted_ca. *)
(*   rewrite Max.max_assoc. *)
(*   rewrite (Max.max_l _ (ac_addr a + _)). auto. *)
(*   lia.   *)
(* Qed. *)

(* Lemma reduce_perm: *)
(*   forall l1 l2 (P: Permutation l1 l2) z, *)
(*     reduce max z l1 = *)
(*     reduce max z l2. *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   - f_equal. *)
(*     rewrite Max.max_assoc. *)
(*     rewrite (Max.max_comm x y). *)
(*     rewrite <- Max.max_assoc. auto. *)
(*   - congruence. *)
(* Qed. *)

(* Lemma align_reduce: *)
(*   forall al (alpos: al > 0) l z, *)
(*     align (Z.of_nat (reduce max z l)) al = *)
(*     align (Z.of_nat (reduce max (Z.to_nat (align (Z.of_nat z) al)) l)) al. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   rewrite Z2Nat.id. *)
(*   rewrite align_align; auto. *)
(*   etransitivity. 2: apply align_le; auto. lia. *)
(*   rewrite IHl. *)
(*   rewrite (IHl (max _ _)). *)
(*   f_equal. f_equal. *)
(*   f_equal. f_equal. *)
(*   rewrite ! Mem.maxspec. *)
(*   repeat destr. *)
(*   rewrite Z2Nat.id. *)
(*   symmetry; apply align_align; auto. *)
(*   etransitivity. 2: apply align_le; auto. lia. *)
(*   auto. *)
(*   generalize (align_le (Z.of_nat z) _ alpos). intro A. *)
(*   apply Z2Nat.inj_le in A. rewrite Nat2Z.id in A. lia. lia. *)
(*   etransitivity. 2: apply align_le; auto. lia. *)
(*   rewrite Z2Nat.id. *)
(*   symmetry; rewrite align_align; auto. *)
(*   apply Z.le_antisymm. *)
(*   apply align_add; auto. lia. *)
(*   apply Nat2Z.inj_lt in l0. *)
(*   rewrite Z2Nat.id in l0. *)
(*   rewrite <- (align_align (Z.of_nat z)); auto. *)
(*   apply align_add; auto. lia. *)
(*   etransitivity. 2: apply align_le; auto. lia. *)
(*   etransitivity. 2: apply align_le; auto. lia. *)
(* Qed. *)

(* Lemma align_max: *)
(*   forall al (alpos: al > 0) a (Apos: a >= 0) b (Bpos: b >= 0), *)
(*     align (Z.max a b) al = *)
(*     Z.max (align a al) (align b al). *)
(* Proof. *)
(*   intros. *)
(*   rewrite ! Zmax_spec. *)
(*   repeat destr. *)
(*   apply Z.le_antisymm. lia. *)
(*   apply align_add; auto. lia. *)
(*   apply Z.le_antisymm. lia. *)
(*   apply align_add; auto. lia. *)
(* Qed. *)

(* Lemma cmem_free_addr_nextaddr: *)
(*   forall m2 cm2 (COMP: Mem.compat_m m2 Mem.M32 cm2), *)
(*     Z.of_nat (cmem_free_addr (acm_of_mem m2 cm2)) = *)
(*     next_addr m2 cm2. *)
(* Proof. *)
(*   intros.  *)
(*   rewrite cmem_free_addr_reduce. *)
(*   2: destruct (mem_is_memory _ _ COMP); auto. *)
(*   unfold acm_of_mem.  *)
(*   unfold next_addr. *)
(*   erewrite reduce_perm. *)
(*   2:apply Permutation_map. *)
(*   2: apply Mem.permut_filter. *)
(*   2: apply Permutation_sym; apply scmem_permut. *)
(*   unfold Mem.mk_block_list, Alloc.mk_block_list_aux. *)
(*   unfold list_blocks. *)
(*   change 0 with (Z.of_nat O) at 1. *)
(*   generalize O at 1 3. *)
(*   generalize (Alloc.list_ints (pred (Pos.to_nat (Mem.nextblock m2)))). *)

(*   induction l; simpl; intros; eauto. *)
(*   des (zlt 0 (Mem.size_block m2 (Pos.of_nat a))). *)
(*   rewrite <- (Z2Nat.id ( (Int.unsigned (cm2 (Pos.of_nat a)) + *)
(*                               Mem.size_block m2 (Pos.of_nat a)) *)
(*                           )). *)
(*   rewrite <- Nat2Z.inj_max. *)
(*   rewrite <- IHl. *)
(*   destr. *)
(*   f_equal. f_equal. f_equal. *)
(*   replace n with (Z.to_nat (Z.of_nat n)). *)
(*   rewrite <- Z2Nat.inj_add. auto. *)
(*   generalize (Int.unsigned_range (cm2 (Pos.of_nat a))); lia. *)
(*   lia. *)
(*   apply Nat2Z.id. *)
(*   exfalso; clear - l0 Heqb. *)
(*   nattac. apply Z2Nat.inj_lt in l0. lia. lia. lia. *)
(*   generalize (Int.unsigned_range (cm2 (Pos.of_nat a))); lia. *)
(*   rewrite <- IHl. *)
(*   replace (NPeano.ltb 0 (Z.to_nat (Mem.size_block m2 (Pos.of_nat a)))) *)
(*   with false. auto. *)
(*   destruct (NPeano.ltb _ _) eqn:?; auto. *)
(*   nattac. *)
(*   clear - Heqb g. *)
(*   apply Nat2Z.inj_lt in Heqb. *)
(*   rewrite Z2Nat.id in Heqb. lia. *)
(*   apply Mem.size_block_pos. *)
(* Qed. *)

(* Lemma Forall_app: *)
(*   forall {A: Type} P (l1 l2: list A), *)
(*     Forall P l1 -> Forall P l2 -> Forall P (l1 ++ l2). *)
(* Proof. *)
(*   induction 1; simpl; intros; auto. *)
(* Qed. *)

(* Lemma box_sorted_nin: *)
(*   forall e *)
(*     (ISSMALL : is_box 3 e) *)
(*     l2 *)
(*     (IN : In e l2) *)
(*     (is_sorted : sorted_ca (e :: l2)), *)
(*     False. *)
(* Proof. *)
(*   induction l2; simpl; intros; eauto. *)
(*   assert (e = a \/ e <> a). *)
(*   { *)
(*     destruct e. destruct a. *)
(*     des (eq_nat_dec ac_addr ac_addr0). *)
(*     des (eq_nat_dec ac_size ac_size0). *)
(*   } *)
(*   des H. *)
(*   inv is_sorted. inv ISSMALL.  *)
(*   generalize (sz_box_not_zero (proj1 MA_bound)). lia. *)
(*   des IN.  *)
(*   apply IHl2; auto. *)
(*   inv is_sorted. *)
(*   inv SORTEDTAIL. *)
(*   constructor. *)
(*   constructor. auto. lia. *)
(* Qed. *)


(* Lemma is_memory_lnr: *)
(*   forall cm, *)
(*     is_memory 3 cm -> *)
(*     list_norepet cm. *)
(* Proof. *)
(*   intros cm A; inv A. *)
(*   revert is_sorted size_gt. *)
(*   clear. *)
(*   induction 1; simpl; intros; eauto; repeat constructor;eauto. *)
(*   - simpl. *)
(*     intros [A|A]. subst. *)
(*     specialize (size_gt _ (or_introl eq_refl)). lia. *)
(*     generalize (In_split _ _ A). *)
(*     intros [l1 [l2 EQ]]. *)
(*     generalize (sorted_in (proj1 MA_bound) l1 nil b a l2). *)
(*     rewrite <- EQ. simpl. *)
(*     intro C; trim C; auto. *)
(*     generalize (size_gt _ (or_introl eq_refl)). *)
(*     generalize (size_gt _ (or_intror (or_introl eq_refl))). lia. *)
(*   - trim IHis_sorted. *)
(*     intros; apply size_gt; simpl ;auto. *)
(*     inv IHis_sorted; auto. *)
(*   - trim IHis_sorted. *)
(*     intros; apply size_gt; simpl ;auto. *)
(*     inv IHis_sorted; auto. *)
(* Qed. *)

(* Lemma sorted_ca_cons_add: *)
(*   forall e l, *)
(*     sorted_ca l -> *)
(*     Forall (fun x => ac_addr e + ac_size e <= ac_addr x)%nat l -> *)
(*     sorted_ca (e::l). *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   - constructor. *)
(*   - inv H. constructor. constructor. auto. *)
(*   - inv H0. trim IHsorted_ca; auto. *)
(*     constructor. constructor. inv IHsorted_ca; auto. auto. auto. *)
(* Qed. *)


(* Lemma sorted_ca_Forall: *)
(*   forall e l, *)
(*     sorted_ca (e::l) -> *)
(*     Forall (fun x => ac_addr e + ac_size e <= ac_addr x)%nat l. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - constructor. inv H. auto. *)
(*     trim IHl. *)
(*     inv H. inv SORTEDTAIL. constructor. constructor. auto. lia. *)
(*     auto. *)
(* Qed. *)


(* Lemma has_more_box_in: *)
(*   forall l1 l2 n, *)
(*     has_more_box 3 l1 l2 n -> *)
(*     forall x, In x l2 -> In x l1. *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   assert ({e = x} + {e <> x}) by (decide equality). *)
(*   des H1. des H0. right; eauto. *)
(* Qed. *)

(* Inductive match_forgotten_holes: list block -> list ACblock -> Prop := *)
(* | mfh_nil: forall l, match_forgotten_holes l nil *)
(* | mfh_cons: *)
(*     forall lb lh b h *)
(*       (MFH: match_forgotten_holes lb lh), *)
(*       match_forgotten_holes (b::lb) (h::lh). *)

(* Lemma has_more_box_spec: *)
(*   forall cm1 cm2 n, *)
(*     has_more_box 3 cm1 cm2 n -> *)
(*     is_memory 3 cm1 -> *)
(*     exists l, *)
(*       length l = n /\ *)
(*       Forall (fun x => is_box 3 x) l /\ *)
(*       list_norepet l /\ *)
(*       sorted_ca l /\ *)
(*       sublist l cm1 /\ *)
(*       (forall x, In x l -> In x cm1) /\ *)
(*       (forall x, In x l -> ~ In x cm2) *)
(* . *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   - exists nil; repSplit; try constructor. destr. destr. *)
(*   - destruct IHhas_more_box as [l [LEN [F [LNR [SCA [SL [HYP HYP']]]]]]]. *)
(*     inv H0; constructor. *)
(*     intros; apply blocks_aligned; simpl; auto. *)
(*     intros; apply size_gt; simpl; auto. *)
(*     inv is_sorted; auto. constructor. *)
(*     exists (e::l); repSplit. *)
(*     + simpl; auto. *)
(*     + constructor; auto. *)
(*     + constructor; auto. *)
(*       apply is_memory_lnr in H0; inv H0. *)
(*       intro IN. apply HYP in IN. auto. *)
(*     + apply sorted_ca_cons_add. auto. *)
(*       rewrite Forall_forall. intros x IN. *)
(*       apply HYP in IN. *)
(*       inv H0. *)
(*       generalize (sorted_ca_Forall e l2 is_sorted). *)
(*       rewrite Forall_forall. *)
(*       intro E; apply E. auto. *)
(*     + constructor; auto. *)
(*     + intros. simpl in H1. *)
(*       des H1. right; apply HYP; auto. *)
(*     + intros. simpl in H1. *)
(*       assert ({e = x} + {e <> x}) by (decide equality). *)
(*       des H2; [|apply HYP'; destr]. *)
(*       clear H1. intro IN. *)
(*       exploit has_more_box_in. apply H. apply IN. intro IN2. *)
(*       destruct (in_split _ _ IN2) as [l1' [l2' EQ]]. *)
(*       subst. *)
(*       generalize (sorted_in (proj1 MA_bound) l1' nil x x l2'). *)
(*       simpl. *)
(*       intro B; trim B. eapply is_sorted; eauto. *)
(*       inv ISSMALL. *)
(*       revert B is_box_size. *)
(*       generalize (sz_box_not_zero (proj1 MA_bound)). lia.  *)
(*   - destruct IHhas_more_box as [l [LEN [F [LNR [SCA [SL [HYP HYP']]]]]]]. *)
(*     inv H0; constructor. *)
(*     intros; apply blocks_aligned; simpl; auto. *)
(*     intros; apply size_gt; simpl; auto. *)
(*     inv is_sorted; auto. constructor. *)
(*     exists l; repSplit; auto. *)
(*     constructor. auto. *)
(*     intros. generalize H1; intro A. apply HYP' in H1. intros [X | X]; destr. *)
(*     subst. generalize A; intro C. apply HYP in A. *)
(*     destruct (in_split _ _ A) as [l1' [l2' EQ]]. *)
(*     subst. *)
(*     generalize (sorted_in (proj1 MA_bound) l1' nil x x l2'). *)
(*     simpl. *)
(*     intro B; trim B. eapply is_sorted; eauto. *)
(*     rewrite Forall_forall in F; apply F in C. inv C. revert B is_box_size. *)
(*     generalize (sz_box_not_zero (proj1 MA_bound)). lia.  *)
(* Qed. *)

(* Lemma lnr_filter : *)
(*   forall {A} f (l: list A), *)
(*     list_norepet l -> list_norepet (filter f l). *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   constructor. destr; constructor; auto. *)
(*   intro IN. rewrite filter_In in IN. destr. *)
(* Qed. *)

(* Lemma permut_app_cons: *)
(*   forall {A} l l' *)
(*     (H : Permutation l l') *)
(*     l0 l'0 a (EQ: l' = l0 ++ a :: l'0), *)
(*   exists l1 l' : list A, *)
(*     l = l1 ++ a :: l' /\ Permutation (l1 ++ l') (l0 ++ l'0). *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   - des l0. *)
(*     inv EQ. *)
(*     exists nil, l; split; auto. *)
(*     inv EQ. *)
(*     specialize (IHPermutation _ _ _ eq_refl). *)
(*     destruct IHPermutation as [l0 [l' [EQ P]]]; *)
(*       exists (a0::l0), l'; split; auto. *)
(*     subst. reflexivity. simpl. *)
(*     constructor. auto. *)
(*   - des l0. *)
(*     inv EQ. *)
(*     exists (y::nil), l; split; destr; auto. *)
(*     inv EQ. des l1. *)
(*     inv H1. *)
(*     exists nil, (a0::l'0). split. reflexivity. *)
(*     simpl; auto. *)
(*     inv H1. *)
(*     exists (a1 :: a0 :: l0), l'0; split; auto. *)
(*     simpl. *)
(*     apply perm_swap. *)
(*   - subst. *)
(*     specialize (IHPermutation2 _ _ _ eq_refl). *)
(*     destruct IHPermutation2 as [l1 [l'1 [EQ P]]]. subst. *)
(*     specialize (IHPermutation1 _ _ _ eq_refl). *)
(*     destruct IHPermutation1 as [l2 [l' [EQ P']]]. subst. *)
(*     exists l2, l'; split; auto. *)
(*     apply Permutation_app_inv in H. *)
(*     apply Permutation_app_inv in H0. *)
(*     rewrite H, H0; auto. *)
(* Qed. *)

(* Lemma permut_cons: *)
(*   forall {A} (l1: list A) a l2 , *)
(*     Permutation l1 (a::l2) -> *)
(*     exists l l', l1 = l ++ a :: l' /\ *)
(*             Permutation (l ++ l') l2. *)
(* Proof. *)
(*   intros. *)
(*   apply (permut_app_cons _ _ H nil l2 a). destr. *)
(* Qed. *)

(* Lemma size_mem_al_plus: *)
(*   forall al (alpos: al > 0) l0 z,  *)
(*     Alloc.size_mem_al al l0 (align z al) = *)
(*     align z al + Alloc.size_mem_al al l0 0. *)
(* Proof. *)
(*   induction l0; simpl; intros; eauto. *)
(*   - lia. *)
(*   - destr. *)
(*     rewrite  !IHl0. *)
(*     rewrite <- ! align_distr; auto. *)
(*     rewrite align_align; auto. *)
(*     rewrite align_0; auto. lia. *)
(* Qed. *)

(* Lemma size_mem_al_mul: *)
(*   forall al (alpos: al > 0) l *)
(*     (F: Forall (fun x => snd x <= al) l) *)
(*     z, *)
(*     Alloc.size_mem_al al l (align z al) = *)
(*     align z al + al * Z.of_nat (length (filter (fun x => snd x >? 0) l)). *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. lia. *)
(*   des a.  *)
(*   inv F. *)
(*   rewrite IHl; auto. *)
(*   destr;  rewrite <- ! align_distr; auto. *)
(*   rewrite align_align; auto. *)
(*   rewrite (Mem.align_small _ alpos (Z.max 0 z0)). lia. *)
(*   apply (proj2 (Zgt_is_gt_bool _ _)) in Heqb0. lia. *)
(*   rewrite align_align; auto. *)
(*   rewrite Z.max_l. rewrite align_0. lia. auto. *)
(*   generalize (Z.gtb_spec z0 0). rewrite Heqb0. *)
(*   intro A; inv A. auto. *)
(* Qed. *)

(* Lemma zof_nat_eq: *)
(*   forall n m, *)
(*     Z.of_nat n = Z.of_nat m -> *)
(*     n = m. *)
(* Proof. *)
(*   intros. *)
(*   cut (Z.to_nat (Z.of_nat n) = Z.to_nat (Z.of_nat m)); destr. *)
(*   intros. *)
(*   rewrite ! Nat2Z.id in H0; auto. *)
(* Qed. *)

(* Lemma partition_filter: *)
(*   forall {A} (l: list A) f l1 l2, *)
(*     partition f l = (l1,l2) -> *)
(*     l1 = filter f l /\ l2 = filter (fun b => negb (f b)) l. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - inv H; auto. *)
(*   - destr_in H. *)
(*     specialize (IHl _ _ _ Heqp). destruct IHl. *)
(*     destr. *)
(* Qed. *)

(* Lemma diff_inv: *)
(*   forall x y, *)
(*     (x <= y -> *)
(*      diff x y = y - x)%nat. *)
(* Proof. *)
(*   unfold diff. *)
(*   intros. *)
(*   rewrite Max.max_r; auto. *)
(*   rewrite Min.min_l; auto. *)
(* Qed. *)


(* Lemma nbox_align': *)
(*   forall al z1 *)
(*     (LT: (0 < z1)%nat), *)
(*     Z.of_nat (nbox al z1 * sz_box al) = *)
(*     align (Z.of_nat z1) (two_power_nat al). *)
(* Proof. *)
(*   intros. *)
(*   unfold nbox. *)
(*   unfold sz_box. *)
(*   rewrite Nat2Z.inj_mul. *)
(*   unfold ceiling. *)
(*   rewrite InstanceZ.npow_inj. *)
(*   generalize (mod_Zmod z1 (NPeano.pow 2 al)). *)
(*   intro A; trim A. generalize (two_power al); lia. *)
(*   destr. *)
(*   - rewrite div_Zdiv. 2: generalize (two_power al); lia. *)
(*     revert A. *)
(*     rewrite InstanceZ.npow_inj. simpl. *)
(*     rewrite <- two_power_nat_equiv. *)
(*     intros. *)
(*     symmetry in A. *)
(*     apply Zmod_divide in A. *)
(*     2: generalize (two_power_nat_pos al); lia. *)
(*     destruct A as [x A]; rewrite A. *)
(*     rewrite Z_div_mult_full. *)
(*     2: generalize (two_power_nat_pos al); lia. *)
(*     rewrite Mem.align_mul. auto. *)
(*     apply two_power_nat_pos. *)
(*   - generalize (Z.pow_pos_nonneg 2 (Z.of_nat al)). *)
(*     intro B. trim B. lia. *)
(*     trim B. lia.  *)
(*     destr; try lia. *)
(*     rewrite Pos2Z.inj_mul. *)
(*     rewrite Zpos_P_of_succ_nat. *)
(*     rewrite <- Heqz. *)
(*     rewrite div_Zdiv. 2: generalize (two_power al); lia. *)
(*     revert A. *)
(*     rewrite InstanceZ.npow_inj. simpl. *)
(*     rewrite <- two_power_nat_equiv. *)
(*     generalize (Z_div_mod_eq (Z.of_nat z1) _ (two_power_nat_pos al)). *)
(*     intros C D. rewrite <- D in C. *)
(*     rewrite C. *)

(*     assert (((two_power_nat al * (Z.of_nat z1 / two_power_nat al) + *)
(*               Z.pos (Pos.of_succ_nat n)) / two_power_nat al) *)
(*             = (Z.of_nat z1 / two_power_nat al) + *)
(*               Z.pos (Pos.of_succ_nat n) / two_power_nat al). *)
(*     { *)
(*       rewrite (Z.add_comm (Z.mul _ _) (Z.pos _)). *)
(*       rewrite Z.mul_comm. *)
(*       rewrite Z_div_plus. *)
(*       2: apply two_power_nat_pos. *)
(*       apply Z.add_comm. *)
(*     } *)
(*     rewrite H. clear H. *)
(*     rewrite (Zdiv_small (Z.pos (Pos.of_succ_nat n))). *)
(*     2: split; [lia|]. *)
(*     2: rewrite D; apply Z_mod_lt. 2: apply two_power_nat_pos. *)
(*     rewrite Z.add_0_r. *)
(*     rewrite (Z.mul_comm (two_power_nat al)). *)
(*     rewrite <- (Mem.align_mul _ (two_power_nat_pos al) (Z.of_nat z1/two_power_nat al)). *)
(*     rewrite <- align_distr. 2: apply two_power_nat_pos. *)
(*     rewrite Mem.align_mul. *)
(*     unfold Z.succ. *)
(*     rewrite Z.mul_add_distr_r. f_equal. *)
(*     rewrite Mem.align_small. reflexivity. *)
(*     apply two_power_nat_pos. 2: apply two_power_nat_pos. *)
(*     split. lia. *)
(*     rewrite D. *)
(*     generalize (Z_mod_lt (Z.of_nat z1) _ (two_power_nat_pos al)). lia. *)
(* Qed. *)


(* Lemma next_box_align: *)
(*   forall x y, *)
(*     next_box x y = Z.to_nat (align (Z.of_nat y) (two_power_nat x)). *)
(* Proof. *)
(*   intros. *)
(*   unfold next_box. *)
(*   destruct (lt_dec 0 y). *)
(*   rewrite <- nbox_align'; auto. rewrite Nat2Z.id; auto. *)
(*   assert (y = O) by lia. subst. *)
(*   rewrite align_0; auto. *)
(*   unfold nbox, ceiling. rewrite NPeano.Nat.mod_0_l; auto. *)
(*   2: eapply sz_box_not_zero; eauto. *)
(*   rewrite div_undef. simpl. auto.    *)
(* Qed. *)

(* Lemma size_mem_aligned_3: *)
(*   forall m, *)
(*     Mem.size_mem m = align (Mem.size_mem m) (two_power_nat 3). *)
(* Proof. *)
(*   unfold Mem.size_mem. intros. *)
(*   rewrite Mem.size_mem_aux_aligned. *)
(*   generalize (Alloc.size_mem_aux MA (Mem.mk_block_list m)). *)
(*   intros. *)
(*   destruct (align_divides z _ (two_power_nat_pos MA)). *)
(*   rewrite H. *)
(*   replace (two_power_nat MA) with (two_power_nat (MA - 3) * two_power_nat 3). *)
(*   rewrite Z.mul_assoc. *)
(*   rewrite Mem.align_mul. auto. auto. *)
(*   rewrite ! two_power_nat_two_p. *)
(*   rewrite <- two_p_is_exp by lia. f_equal. *)
(*   generalize MA_bound; lia. *)
(* Qed. *)


(* Lemma minus_minus: *)
(*   forall a b c, *)
(*     (c <= b -> b <= a -> a - (b - c) = a - b + c)%nat. *)
(* Proof. *)
(*   induction a; simpl; intros. lia. *)
(*   destr. des b. lia. *)
(*   des c. assert (n = n0) by lia. subst. lia. *)
(*   des b. des c. inv Heqn. lia. lia. *)
(* Qed. *)

(* Lemma szmem_bndinf: *)
(*   forall m, two_power_nat MA <= Mem.size_mem m. *)
(* Proof. *)
(*   unfold Mem.size_mem, Alloc.size_mem_aux. *)
(*   intros. *)
(*   apply Alloc.size_mem_al_pos; auto. *)
(*   generalize (two_power_nat_pos MA); lia. *)
(* Qed. *)

(* Lemma length_filter_true: *)
(*   forall {A} (f: A -> bool) l, *)
(*     Forall (fun x => f x = true) l -> *)
(*     length (filter f l) = length l. *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   destr. *)
(* Qed. *)

(* Ltac nattac' := *)
(*   repeat match goal with *)
(*          | H: beq_nat ?a ?b = true |- _ => apply beq_nat_true in H *)
(*          | H: beq_nat ?a ?b = false |- _ => apply beq_nat_false in H *)
(*          | H: context [beq_nat ?a ?b] |- _ => des (beq_nat a b) *)
(*          | |- context [beq_nat ?a ?b] => des (beq_nat a b) *)
(*          end. *)
(* Lemma Forall_filter: *)
(*   forall {A} (P: A -> Prop) f l, *)
(*     Forall P l -> *)
(*     Forall P (filter f l). *)
(* Proof. *)
(*   induction 1; simpl; intros; repeat constructor; eauto. *)
(*   destr; constructor; auto. *)
(* Qed. *)
(* Lemma Forall_and: *)
(*   forall {A} (P Q: A -> Prop) l, *)
(*     Forall P l -> *)
(*     Forall Q l -> *)
(*     Forall (fun x => P x /\ Q x) l. *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   inv H1. constructor; auto. *)
(* Qed. *)

(* Fixpoint make_cm (cm: block -> int) (lblocks: list block) (lholes: list ACblock) *)
(*   : ((block -> int) * list block) := *)
(*   match lblocks, lholes with *)
(*     b::lb, h::lh => *)
(*     let (cm,ll) := make_cm cm lb lh in *)
(*     (update peq cm b (Int.repr (Z.of_nat (ac_addr h))),ll) *)
(*   | _, _ => (cm,lblocks) *)
(*   end. *)

(* Lemma make_cm_lengths: *)
(*   forall lb cm lh cm' lb', *)
(*     make_cm cm lb lh = (cm', lb') -> *)
(*     (length lb' = length lb - length lh)%nat. *)
(* Proof. *)
(*   induction lb; simpl; intros; eauto. *)
(*   - inv H; reflexivity. *)
(*   - des lh; try destr_in H; inv H. reflexivity. *)
(*     apply IHlb in Heqp. auto.  *)
(* Qed. *)

(* Fixpoint add_blocks_after (cm: block -> int) (lb: list block) (A: int) : block -> int := *)
(*   match lb with *)
(*     nil => cm *)
(*   | b::lb => add_blocks_after (update peq cm b A) lb (Int.repr (Int.unsigned A + two_power_nat 3)) *)
(*   end. *)

(* Definition realloc_blocks cm lb lh N : block -> int := *)
(*   let (cm',lb') := make_cm cm lb lh in *)
(*   add_blocks_after cm' lb' N. *)

(* Lemma make_cm_other: *)
(*   forall cm lb lh b (NIN: ~ In b lb), *)
(*     (fst (make_cm cm lb lh)) b = cm b. *)
(* Proof. *)
(*   induction lb; simpl; intros; eauto. *)
(*   des lh. destr. *)
(*   unfold update; destr. *)
(*   specialize (IHlb l b). trim IHlb. destr. *)
(*   rewrite Heqp in IHlb. destr. *)
(* Qed. *)


(* Lemma make_cm_other': *)
(*   forall cm lb lh b (NIN: ~ In b lb) cm' lb', *)
(*     make_cm cm lb lh = (cm',lb') -> *)
(*     cm' b = cm b. *)
(* Proof. *)
(*   intros. *)
(*   specialize (make_cm_other cm _ lh _ NIN). *)
(*   rewrite H. destr. *)
(* Qed. *)

(* Lemma add_blocks_after_other: *)
(*   forall lb cm N b (NIN: ~ In b lb), *)
(*     add_blocks_after cm lb N b = cm b. *)
(* Proof. *)
(*   induction lb; simpl; intros; eauto. *)
(*   rewrite IHlb.  *)
(*   unfold update; destr. destr. *)
(* Qed. *)

(* Lemma make_cm_in: *)
(*   forall lb cm lh lb' cm' (MC: make_cm cm lb lh = (cm',lb')) *)
(*     b (IN: In b lb'), In b lb. *)
(* Proof. *)
(*   induction lb; simpl; intros; eauto. *)
(*   - inv MC; destr. *)
(*   - destr_in MC. *)
(*     inv MC; destr. *)
(*     destr_in MC. inv MC. eauto.  *)
(* Qed. *)

(* Lemma cmem_free_addr_spec: *)
(*   forall m, *)
(*     sorted_ca m -> *)
(*     Forall (fun x => ac_size x <> O) m -> *)
(*     Forall (fun x => ac_addr x + ac_size x <= cmem_free_addr m)%nat m. *)
(* Proof. *)
(*   induction 1; simpl; intros. *)
(*   - constructor. *)
(*   - constructor; auto. *)
(*   - inv H0. trim IHsorted_ca; auto. *)
(*     inv IHsorted_ca; inv H4. *)
(*     constructor; auto. simpl in *. lia. *)
(* Qed. *)


(* Lemma prop_eq_impl: *)
(*   forall {A: Type} (P: A -> Prop) a b (eq: a = b), P a -> P b. *)
(* Proof. *)
(*   intros. rewrite <- eq. auto. *)
(* Qed. *)

(* Lemma make_cm_lnr: *)
(*   forall lb (lnr: list_norepet lb) cm lh cm' lb', *)
(*     make_cm cm lb lh = (cm',lb') -> *)
(*     list_norepet lb'. *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   - inv H; constructor. *)
(*   - destr_in H0. inv H0; constructor; auto. *)
(*     destr_in H0. inv H0;  auto. eapply IHlnr; eauto. *)
(* Qed. *)



(* Lemma cmem_free_addr_In: *)
(*   forall           l l' *)
(*               (INimpl: sublist l l') *)
(*               (SCA: sorted_ca l'), *)
(*     (cmem_free_addr l <= cmem_free_addr l')%nat. *)
(* Proof. *)
(*   intros. eapply sublist_cmem_free_addr. *)
(*   apply MA_bound. auto. *)
(*   eapply sublist_sorted. apply MA_bound. eauto. *)
(*   auto. auto. *)
(* Qed. *)

(* Lemma in_bound_size_not_null: *)
(*   forall o m b *)
(*     (IB : NormaliseSpec.in_bound o (Mem.bounds_of_block m b)), *)
(*     Mem.size_block m b <> 0. *)
(* Proof. *)
(*   intros. *)
(*   generalize (Mem.bounds_size m b) (Mem.size_block_snd m b) (Mem.bounds_lo_0 m b). *)
(*   des (Mem.bounds_of_block m b). *)
(*   intros A B; specialize (A _ _ eq_refl). subst. red in IB. *)
(*   simpl in *. intros; subst. lia. *)
(* Qed. *)


(* Lemma pow_tpnat: *)
(*   forall x, *)
(*     two_power_nat x = Z.of_nat (NPeano.pow 2 x). *)
(* Proof. *)
(*   intros. *)
(*   rewrite two_power_nat_equiv. *)
(*   rewrite InstanceZ.npow_inj. reflexivity. *)
(* Qed. *)

(* Lemma not_in_mbla_0: *)
(*   forall n b sz, *)
(*     ~ In b (map fst (Alloc.mk_block_list_aux sz n)) -> *)
(*     (Pos.to_nat b > n)%nat. *)
(* Proof. *)
(*   induction n; simpl; intros; eauto. *)
(*   lia. *)
(*   apply Decidable.not_or in H. *)
(*   destruct H as [A B]. *)
(*   trim (IHn b sz). *)
(*   apply B.  *)
(*   cut (S n < Pos.to_nat b)%nat. lia. *)
(*   rewrite NPeano.Nat.le_neq. split; auto. *)
(*   intro EQ. *)
(*   apply f_equal with (f:= Pos.of_nat) in EQ. *)
(*   rewrite Pos2Nat.id in EQ. destr. *)
(* Qed. *)

(* Lemma invalid_block_size: *)
(*   forall m b, *)
(*     ~ Mem.valid_block m b -> *)
(*     Mem.size_block m b = 0. *)
(* Proof. *)
(*   intros m b NVB. *)
(*   unfold Mem.size_block, Alloc.get_size. *)
(*   rewrite Mem.bounds_mask_consistency. auto. *)
(*   apply Mem.msk_valid. auto. *)
(* Qed. *)

(* Lemma bounds_sup: *)
(*   forall m b, *)
(*     Mem.size_block m b <= Int.max_unsigned. *)
(* Proof. *)
(*   intros. *)
(*   generalize (Mem.wfm_alloc_ok m). *)
(*   unfold Alloc.alloc_blocks. *)
(*   destr. destr. intros _. *)
(*   unfold Alloc.alloc_mem_aux in Heqp. *)
(*   apply Alloc.alloc_size_mem_al in Heqp. *)
(*   generalize (Alloc.size_mem_al_pos (Alloc.mk_block_list_aux (Alloc.get_size (Mem.mem_blocksize m)) *)
(*                                                              (pred (Pos.to_nat (Mem.nextblock m)))) *)
(*                                     (two_power_nat MA) _ (two_power_nat_pos MA)). *)
(*   intro G. trim G. generalize (two_power_nat_pos MA); lia. subst. *)
(*   generalize (fun pf => alloc_size_mem_al_le _ (two_power_nat_pos MA) *)
(*                                           (Alloc.mk_block_list_aux (Alloc.get_size (Mem.mem_blocksize m)) *)
(*                                                                    (pred (Pos.to_nat (Mem.nextblock m)))) *)
(*                                           (two_power_nat MA) _ pf eq_refl *)
(*              ). *)
(*   intro J; trim J. *)
(*   generalize (two_power_nat_pos MA); lia. *)
(*   etransitivity. *)
(*   destruct (in_dec peq b (map fst (Alloc.mk_block_list_aux (Alloc.get_size (Mem.mem_blocksize m)) *)
(*                                                            (pred (Pos.to_nat (Mem.nextblock m)))))). *)
(*   rewrite Forall_forall in J. *)
(*   rewrite in_map_iff in i; dex. destruct i as (i1 & i2). *)
(*   des x. *)
(*   exploit Alloc.mbla_in. apply i2. intro; subst. *)
(*   apply J in i2. simpl in *. apply i2. *)
(*   apply not_in_mbla_0 in n. *)
(*   rewrite invalid_block_size.  generalize (two_power_nat_pos MA); lia. *)
(*   intro P. red in P. red in P. *)
(*   apply Pos2Nat.inj_lt in P. lia. *)
(*   etransitivity. apply Z.lt_eq_cases. left. eauto. *)
(*   apply szmem_mu. *)
(* Qed. *)


(* Lemma intermediate_value: *)
(*   forall a x z, *)
(*     a < z -> *)
(*     x >= 0 -> *)
(*     a + x > z -> *)
(*     0 <= z - a <= Int.max_unsigned -> *)
(*     exists y, a + Int.unsigned y = z /\ *)
(*          Int.unsigned y < x. *)
(* Proof. *)
(*   intros. *)
(*   exists (Int.repr (z-a)). rewrite Int.unsigned_repr.  lia. *)
(*   auto. *)
(* Qed. *)

(* Lemma next_addr_mu: *)
(*   forall m cm (COMP: Mem.compat_m m Mem.M32 cm), *)
(*     next_addr m cm <= Int.max_unsigned. *)
(* Proof. *)
(*   intros m cm COMP. *)
(*   unfold next_addr. *)
(*   assert (0 <= Int.max_unsigned) by (vm_compute; destr). *)
(*   revert H. *)
(*   generalize 0. *)
(*   generalize (list_blocks m). *)
(*   induction l; simpl; intros; eauto. *)
(*   apply IHl. *)
(*   rewrite Zmax_spec; destr. *)
(*   inv COMP. clear overlap alignment. *)
(*   destruct (zlt 0 (Mem.size_block m a)). *)
(*   - *)
(*     assert (NormaliseSpec.in_bound ((Mem.size_block m a - 1)) (Mem.bounds_of_block m a)). *)
(*     { *)
(*       red. rewrite Mem.bounds_lo_0. rewrite Mem.size_block_snd. lia. *)
(*     } *)
(*     generalize (addr_space a Int.zero (Mem.in_bound_zero _ _ _ H0)). *)
(*     generalize (addr_space a (Int.repr (Mem.size_block m a - 1))). *)
(*     intro J; trim J. *)
(*     rewrite Int.unsigned_repr.  auto. *)
(*     generalize (bounds_sup m a); lia. *)
(*     rewrite Int.add_zero. *)
(*     unfold Int.add in J. intro. *)
(*     rewrite (Int.unsigned_repr (_ - _)) in J. *)
(*     2: generalize (bounds_sup m a); lia. *)
(*     rewrite Int.unsigned_repr in J. unfold Mem.comp_size in J. *)
(*     lia. *)
(*     split. generalize (Int.unsigned_range (cm a)). lia. *)
(*     destruct (zle (Int.unsigned (cm a) + (Mem.size_block m a - 1)) Int.max_unsigned). auto. *)
(*     unfold Mem.comp_size in *. *)

(*     generalize (intermediate_value (Int.unsigned (cm a)) (Mem.size_block m a - 1) Int.max_unsigned). *)
(*     intro A. trim A. apply H1. *)
(*     trim A. generalize (bounds_sup m a); lia. *)
(*     trim A. apply g. *)
(*     trim A. *)
(*     generalize (Int.unsigned_range_2 (cm a)). lia. *)
(*     dex. *)
(*     specialize (addr_space a y). *)
(*     trim addr_space. *)
(*     red. *)
(*     rewrite Mem.size_block_snd. *)
(*     rewrite Mem.bounds_lo_0. generalize (Int.unsigned_range y); lia. *)
(*     unfold Int.add in addr_space. rewrite (proj1 A) in addr_space. *)
(*     rewrite Int.unsigned_repr in addr_space. *)
(*     2: lia. *)
(*     lia. *)
(*   - generalize (Mem.size_block_pos m a) (Int.unsigned_range_2 (cm a)); lia. *)
(* Qed.  *)


(* Fixpoint take {A: Type} (n: nat) (l: list A) := *)
(*   match n, l with *)
(*     O, _  => nil *)
(*   | S n, a::r => a::(take n r) *)
(*   | _, _ => nil *)
(*   end. *)

(* Lemma take_length: *)
(*   forall {A: Type} (n: nat) (l: list A), *)
(*     (length l >= n)%nat -> *)
(*     length (take n l) = n. *)
(* Proof. *)
(*   induction n; simpl; intros; eauto. *)
(*   des l. lia. rewrite IHn; lia. *)
(* Qed. *)

(* Lemma take_Forall: *)
(*   forall {A: Type} (P: A -> Prop) (n: nat) (l: list A), *)
(*     Forall P l -> *)
(*     Forall P (take n l). *)
(* Proof. *)
(*   induction n; simpl; intros; eauto. *)
(*   des l; constructor; inv H; auto. *)
(* Qed. *)


(* Lemma take_In: *)
(*   forall {A: Type} (n: nat) (l: list A) a, *)
(*     In a (take n l) -> In a l. *)
(* Proof. *)
(*   induction n; simpl; intros; eauto. easy. *)
(*   des l. des H. *)
(*   apply IHn in i. auto. *)
(* Qed. *)

(* Lemma take_lnr: *)
(*   forall {A: Type} (n: nat) (l: list A), *)
(*     list_norepet l -> *)
(*     list_norepet (take n l). *)
(* Proof. *)
(*   induction n; simpl; intros; eauto. constructor. *)
(*   des l; constructor; inv H; auto. *)
(*   intro I. *)
(*   apply take_In in I. destr. *)
(* Qed. *)

(* Lemma take_sublist: *)
(*   forall {A: Type} n (l: list A), *)
(*     sublist (take n l) l. *)
(* Proof. *)
(*   induction n; simpl; intros; eauto. *)
(*   induction l; simpl; intros; constructor; auto. *)
(*   des l; constructor; auto.       *)
(* Qed. *)

(* Lemma take_sca: *)
(*   forall n l, *)
(*     sorted_ca l -> *)
(*     sorted_ca (take n l). *)
(* Proof. *)
(*   intros. eapply sublist_sorted. apply (proj1 MA_bound). *)
(*   apply H. apply take_sublist. *)
(* Qed. *)

(* Lemma sublist_minus: *)
(*   forall {A} (e:A) L l'0 *)
(*     (SUB : sublist L l'0) l', *)
(*     L = (e :: l') -> *)
(*     sublist l' l'0. *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   destr. *)
(*   inv H. *)
(*   constructor. auto. subst. *)
(*   specialize (IHSUB _ eq_refl). constructor; auto. *)
(* Qed. *)

(* Lemma sublist_trans: *)
(*   forall {A: Type} (l1 l2 : list A), *)
(*     sublist l1 l2 -> *)
(*     forall l3, *)
(*       sublist l2 l3 -> *)
(*       sublist l1 l3. *)
(* Proof. *)
(*   induction 1; simpl; intros; eauto. *)
(*   - revert H0 IHsublist. clear. *)
(*     remember (e::l') as L. *)
(*     intro S; revert L e l' S HeqL. *)
(*     induction 1; simpl; intros; eauto. *)
(*     + destr. *)
(*     + inv HeqL. constructor. apply IHsublist. auto. *)
(*     + constructor. apply IHS. auto. auto. *)
(*   - apply IHsublist. eapply sublist_minus; eauto. *)
(* Qed. *)

(* Lemma sublist_refl: *)
(*   forall {A} (l: list A), sublist l l. *)
(* Proof. *)
(*   induction l; constructor; auto. *)
(* Qed. *)

(* Lemma cmem_free_addr_slack: *)
(*   forall N l1 l2, *)
(*     has_more_box 3 l1 l2 N -> *)
(*     is_memory 3 l1 -> *)
(*     is_memory 3 l2 -> *)
(*     (cmem_free_addr l1 <= next_box 3 (cmem_free_addr l2))%nat -> *)
(*     (cmem_free_addr l1 <= cmem_free_addr l2)%nat. *)
(* Proof. *)
(*   intros. *)
(*   eapply has_more_box_cmem_free_addr. apply (proj1 MA_bound). *)
(*   auto. auto. eauto. auto. *)
(* Qed. *)

(* Lemma realloc_blocks_ind: *)
(*   forall (P: mem -> int -> Prop) cm lb lh N m b *)
(*     (FB: Forall (fun b => Mem.size_block m b <= 8) lb) *)
(*     (Pinit: ~ In b lb -> P m (cm b)) *)
(*     (Pholes: forall h, In b lb -> In h lh -> Mem.size_block m b <= 8 -> P m (Int.repr (Z.of_nat (ac_addr h)))) *)
(*     (Pafter: *)
(*        0 <= N <= Int.max_unsigned - two_power_nat 3 * Z.of_nat (length lb - length lh) -> *)
(*        forall M, *)
(*         (M < length lb - length lh)%nat -> *)
(*         In b lb -> *)
(*         P m (Int.repr (align N (two_power_nat 3) + Z.of_nat M * two_power_nat 3))) *)
(*     (RNG: 0 <= N <= Int.max_unsigned - two_power_nat 3 * Z.of_nat (length lb - length lh)) *)
(*     (LNR: list_norepet lb), *)
(*     P m (realloc_blocks cm lb lh (Int.repr (align N (two_power_nat 3))) b). *)
(* Proof. *)
(*   unfold realloc_blocks; simpl; intros. *)
(*   destr. *)
(*   destruct (in_dec peq b l). *)
(*   { *)
(*     generalize (make_cm_lengths _ _ _ _ _ Heqp). *)
(*     revert Pafter RNG. *)
(*     generalize (length lb - length lh)%nat. *)
(*     generalize (make_cm_lnr _ LNR _ _ _ _ Heqp). *)
(*     generalize (make_cm_in _ _ _ _ _ Heqp). *)
(*     clear Heqp. revert i0 i N. *)
(*     clear - l. *)
(*     induction l; simpl; intros; eauto. *)
(*     - easy. *)
(*     - destruct (peq a b); subst. *)
(*       + clear i0.  *)
(*         rewrite add_blocks_after_other; auto. unfold update; destr. *)
(*         generalize (Pafter RNG O). intro A; trim A. lia. *)
(*         trim A. auto.  *)
(*         rewrite Z.add_0_r in A. apply A.  inv H0; auto. *)
(*       + trim IHl. destr. *)
(*         rewrite Int.unsigned_repr. *)
(*         replace (align N (two_power_nat 3) + two_power_nat 3) *)
(*         with (align (N + two_power_nat 3) (two_power_nat 3)). *)
(*         eapply IHl. *)
(*         5: reflexivity. *)
(*         intros; apply H; auto. *)
(*         inv H0; auto. *)
(*         intros. *)
(*         trim (Pafter RNG (S M)). lia. *)
(*         trim Pafter. auto. *)
(*         revert Pafter. *)
(*         apply prop_eq_impl. *)
(*         f_equal. *)
(*         replace (Z.of_nat (S M) * two_power_nat 3) with *)
(*         (two_power_nat 3 + Z.of_nat M * two_power_nat 3) by lia. *)
(*         rewrite <- (align_refl (two_power_nat 3)) at 4; auto. *)
(*         rewrite (Z.add_comm N (align _ _)).  *)
(*         rewrite <- Mem.align_distr. rewrite align_refl. lia. auto. auto. *)
(*         generalize (two_power_nat_pos 3); nia. *)
(*         rewrite <- (align_refl (two_power_nat 3)) at 1; auto. *)
(*         rewrite (Z.add_comm N (align _ _)).  *)
(*         rewrite <- Mem.align_distr. rewrite align_refl. lia. auto. auto. *)
(*         split. *)
(*         etransitivity. 2: apply align_le; auto. lia. *)
(*         transitivity (N + two_power_nat 3). *)
(*         unfold align. *)
(*         rewrite (Z_div_mod_eq (N + two_power_nat 3) (two_power_nat 3)) at 2. *)
(*         assert (forall p q r, p <= q -> r >= 0 -> p <= q + r) by (intros; lia). *)
(*         apply H1. *)
(*         rewrite Z.mul_comm. *)
(*         apply Zmult_le_compat. lia. *)
(*         apply Z.div_le_mono. generalize (two_power_nat_pos 3); lia. *)
(*         lia. *)
(*         generalize (two_power_nat_pos 3); lia. *)
(*         apply Z_div_pos. auto. generalize (two_power_nat_pos 3); lia. *)
(*         apply Z.le_ge. apply Z.mod_bound_pos. *)
(*         generalize (two_power_nat_pos 3); lia. *)
(*         generalize (two_power_nat_pos 3); lia. *)
(*         auto. *)
(*         rewrite Nat2Z.inj_succ in RNG.  *)
(*         generalize (two_power_nat_pos 3); nia. *)
(*   } *)
(*   rewrite add_blocks_after_other; auto. *)
(*   destruct (in_dec peq b lb). *)
(*   { *)
(*     revert Heqp n i0. *)
(*     clear Pinit Pafter RNG. *)
(*     revert lb cm lh l i LNR FB Pholes. clear. *)
(*     induction lb; simpl; intros; eauto. *)
(*     - easy. *)
(*     - des (peq a b). clear i0. *)
(*       + des lh. inv Heqp. destr. *)
(*         destr_in Heqp. inv Heqp. *)
(*         unfold update. rewrite peq_true. apply Pholes. auto. auto. *)
(*         inv FB; auto. *)
(*       + des i0. *)
(*         des lh. inv Heqp. destr. *)
(*         destr_in Heqp. inv Heqp. *)
(*         unfold update; rewrite peq_false; auto. *)
(*         eapply IHlb; eauto. inv LNR; auto. *)
(*         inv FB; auto. *)
(*   } *)
(*   erewrite make_cm_other'; eauto. *)
(* Qed. *)

(* Lemma align_pessimistic: *)
(*   forall x al, al > 0 -> x >= 0 -> *)
(*           align x al <= x + al. *)
(* Proof. *)
(*   intros; unfold align. *)
(*   rewrite (Z_div_mod_eq (x + al) al) at 2. *)
(*   assert (forall p q r, p <= q -> r >= 0 -> p <= q + r) by (intros; lia). *)
(*   apply H1. *)
(*   rewrite Z.mul_comm. *)
(*   apply Zmult_le_compat. lia. *)
(*   apply Z.div_le_mono. lia.  lia. lia. *)
(*   apply Z_div_pos. auto. lia.  *)
(*   apply Z.le_ge. apply Z.mod_bound_pos. lia. lia. lia. *)
(* Qed. *)

(* Lemma align_and: *)
(*   forall al i, *)
(*     Int.and (Int.repr (align i (two_power_nat al))) *)
(*             (Int.not (Int.repr (two_power_nat al - 1))) = *)
(*     (Int.repr (align i (two_power_nat al))). *)
(* Proof. *)
(*   intros. *)
(*   IntFacts.solve_int. *)
(*   rewrite Int.bits_not; auto. *)
(*   rewrite ! Int.testbit_repr; auto. *)
(*   rewrite two_power_nat_two_p. *)
(*   rewrite Int.Ztestbit_two_p_m1; auto; try lia. destr. *)
(*   2: apply andb_true_r. *)
(*   rewrite andb_false_r. symmetry. *)
(*   destruct (align_divides i (two_p (Z.of_nat al))) as [x EQ]. rewrite two_p_equiv. *)
(*   generalize (Z.pow_pos_nonneg 2 (Z.of_nat al)). lia. *)
(*   rewrite EQ. *)
(*   rewrite two_p_equiv. *)
(*   rewrite Z.mul_pow2_bits. 2: lia. *)
(*   apply Z.testbit_neg_r. lia. *)
(* Qed. *)

(* Lemma align_and': *)
(*   forall al al' (LE: (al' <= al)%nat) i, *)
(*     Int.and (Int.repr (align i (two_power_nat al))) *)
(*             (Int.not (Int.repr (two_power_nat al' - 1))) = *)
(*     (Int.repr (align i (two_power_nat al))). *)
(* Proof. *)
(*   intros. *)
(*   IntFacts.solve_int. *)
(*   rewrite Int.bits_not; auto. *)
(*   rewrite ! Int.testbit_repr; auto. *)
(*   rewrite ! two_power_nat_two_p. *)
(*   rewrite Int.Ztestbit_two_p_m1; auto; try lia. destr. *)
(*   2: apply andb_true_r. *)
(*   rewrite andb_false_r. symmetry. *)
(*   destruct (align_divides i (two_p (Z.of_nat al))) as [x EQ]. rewrite two_p_equiv. *)
(*   generalize (Z.pow_pos_nonneg 2 (Z.of_nat al)). lia. *)
(*   rewrite EQ. *)
(*   rewrite two_p_equiv. *)
(*   rewrite Z.mul_pow2_bits. 2: lia. *)
(*   apply Z.testbit_neg_r. lia. *)
(* Qed. *)

(* Lemma compat_addr_space: *)
(*   forall cm m (COMP: Mem.compat_m m Mem.M32 cm) *)
(*     b o (IB: Mem.in_bound_m o m b) *)
(*     (POS: 0 <= o) , *)
(*     0 < Int.unsigned (cm b) + o < Int.max_unsigned. *)
(* Proof. *)
(*   intros. *)
(*   inv COMP. *)
(*   generalize (intermediate_value (Int.unsigned (cm b)) (Mem.size_block m b - 1) Int.max_unsigned). *)
(*   intro A. trim A. generalize (addr_space b Int.zero). *)
(*   intro B; trim B. eapply Mem.in_bound_zero; eauto. rewrite Int.add_zero in B; auto. *)
(*   unfold Mem.comp_size in B. lia. *)
(*   trim A. red in IB. red in IB. rewrite Mem.size_block_snd in IB. *)
(*   rewrite Mem.bounds_lo_0 in IB. generalize (bounds_sup m b); lia. *)
(*   destruct (zle (Int.unsigned (cm b) + (Mem.size_block m b - 1)) Int.max_unsigned). *)
(*   generalize (addr_space b (Int.repr o)). *)
(*   erewrite in_bound_unsigned; eauto. *)
(*   intro B; trim B. apply IB. *)
(*   unfold Int.add in B. *)
(*   erewrite (in_bound_unsigned o) in B; eauto. *)
(*   rewrite Int.unsigned_repr in B. unfold Mem.comp_size in B; auto. *)
(*   split. generalize (Int.unsigned_range (cm b)); lia. *)
(*   etransitivity. 2: apply l. apply Z.add_le_mono_l. *)
(*   red in IB. red in IB. rewrite Mem.size_block_snd in IB. lia. *)
(*   trim A. apply g. *)
(*   trim A. *)
(*   generalize (Int.unsigned_range_2 (cm b)). lia. *)
(*   dex. *)
(*   specialize (addr_space b y). *)
(*   trim addr_space. *)
(*   red. *)
(*   rewrite Mem.size_block_snd. *)
(*   rewrite Mem.bounds_lo_0. generalize (Int.unsigned_range y); lia. *)
(*   unfold Int.add in addr_space. rewrite (proj1 A) in addr_space. *)
(*   rewrite Int.unsigned_repr in addr_space. *)
(*   2: vm_compute; destr.  *)
(*   unfold Mem.comp_size in addr_space; lia.   *)
(* Qed. *)


(* Lemma inj_number_blocks_forgotten: *)
(*   forall f m1 m2 sil *)
(*     (MI: sinj f m1 m2 sil nil), *)
(*     Mem.size_mem m2 + two_power_nat MA * (Z.of_nat (length sil)) = Mem.size_mem m1. *)
(* Proof. *)
(*   intros. *)
(*   unfold Mem.size_mem, size_mem_aux. *)
(*   generalize (part_inj_permut' _ _ _ _ MI); destr; intro A. *)
(*   generalize (partition_app_perm _ _ _ _ Heqp); eauto. intro B. *)
(*   trim A; auto. *)
(*   erewrite size_mem_al_permut'. 3: eauto. 3: eauto. *)
(*   2: apply Permutation_sym; apply A. *)
(*   erewrite (size_mem_al_permut _ _ _ (two_power_nat_pos MA) (Permutation_map snd B) (Mem.mk_block_list m1)). 2: eauto. 2: eauto. *)
(*   rewrite Mem.size_mem_app. *)
(*   generalize (Mem.size_mem_al_aligned l (two_power_nat MA)). intro C. *)
(*   trim C. *)
(*   rewrite Mem.align_small; auto. generalize (two_power_nat_pos MA); lia. *)
(*   rewrite C at 2. *)
(*   rewrite size_mem_al_plus. *)
(*   rewrite <- C. f_equal. *)
(*   generalize (in_partition_r _ _ _ _ Heqp). intro INR. *)

(*   assert (forall z, size_mem_al (two_power_nat MA) l0 (align z (two_power_nat MA)) = (align z (two_power_nat MA)) + two_power_nat MA * Z.of_nat (length (filter (fun x => 0 <? snd x) l0))). *)
(*   { *)
(*     generalize (fun x => (proj1 (INR x))). *)
(*     clear - MI. *)
(*     induction l0; simpl; intros; eauto. *)
(*     lia. *)
(*     des a. *)
(*     rewrite IHl0. *)
(*     rewrite Zmax_spec. *)
(*     generalize (Zlt_cases 0 z0). *)
(*     destr. *)
(*     destr; try lia. *)
(*     - rewrite <- ! Align.align_distr, ! Align.align_align; auto. *)
(*       intros. rewrite <- Z.add_assoc. *)
(*       f_equal. *)
(*       rewrite Mem.align_small; auto. lia. *)
(*       split; auto. *)
(*       trim (H (b,z0)). auto. *)
(*       des H. unfold is_injected in e. destr_in e. *)
(*       eapply sinj_fb in Heqo; eauto. *)
(*       unfold Mem.mk_block_list in i. *)
(*       eapply mbla_in in i. subst. des Heqo. *)
(*       etransitivity. apply a. change 8 with (two_power_nat 3). *)
(*       rewrite ! two_power_nat_two_p. *)
(*       apply two_p_monotone. generalize MA_bound; lia. *)
(*     - intros. f_equal. *)
(*       destr. *)
(*       rewrite <- ! Align.align_distr, ! Align.align_align; auto. *)
(*       rewrite Align.align_0; auto. lia. *)
(*       assert (z0 = 0) by lia. subst. *)
(*       rewrite <- ! Align.align_distr, ! Align.align_align; auto. *)
(*       rewrite Align.align_0; auto. lia. *)
(*     - intros; apply H; auto. *)
(*   } *)
(*   erewrite <- Align.align_0; auto. *)
(*   rewrite H. *)
(*   rewrite Align.align_0; auto. rewrite Z.add_0_l. *)
(*   f_equal. f_equal. *)
(*   rewrite <- (map_length fst (filter _ _)). *)
(*   eapply Permutation_length. *)
(*   apply NoDup_Permutation. *)
(*   apply list_norepet_NoDup; inv MI; auto. *)
(*   apply list_norepet_NoDup. *)
(*   apply lnr_map_filter. *)
(*   apply lnr_partition' in Heqp. destr. *)
(*   apply lnr_mbl. *)

(*   intros. *)
(*   rewrite in_map_iff. *)
(*   split; intros IN. *)
(*   exists (x, Mem.size_block m1 x). simpl; split; auto. *)
(*   rewrite filter_In. *)
(*   destruct (sinj_in _ _ _ _ _ MI _ IN) as [Fn [Vb SzB]]. *)
(*   destruct (sinj_fb _ _ _ _ _ MI _ Fn) as [SZ Msk]. *)
(*   split. *)
(*   rewrite in_partition_r. 2: eauto. split. *)
(*   unfold Mem.mk_block_list. apply mbla_below_in'. *)
(*   red in Vb. apply Pos2Nat.inj_lt in Vb. lia. *)
(*   unfold is_injected; simpl; rewrite Fn; auto. *)
(*   simpl. *)
(*   apply Zlt_is_lt_bool. lia. *)

(*   destruct IN as [[b z] [EQ IN]]. simpl in *; subst. *)
(*   rewrite filter_In in IN. des IN. *)
(*   rewrite in_partition_r in i. 2: eauto. des i. *)
(*   exploit mbla_in. apply i0.  intro; subst. *)
(*   unfold is_injected in e0. simpl in e0. destr_in e0. *)
(*   destruct (sinj_inject _ _ _ _ _ MI x). *)

(*   Lemma mbl_valid: *)
(*     forall m b z, *)
(*       In (b,z) (Mem.mk_block_list m) -> *)
(*       Mem.valid_block m b. *)
(*   Proof. *)
(*     intros. *)
(*     des (Mem.valid_block_dec m b). *)
(*     exploit mbla_not_above. *)
(*     2: rewrite in_map_iff; exists (b,z); split; eauto. 2: apply H. *)
(*     unfold Mem.valid_block in n. *)
(*     clear Heqs. apply not_plt_ple in n. *)
(*     simpl. *)
(*     apply Pos2Nat.inj_le in n. lia. *)
(*     easy. *)
(*   Qed. *)
(*   eapply mbl_valid. eauto. *)
(*   dex; destr. *)
(*   des H0. rewrite e1 in e. rewrite Z.ltb_lt in e. lia. auto. *)

(*   rewrite Forall_forall. intros x IN.  *)
(*   des x. unfold Mem.mk_block_list in IN. apply Alloc.mbla_in in IN. subst. *)
(*   apply Zle_ge. apply Mem.size_block_pos. *)

  
(*   rewrite Forall_forall. intros x IN.  *)
(*   des x. rewrite in_partition_l in IN. 2: eauto. des IN. *)
(*   unfold Mem.mk_block_list in i. apply Alloc.mbla_in in i. subst. *)
(*   apply Zle_ge. apply Mem.size_block_pos. *)
(* Qed. *)

(* Lemma perm_inj_filter_map: *)
(*   forall f m1 m2 sil *)
(*     (MI: sinj f m1 m2 sil nil), *)
(*     Permutation *)
(*       (align_list_blocks (Mem.mk_block_list m2)) *)
(*       (filter_map (fun x => *)
(*                      match f (fst x) with *)
(*                        Some b' => (Some (b',align (snd x) (two_power_nat 3))) *)
(*                      | None => None *)
(*                      end) (Mem.mk_block_list m1)). *)
(* Proof. *)
(*   intros. *)
(*   generalize (part_inj_permut _ _ _ _ MI). *)
(*   destr. *)
(*   intro A; trim A. *)
(*   eapply partition_app_perm; eauto. *)
(*   generalize (in_partition_l _ _ _ _ Heqp). intro EQ. *)
(*   apply A. *)
(* Qed. *)

(* Lemma Fspec_szmem: *)
(*   forall f m1 m2 sil *)
(*     (FB : sinj f m1 m2 sil nil) *)
(*     F *)
(*     (NUMFORGOTTEN : Mem.size_mem m2 + two_power_nat MA * Z.of_nat F = *)
(*                     Mem.size_mem m1) *)
(*     l l0 *)
(*     (PI : part_inj (Mem.mk_block_list m1) f = (l, l0)) *)
(*     (SZM1 : Mem.size_mem m1 = Alloc.size_mem_aux MA (l ++ l0)) *)
(*     (SZM2 : Mem.size_mem m2 = Alloc.size_mem_aux MA l), *)
(*     F = length (filter (fun x : block * Z => snd x >? 0) l0). *)
(* Proof. *)
(*   intros. *)
(*   apply zof_nat_eq. *)
(*   unfold Alloc.size_mem_aux in SZM1, SZM2. rewrite Mem.size_mem_app in SZM1. *)
(*   revert NUMFORGOTTEN. *)
(*   rewrite SZM1, SZM2. *)
(*   rewrite (Mem.size_mem_al_aligned l) at 2. *)
(*   2: rewrite align_refl; auto. *)
(*   rewrite size_mem_al_plus; auto. *)
(*   rewrite <- Mem.size_mem_al_aligned. *)
(*   2: rewrite align_refl; auto. *)
(*   intro. *)
(*   assert (Z.of_nat F * two_power_nat MA = Alloc.size_mem_al (two_power_nat MA) l0 0). *)
(*   lia. *)
(*   rewrite <- (align_0 _ (two_power_nat_pos MA)) in H. *)
(*   rewrite size_mem_al_mul in H; auto. *)
(*   rewrite align_0 in H; auto. *)
(*   generalize (two_power_nat_pos MA); nia. *)
(*   clear - FB PI. *)
(*   unfold part_inj in PI. *)
(*   rewrite Forall_forall. intros x IN. *)
(*   rewrite (in_partition_r) in IN. 2: eauto. *)
(*   unfold is_injected in IN. destr_in IN. des x. *)
(*   apply FB in Heqo. destruct IN. *)
(*   unfold Mem.mk_block_list in H. *)
(*   eapply Alloc.mbla_in in H. subst. etransitivity. apply Heqo.  *)
(*   change 8 with (two_p 3). *)
(*   rewrite two_power_nat_two_p. *)
(*   apply two_p_monotone. *)
(*   generalize MA_bound; lia. *)
(* Qed. *)

(* Lemma list_of_forgotten: *)
(*   forall f m1 l l0 *)
(*     (PI : part_inj (Mem.mk_block_list m1) f = (l, l0)) *)
(*     F *)
(*     (Fspec : F = length (filter (fun x : block * Z => snd x >? 0) l0)), *)
(*   exists lf, *)
(*     length lf = F /\ *)
(*     Forall (fun x => Mem.size_block m1 x > 0 /\ f x = None) lf /\ *)
(*     list_norepet lf /\ *)
(*     (forall b, f b = None -> Mem.size_block m1 b <> 0 -> In b lf). *)
(* Proof. *)
(*   intros; *)
(*   exists (filter (fun (x: block) => match f x with *)
(*                               None => true && zlt 0 (Mem.size_block m1 x)  *)
(*                             | _ => false *)
(*                             end) (map fst (Mem.mk_block_list m1))). *)
(*   repSplit. *)
(*   - subst. *)
(*     unfold part_inj in PI. *)
(*     generalize (partition_filter _ _ _ _ PI). intros [A B]. *)
(*     rewrite B. *)
(*     clear. *)
(*     cut (Forall (fun x => snd x = Mem.size_block m1 (fst x)) (Mem.mk_block_list m1)). *)
(*     generalize (Mem.mk_block_list m1). *)
(*     induction 1; simpl; intros; eauto. *)
(*     des x. unfold is_injected. simpl.  des (f b). *)
(*     des (zlt 0 (Mem.size_block m1 b)). *)
(*     destr. auto. *)
(*     rewrite Z.gtb_ltb in Heqb0. *)
(*     rewrite Z.ltb_nlt in Heqb0. destr. *)
(*     destr. *)
(*     rewrite Z.gtb_ltb in Heqb0. *)
(*     rewrite Z.ltb_lt in Heqb0. lia.  *)
(*     rewrite Forall_forall. intros x IN. *)
(*     unfold Mem.mk_block_list in IN. *)
(*     des x. eapply Alloc.mbla_in in IN; auto. *)
(*   - cut (Forall (fun x => snd x = Mem.size_block m1 (fst x)) (Mem.mk_block_list m1)). *)
(*     generalize (Mem.mk_block_list m1). *)
(*     induction 1; simpl; intros; eauto. *)
(*     des x. des (f b). *)
(*     des (zlt 0 (Mem.size_block m1 b)); constructor; auto. split. lia. auto. *)
(*     rewrite Forall_forall. intros x IN. *)
(*     unfold Mem.mk_block_list in IN. *)
(*     des x. eapply Alloc.mbla_in in IN; auto. *)
(*   - apply lnr_filter. apply lnr_mbl. *)
(*   - intros b FBN SZB. *)
(*     rewrite filter_In. rewrite FBN. *)
(*     split. *)
(*     2: generalize (Mem.size_block_pos m1 b); des (zlt 0 (Mem.size_block m1 b)); lia. *)
(*     rewrite in_map_iff. *)
(*     eexists; split. 2: eapply in_bound_in_list' with Int.zero. simpl; reflexivity. *)
(*     red. *)
(*     generalize (Mem.size_block_pos m1 b). *)
(*     rewrite Mem.size_block_snd. *)
(*     rewrite Mem.bounds_lo_0. change (Int.unsigned Int.zero) with 0. *)
(*     lia. *)
(* Qed. *)

(* Lemma align_slack: *)
(*   forall A B C D *)
(*     (LE: A * B <= A * C + D) *)
(*     (SMALL: 0 < D < A), *)
(*     A * B + D <= A * C + D. *)
(* Proof. *)
(*   intros. *)
(*   assert (A * (B - C) <= D) by lia. *)
(*   assert (B <= C) by nia. *)
(*   cut (A * B <= A * C). lia. *)
(*   cut (A * (B - C) <= 0). lia. *)
(*   assert (A * (B - C) < A) by lia. *)
(*   apply Z.mul_nonneg_nonpos. lia. lia.             *)
(* Qed. *)

(* Lemma szmem_next_addr_spec: *)
(*   forall m2 cm2, *)
(*     Mem.size_mem m2 <= next_addr m2 cm2 -> *)
(*     exists X Y, Mem.size_mem m2 + two_power_nat 3 * Z.of_nat X + Y = next_addr m2 cm2 /\ *)
(*            0 <= Y < two_power_nat 3. *)
(* Proof. *)
(*   intros. *)
(*   generalize (Z_div_mod_eq (next_addr m2 cm2 - Mem.size_mem m2) _ (two_power_nat_pos 3)). *)
(*   intros. *)
(*   exists (Z.to_nat ((next_addr m2 cm2 - Mem.size_mem m2) / two_power_nat 3)). *)
(*   exists ((next_addr m2 cm2 - Mem.size_mem m2) mod two_power_nat 3). *)
(*   rewrite Z2Nat.id. split. *)
(*   lia. *)
(*   apply Z_mod_lt. *)
(*   auto. *)
(*   apply Z.div_pos. lia. generalize (two_power_nat_pos 3); lia. *)
(* Qed. *)

(* Lemma diff_sup_X: *)
(*   forall m2 cm2 X Y *)
(*     (C : Mem.size_mem m2 + two_power_nat 3 * Z.of_nat X + Y = next_addr m2 cm2) *)
(*     (D : 0 <= Y < two_power_nat 3), *)
(*     (Z.to_nat (align (next_addr m2 cm2) (two_power_nat 3)) - *)
(*     Z.to_nat (Mem.size_mem m2 - two_power_nat MA) *)
(*     >= X * NPeano.pow 2 3 + NPeano.pow 2 MA)%nat. *)
(* Proof. *)
(*   intros. *)
(*   rewrite <- C. *)
(*   match goal with *)
(*     |- (?a >= ?b)%nat => assert (b <= a)%nat;[|lia] *)
(*   end. *)
(*   rewrite Nat2Z.inj_le. *)
(*   rewrite Z2Nat.inj_sub. *)
(*   transitivity ((two_power_nat 3 * Z.of_nat X)  +  (two_power_nat MA)). *)
(*   rewrite Nat2Z.inj_add. *)
(*   rewrite ! pow_tpnat. *)
(*   rewrite Nat2Z.inj_mul. lia. *)
(*   rewrite minus_minus. *)
(*   rewrite Nat2Z.inj_add. rewrite Z2Nat.id. *)
(*   rewrite <- Z2Nat.inj_sub. *)
(*   rewrite Z2Nat.id. *)
(*   cut (two_power_nat 3 * Z.of_nat X <= align (Mem.size_mem m2 + two_power_nat 3 * Z.of_nat X + Y) (two_power_nat 3) - Mem.size_mem m2). lia. *)
(*   etransitivity. *)
(*   2: apply Z.sub_le_mono_r. *)
(*   2: apply align_le. lia. auto. *)
(*   apply Zle_minus_le_0. *)
(*   etransitivity. 2: apply align_le. *)
(*   generalize (two_power_nat_pos 3); nia. auto. *)
(*   generalize (size_mem_pos m2); lia. *)
(*   generalize (two_power_nat_pos MA); lia. *)
(*   apply Z2Nat.inj_le. generalize (two_power_nat_pos MA); lia. *)
(*   generalize (size_mem_pos m2); lia. *)
(*   apply szmem_bndinf. *)
(*   apply Z2Nat.inj_le. *)
(*   generalize (size_mem_pos m2); lia. *)
(*   etransitivity. 2: apply align_le. *)
(*   generalize (two_power_nat_pos 3) (size_mem_pos m2); nia. auto. *)
(*   etransitivity. 2: apply align_le. *)
(*   generalize (two_power_nat_pos 3) (size_mem_pos m2); nia. auto.  *)
(*   generalize (two_power_nat_pos MA); lia. *)
(* Qed. *)

(* Lemma div_sup_X: *)
(*   forall X , *)
(*     (X + NPeano.pow 2 (MA - 3) <= *)
(*      NPeano.div (X * NPeano.pow 2 3 + NPeano.pow 2 MA) (sz_box 3))%nat. *)
(* Proof. *)
(*   intros. *)
(*   transitivity (NPeano.div (sz_box 3 * (X + NPeano.pow 2 (MA - 3))) (sz_box 3)). *)
(*   rewrite mult_comm. *)
(*   rewrite NPeano.Nat.div_mul. lia. *)
(*   eapply sz_box_not_zero; eauto. *)
(*   unfold sz_box. *)
(*   rewrite mult_plus_distr_l. *)
(*   rewrite <- NPeano.Nat.pow_add_r. *)
(*   replace (3 + (MA - 3))%nat with MA. *)
(*   rewrite mult_comm. lia.   *)
(*   generalize MA_bound; lia. *)
(* Qed. *)

(* Lemma add_pos_pos: *)
(*   forall a b, 0 <= a -> 0 <= b -> 0 <= a + b. *)
(* Proof. intros; lia. Qed. *)

(* Lemma in_bound_sinj: *)
(*   forall f m1 m2 sil *)
(*     (SI: sinj f m1 m2 sil nil) *)
(*     b o *)
(*     (IB: Mem.in_bound_m o m1 b) *)
(*     b' (FB: f b = Some b'), *)
(*     Mem.in_bound_m o m2 b'. *)
(* Proof. *)
(*   intros. *)
(*   red in IB; red. *)
(*   red in IB; red. *)
(*   rewrite Mem.bounds_lo_0 in *. *)
(*   rewrite Mem.size_block_snd in *. *)
(*   generalize (sinj_bounds' _ _ _ _ _ SI _ _ FB). lia. *)
(* Qed. *)

(* Lemma nooverlap_hole_cm1: *)
(*   forall *)
(*     f m1 m2 cm2 *)
(*     (COMP: Mem.compat_m m2 Mem.M32 cm2) *)
(*     sil *)
(*     (MI: sinj f m1 m2 sil nil) *)
(*     lf *)
(*     (SPEClf: forall b, f b = None -> Mem.size_block m1 b <> 0 -> In b lf) *)
(*     cm1 old_cm1 (IMA: is_memory 3 old_cm1) *)
(*     (SL: sublist cm1 old_cm1) N *)
(*     (HMB : has_more_box 3 cm1 (acm_of_mem m2 cm2) N) *)
(*     b b' o o' (n : b <> b') *)
(*     (IB : NormaliseSpec.in_bound (Int.unsigned o) *)
(*                                  (Mem.bounds_of_block m1 b)) *)
(*     (IB' : NormaliseSpec.in_bound (Int.unsigned o') *)
(*                                   (Mem.bounds_of_block m1 b')) *)
(*     (IN1 : ~ In b' lf) *)
(*     h *)
(*     (INF: In b lf) *)
(*     l1 *)
(*     (INH: In h l1) *)
(*     (F' : Forall (fun x : ACblock => is_box 3 x /\ ac_addr x <> 0%nat) l1) *)
(*     (in' : forall x : ACblock, In x l1 -> In x cm1) *)
(*     (in2' : forall x : ACblock, In x l1 -> ~ In x (acm_of_mem m2 cm2)) *)
(*     (SZB: Mem.size_block m1 b <= 8) *)
(*     (BndL1: Forall *)
(*               (fun x : ACblock => *)
(*                  Z.of_nat (ac_addr x) + two_power_nat 3 <= next_addr m2 cm2) *)
(*               l1), *)
(*     let cm1' := fun b : block => *)
(*                   match f b with *)
(*                   | Some b' => cm2 b' *)
(*                   | None => Int.zero *)
(*                   end in *)
(*     Int.unsigned (Int.add (Int.repr (Z.of_nat (ac_addr h))) o) <> *)
(*     Int.unsigned (Int.add (cm1' b') o'). *)
(* Proof. *)
(*   intros. *)
(*   assert (FB': exists b'', f b' = Some b''). *)
(*   des (f b'). eexists; f_equal.  *)
(*   exfalso; apply IN1; apply SPEClf; auto; eapply in_bound_size_not_null; eauto. *)
(*   dex. unfold cm1'; rewrite FB'. *)
(*   generalize (in' _ INH) (in2' _ INH). intros INCM1 NINCM2. *)
(*   cut (In ({| ac_addr := Z.to_nat (Int.unsigned (cm2 b'')); *)
(*               ac_size := Z.to_nat (Mem.size_block m2 b'') |}) *)
(*           (acm_of_mem m2 cm2)). *)
(*   intro INCM2. *)
(*   exploit is_memory_sublist. *)
(*   apply (proj1 MA_bound). apply IMA. apply SL. *)

(*   match goal with *)
(*     H: ~ In ?a ?l, H1: In ?b ?l |- _ => *)
(*     assert (a <> b) by destr *)
(*   end. *)
(*   eapply has_more_box_in in INCM2; eauto. *)
(*   intros IM'. *)
(*   destruct (in_split _ _ INCM2). *)
(*   dex. subst. *)
(*   assert (INOR: In h x \/ In h l2). *)
(*   apply in_app_or in INCM1. destr. *)
(*   des INOR. *)
(*   destruct (in_split _ _ i). dex; subst. *)
(*   exploit sorted_in. apply (proj1 MA_bound). *)
(*   eapply is_sorted; eauto. rewrite  app_ass in IM'. simpl in IM'. eauto. *)
(*   simpl. intros INEQ. *)
(*   match goal with *)
(*     |- ?a <> ?b => cut (a < b); [lia|] *)
(*   end. *)
(*   generalize (NormaliseSpec.addr_space _ _ _ _ COMP *)
(*                                        b'' o'). *)
(*   intro X; trim X. *)
(*   eapply in_bound_sinj; eauto. *)
(*   unfold Int.add in X. *)
(*   unfold Int.add. *)
(*   rewrite (Int.unsigned_repr (Z.of_nat _)). *)
(*   rewrite Int.unsigned_repr. *)
(*   rewrite Int.unsigned_repr. *)
(*   eapply Z.lt_le_trans. *)
(*   apply Z.add_lt_mono_l. apply IB. *)
(*   apply Nat2Z.inj_le in INEQ. *)
(*   rewrite Nat2Z.inj_add in INEQ. *)
(*   etransitivity. *)
(*   rewrite Mem.size_block_snd. apply Z.add_le_mono_l. apply SZB. *)
(*   rewrite Forall_forall in F'; specialize (F' _ INH). *)
(*   destruct F' as [F'1 F'2]. *)
(*   inv F'1. rewrite is_box_size in INEQ . *)
(*   change (Z.of_nat (sz_box 3)) with 8 in INEQ. *)
(*   etransitivity. apply INEQ. rewrite Z2Nat.id. *)
(*   generalize (Int.unsigned_range o'); lia. *)
(*   apply Int.unsigned_range. *)
(*   exploit in_bound_sinj; eauto. intro IBM. *)
(*   eapply compat_addr_space in IBM; eauto. lia. *)
(*   apply Int.unsigned_range. *)
(*   split. *)
(*   generalize (Int.unsigned_range o); lia. *)
(*   apply Nat2Z.inj_le in INEQ. *)
(*   rewrite Nat2Z.inj_add in INEQ. rewrite Z2Nat.id in INEQ. *)
(*   etransitivity. *)
(*   apply Z.add_le_mono_l. *)
(*   2: etransitivity. 2: apply INEQ. *)
(*   2: apply Int.unsigned_range_2. *)
(*   revert INH F' SZB IB. clear; intros. *)
(*   rewrite Forall_forall in F'; specialize (F' _ INH). destruct (proj1 F'). *)
(*   rewrite is_box_size. change (Z.of_nat (sz_box 3)) with 8. *)
(*   red in IB. rewrite Mem.size_block_snd in IB. lia. *)
(*   apply Int.unsigned_range. *)
(*   split. lia. *)
(*   apply Nat2Z.inj_le in INEQ. *)
(*   rewrite Nat2Z.inj_add in INEQ. rewrite Z2Nat.id in INEQ. *)
(*   transitivity (Int.unsigned (cm2 b'') - Z.of_nat (ac_size h)). lia. *)
(*   generalize (Int.unsigned_range_2 (cm2 b'')); lia. *)
(*   apply Int.unsigned_range. *)

(*   destruct (in_split _ _ i). dex; subst. *)
(*   exploit sorted_in. apply (proj1 MA_bound). *)
(*   eapply is_sorted;  eauto. simpl.  *)
(*   simpl. intros INEQ. *)
(*   match goal with *)
(*     |- ?a <> ?b => cut (b < a); [lia|] *)
(*   end. *)
(*   generalize (NormaliseSpec.addr_space _ _ _ _ COMP *)
(*                                        b'' o'). *)
(*   intro X; trim X. *)
(*   eapply in_bound_sinj; eauto. *)
(*   unfold Int.add. *)
(*   rewrite (Int.unsigned_repr (Z.of_nat _)). *)
(*   rewrite Int.unsigned_repr. *)
(*   rewrite Int.unsigned_repr. *)
(*   eapply Z.lt_le_trans. *)
(*   apply Z.add_lt_mono_l. apply IB'. *)
(*   apply Nat2Z.inj_le in INEQ. *)
(*   rewrite Nat2Z.inj_add in INEQ. *)
(*   rewrite !Z2Nat.id in INEQ. *)
(*   etransitivity. *)
(*   rewrite Mem.size_block_snd. etransitivity. 2: apply INEQ. *)
(*   generalize (sinj_bounds' _ _ _ _ _ MI _ _ FB'). lia. *)
(*   generalize (Int.unsigned_range o); lia. *)
(*   apply Mem.size_block_pos. *)
(*   apply Int.unsigned_range. *)
(*   split. *)
(*   generalize (Int.unsigned_range o); lia. *)
(*   transitivity (next_addr m2 cm2). *)
(*   rewrite Forall_forall in BndL1; specialize (BndL1 _ INH). *)
(*   etransitivity. 2: apply BndL1. *)
(*   apply Z.add_le_mono_l. *)
(*   rewrite Forall_forall in F'; specialize (F' _ INH); destruct (proj1 F') as [XX YY]; inv YY. *)
(*   clear - SZB IB H1. *)
(*   change (two_power_nat 3) with 8. *)
(*   red in IB; rewrite Mem.size_block_snd in IB. lia. *)
(*   apply next_addr_mu; auto. *)
(*   exploit in_bound_sinj; eauto. intro IBM. *)
(*   eapply compat_addr_space in IBM; eauto. lia. *)
(*   apply Int.unsigned_range. *)
(*   split. lia. *)
(*   transitivity (next_addr m2 cm2). *)
(*   rewrite Forall_forall in BndL1; specialize (BndL1 _ INH). *)
(*   clear - BndL1. generalize (two_power_nat_pos 3); lia. *)
(*   apply next_addr_mu; auto. *)
  
(*   unfold acm_of_mem. *)
(*   rewrite filter_In. *)
(*   rewrite Alloc.perm_in. *)
(*   2: apply Permutation_sym; apply scmem_permut. *)
(*   simpl. *)
(*   split. *)
(*   rewrite in_map_iff. *)
(*   exists (b'',Mem.size_block m2 b''). simpl. split; auto. *)
(*   apply Alloc.mbla_below_in'. *)
(*   destruct (sinj_valid _ _ _ _ _ MI _ _ FB') as [Vb [VB Nin]]. *)
(*   red in VB. *)
(*   apply Pos2Nat.inj_lt in VB. lia. *)
(*   rewrite NPeano.ltb_lt. *)
(*   change O with (Z.to_nat 0). apply Z2Nat.inj_lt. *)
(*   lia. *)
(*   apply Mem.size_block_pos. *)
(*   exploit in_bound_sinj; eauto. intro IBM. *)
(*   red in IBM. red in IBM. rewrite Mem.size_block_snd in IBM. *)
(*   rewrite Mem.bounds_lo_0 in IBM. lia. *)
(* Qed. *)

(* Lemma nooverlap_after_cm1: *)
(*   forall *)
(*     f m1 m2 cm2 sil *)
(*     (COMP: Mem.compat_m m2 Mem.M32 cm2) *)
(*     (MI: sinj f m1 m2 sil nil) *)
(*     lf *)
(*     (SPEClf: forall b, f b = None -> Mem.size_block m1 b <> 0 -> In b lf) *)
(*     cm1 old_cm1 (IMA: is_memory 3 old_cm1) *)
(*     (SL: sublist cm1 old_cm1) N *)
(*     (HMB : has_more_box 3 cm1 (acm_of_mem m2 cm2) N) *)
(*     b b' o o' (n : b <> b') *)
(*     (IB : NormaliseSpec.in_bound (Int.unsigned o) *)
(*                                  (Mem.bounds_of_block m1 b)) *)
(*     (IB' : NormaliseSpec.in_bound (Int.unsigned o') *)
(*                                   (Mem.bounds_of_block m1 b')) *)
(*     (IN1 : ~ In b' lf) *)
(*     (INF: In b lf) *)
(*     l1 *)
(*     (F' : Forall (fun x : ACblock => is_box 3 x /\ ac_addr x <> 0%nat) l1) *)
(*     (SZNINJ: Forall (fun x : block => Mem.size_block m1 x > 0 /\ f x = None) *)
(*                     lf), *)
(*     let cm1' := fun b : block => *)
(*                   match f b with *)
(*                   | Some b' => cm2 b' *)
(*                   | None => Int.zero *)
(*                   end in *)
(*     0 <= next_addr m2 cm2 <= *)
(*     Int.max_unsigned - two_power_nat 3 * Z.of_nat (length lf - length l1) -> *)
(*     forall M : nat, *)
(*       (M < length lf - length l1)%nat -> *)
(*       In b lf -> *)
(*       Int.unsigned *)
(*         (Int.add *)
(*            (Int.repr *)
(*               (align (next_addr m2 cm2) (two_power_nat 3) + *)
(*                Z.of_nat M * two_power_nat 3)) o) <> *)
(*       Int.unsigned (Int.add (cm1' b') o'). *)
(* Proof. *)
(*   intros. *)
(*   match goal with *)
(*     |- ?a <> ?b => cut (b < a); [lia|] *)
(*   end. *)
(*   assert (FB': exists b'', f b' = Some b''). *)
(*   des (f b'). eexists; f_equal.  *)
(*   exfalso; apply IN1; apply SPEClf; auto; eapply in_bound_size_not_null; eauto. *)
(*   dex. unfold cm1'; rewrite FB'. *)
(*   unfold Int.add at 1. *)
(*   rewrite Int.unsigned_repr. *)
(*   2: exploit compat_addr_space. 2: apply COMP. *)
(*   2: eapply in_bound_sinj; eauto.  *)
(*   2: generalize (Int.unsigned_range o'); lia. 2: lia. *)
(*   exploit in_bound_sinj; eauto. intro IBM. *)
(*   eapply Z.lt_le_trans. *)
(*   apply Z.add_lt_mono_l. apply IBM. rewrite Mem.size_block_snd. *)
(*   etransitivity. *)
(*   (* rewrite <- Mem.size_block_snd. *) *)
(*   (* erewrite SSI; eauto. *) *)
(*   (* rewrite Mem.size_block_snd. *) *)
(*   eapply next_addr_spec. *)
(*   eapply in_bound_in_list. *)
(*   eapply in_bound_sinj; eauto.  *)
(*   unfold Int.add. *)
(*   cut (0 <= *)
(*        align (next_addr m2 cm2) (two_power_nat 3) + Z.of_nat M * two_power_nat 3 <= *)
(*        Int.max_unsigned). *)
(*   intro HYP. *)
(*   rewrite (Int.unsigned_repr (_ + _)). *)
(*   2: rewrite Int.unsigned_repr. 3: lia.  *)
(*   rewrite Int.unsigned_repr by auto. *)
(*   etransitivity. *)
(*   2: apply Z.add_le_mono_r. *)
(*   2: apply Z.add_le_mono_r. *)
(*   2: apply align_le; auto. *)
(*   generalize (two_power_nat_pos 3) (Int.unsigned_range o); nia. *)
(*   split. *)
(*   apply add_pos_pos. etransitivity. *)
(*   2: apply add_pos_pos. lia. etransitivity. 2: apply align_le; auto. apply H.  *)
(*   generalize (two_power_nat_pos 3); nia. *)
(*   apply Int.unsigned_range. *)
(*   destruct (align_divides (next_addr m2 cm2) _ (two_power_nat_pos 3)) *)
(*     as [x EQ]. *)
(*   rewrite EQ. *)
(*   transitivity (two_power_nat 3 * (x + Z.of_nat M) + Int.unsigned o). lia.           *)
(*   rewrite (Z_div_mod_eq  Int.max_unsigned _ (two_power_nat_pos 3)). *)
(*   change (Int.max_unsigned mod two_power_nat 3) with 7. *)
(*   eapply Z.le_trans. *)
(*   apply Zplus_le_compat_l. instantiate (1:=7). *)
(*   red in IB. rewrite Mem.size_block_snd in IB. *)
(*   rewrite Forall_forall in SZNINJ. *)
(*   specialize (SZNINJ _ H1). *)
(*   change (two_power_nat 3) with 8. *)
(*   generalize (sinj_fb _ _ _ _ _ MI _ (proj2 SZNINJ)). lia. *)
(*   apply align_slack. *)
(*   rewrite (Z_div_mod_eq  Int.max_unsigned _ (two_power_nat_pos 3)) in HYP. *)
(*   change (Int.max_unsigned mod two_power_nat 3) with 7 in HYP. *)
(*   rewrite EQ in HYP. lia. *)
(*   change (two_power_nat 3) with 8. lia. *)
(*   split. *)
(*   apply add_pos_pos. *)
(*   etransitivity. 2: apply align_le; auto. apply H. *)
(*   generalize (two_power_nat_pos 3); nia. *)
(*   etransitivity. *)
(*   apply Zplus_le_compat_r. *)
(*   apply align_pessimistic. auto. lia. *)
(*   apply Nat2Z.inj_lt in H0. *)
(*   cut (next_addr m2 cm2 <= Int.max_unsigned - two_power_nat 3 * (1 + Z.of_nat M)). lia. *)
(*   etransitivity. apply H. *)
(*   apply Z.sub_le_mono_l. *)
(*   apply Zmult_le_compat. lia. lia. *)
(*   generalize (two_power_nat_pos 3); lia. lia. *)
(* Qed. *)


(* Fixpoint pos {A: Type} (eq: forall (a b: A), {a=b}+{a<>b}) b (l: list A) : nat := *)
(*   match l with *)
(*     nil => O *)
(*   | a::r => if eq a b then O else S (pos eq b r) *)
(*   end. *)

(* Lemma pos_in: *)
(*   forall {A: Type} (eq: forall (a b: A), {a=b}+{a<>b}) b (l: list A), *)
(*     In b l -> *)
(*     nth_error l (pos eq b l) = Some b. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   - easy. *)
(*   - destr. unfold value. *)
(*     f_equal; auto. *)
(* Qed. *)

(* Lemma pos_length {A: Type} (eq: forall (a b: A), {a=b}+{a<>b}) b l: *)
(*   In b l -> *)
(*   (pos eq b l < length l)%nat. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto; destr. lia. des H. trim IHl; auto. lia. *)
(* Qed. *)

(* Lemma add_blocks_after_in: *)
(*   forall l i N b, *)
(*     In b l -> *)
(*     list_norepet l -> *)
(*     Z.of_nat (length l) * two_power_nat 3 <= Int.max_unsigned -> *)
(*     add_blocks_after i l N b = Int.add N (Int.repr (Z.of_nat (pos peq b l) *  two_power_nat 3)). *)
(* Proof. *)
(*   Opaque Z.of_nat. *)
(*   induction l; simpl; intros; eauto. *)
(*   - easy. *)
(*   - des (peq a b). clear H.  *)
(*     + inv H0. rewrite add_blocks_after_other; auto. unfold update; rewrite peq_true. *)
(*       rewrite Int.add_zero; auto. *)
(*     + des H. inv H0. rewrite IHl; auto. simpl. *)
(*       rewrite Values_symbolic.Val.int_add_repr. *)
(*       unfold Int.add. f_equal. *)
(*       rewrite <- Z.add_assoc. f_equal. *)
(*       rewrite Int.unsigned_repr. *)
(*       rewrite Nat2Z.inj_succ. nia. *)
(*       split. generalize (two_power_nat_pos 3); nia. *)
(*       etransitivity. *)
(*       eapply Zmult_le_compat_r. apply Nat2Z.inj_le. *)
(*       rewrite <- NPeano.Nat.succ_le_mono. apply lt_le_weak. apply pos_length. auto. *)
(*       generalize (two_power_nat_pos 3); lia. auto. *)
(*       etransitivity. *)
(*       eapply Zmult_le_compat_r. apply Nat2Z.inj_le. *)
(*       3: apply H1. lia. *)
(*       generalize (two_power_nat_pos 3); lia.  *)
(* Qed. *)

(* Transparent Z.of_nat. *)

(* Lemma pos_diff: *)
(*   forall {A: Type} (eq: forall (a b: A), {a=b}+{a<>b}) b b' l *)
(*     (i1: In b l) *)
(*     (i2: In b' l) *)
(*     (n: b <> b'), *)
(*     pos eq b l <> pos eq b' l. *)
(* Proof. *)
(*   induction l; simpl; intros; eauto. *)
(*   repeat destr. *)
(* Qed. *)

(* Lemma neq_add: *)
(*   forall a b c, *)
(*     b <> c -> *)
(*     a + b <> a + c. *)
(* Proof. *)
(*   intros a b c n e. lia. *)
(* Qed. *)

(* Lemma make_cm_in': *)
(*   forall lb lh cm cm' lb' *)
(*     (MC: make_cm cm lb lh = (cm',lb')) *)
(*     b (i: In b lb) (n: ~ In b lb'), *)
(*   exists h, *)
(*     cm' b = Int.repr (Z.of_nat (ac_addr h)) /\ *)
(*     In h lh. *)
(* Proof. *)
(*   induction lb; simpl; intros; eauto. easy. *)
(*   des (peq a b). *)
(*   + clear i. *)
(*     destr_in MC. inv MC. destr. *)
(*     destr_in MC. inv MC. *)
(*     unfold update; rewrite peq_true. eexists; split; eauto. *)
(*   + des i. *)
(*     destr_in MC. inv MC. destr. *)
(*     destr_in MC. inv MC. *)
(*     unfold update; rewrite peq_false; auto. *)
(*     exploit IHlb; eauto. *)
(*     intros [h [EQ IN]]; *)
(*       exists h; split; auto. *)
(* Qed. *)

(* Lemma sup_neq: *)
(*   forall a b, a > b -> a <> b. *)
(* Proof. *)
(*   intros; lia. *)
(* Qed. *)

(* Lemma nooverlap_add_blocks_after: *)
(*   forall f m1 m2 cm2 sil *)
(*     (COMP: Mem.compat_m m2 Mem.M32 cm2) *)
(*     (MI: sinj f m1 m2 sil nil) *)
(*     lf *)
(*     (SPEClf: forall b, f b = None -> Mem.size_block m1 b <> 0 -> In b lf) *)
(*     cm1 old_cm1 (IMA: is_memory 3 old_cm1) *)
(*     (SL: sublist cm1 old_cm1) N *)
(*     (HMB : has_more_box 3 cm1 (acm_of_mem m2 cm2) N) *)
(*     b b' o o' (n : b <> b') *)
(*     (IB : NormaliseSpec.in_bound (Int.unsigned o) *)
(*                                  (Mem.bounds_of_block m1 b)) *)
(*     (IB' : NormaliseSpec.in_bound (Int.unsigned o') *)
(*                                   (Mem.bounds_of_block m1 b')) *)
(*     l1 (F' : Forall (fun x : ACblock => is_box 3 x /\ ac_addr x <> 0%nat) l1) *)
(*     (SZNINJ: Forall (fun x : block => Mem.size_block m1 x > 0 /\ f x = None) lf) *)
(*     (LNRf: list_norepet lf), *)
(*     let cm1' := fun b : block => *)
(*                   match f b with *)
(*                   | Some b' => cm2 b' *)
(*                   | None => Int.zero *)
(*                   end in *)
(*     forall i l (MC: make_cm cm1' lf l1 = (i,l)) *)
(*       (H : forall (b0 : block) (z : Z), *)
(*           In b0 l -> *)
(*           0 <= z < two_power_nat 3 -> *)
(*           0 <=  *)
(*           align (next_addr m2 cm2) (two_power_nat 3) + *)
(*           Z.of_nat (pos peq b0 l) * two_power_nat 3 + z <= Int.max_unsigned) *)
(*       (H0 : forall (b0 : block) (o0 : int), *)
(*           In b0 l -> *)
(*           NormaliseSpec.in_bound (Int.unsigned o0) *)
(*                                  (Mem.bounds_of_block m1 b0) -> *)
(*           0 <= Int.unsigned o0 < two_power_nat 3) *)
(*       (next_addr_rng : 0 <= next_addr m2 cm2 <= *)
(*                        Int.max_unsigned - *)
(*                        two_power_nat 3 * Z.of_nat (length lf - length l1)) *)
(*       (BndL1 : Forall *)
(*                  (fun x : ACblock => *)
(*                     Z.of_nat (ac_addr x) + two_power_nat 3 <= next_addr m2 cm2) *)
(*                  l1) *)
(*       (i0: In b l) *)
(*       (n0: ~ In b' l), *)
(*       Int.unsigned *)
(*         (Int.add *)
(*            (add_blocks_after i l *)
(*                              (Int.repr (align (next_addr m2 cm2) (two_power_nat 3))) b) o) <> *)
(*       Int.unsigned *)
(*         (Int.add *)
(*            (add_blocks_after i l *)
(*                              (Int.repr (align (next_addr m2 cm2) (two_power_nat 3))) b') o'). *)
(* Proof. *)
(*   intros. *)
(*   exploit make_cm_lnr. 2: apply MC. eauto. intro LNRL. *)
(*   assert (Lsmall: Z.of_nat (length l) * two_power_nat 3 <= Int.max_unsigned). *)
(*   { *)
(*     erewrite make_cm_lengths. 2: eauto. lia. *)
(*   } *)
(*   rewrite (add_blocks_after_in _ _ _ _ i0); auto. *)
(*   rewrite Values_symbolic.Val.int_add_repr. *)
(*   rewrite add_blocks_after_other; auto. *)
(*   destruct (in_dec peq b' lf). *)
(*   unfold Int.add. *)
(*   rewrite (Int.unsigned_repr (align _ _ + _)). *)
(*   Focus 2. *)
(*   trim (H _ 0 i0). vm_compute; destr. rewrite Z.add_0_r in H; auto. *)
(*   rewrite Int.unsigned_repr. *)
(*   Focus 2. *)
(*   apply H. auto. *)
(*   red in IB. rewrite Mem.bounds_lo_0 in IB. rewrite Mem.size_block_snd in IB. *)
(*   rewrite Forall_forall in SZNINJ. *)
(*   specialize (SZNINJ _ (make_cm_in _ _ _ _ _ MC _ i0)). *)
(*   change (two_power_nat 3) with 8. *)
(*   generalize (sinj_fb _ _ _ _ _ MI _ (proj2 SZNINJ)). lia. *)


(*   destruct (make_cm_in' _ _ _ _ _ MC _ i1 n0) as [h [EQ IN]]; rewrite EQ. *)

(*   apply sup_neq. *)
(*   apply Z.lt_gt. *)
(*   eapply Z.lt_le_trans with (m := next_addr m2 cm2). *)
(*   rewrite Forall_forall in BndL1; specialize (BndL1 _ IN). move BndL1 at bottom. *)
(*   rewrite (Int.unsigned_repr (Z.of_nat _)). *)
(*   rewrite Int.unsigned_repr. *)
(*   eapply Z.lt_le_trans. 2: apply BndL1. *)
(*   apply Z.add_lt_mono_l. *)
(*   eapply Z.lt_le_trans. apply IB'. rewrite Mem.size_block_snd. *)
(*   rewrite Forall_forall in SZNINJ. *)
(*   specialize (SZNINJ _ i1). *)
(*   change (two_power_nat 3) with 8. *)
(*   generalize (sinj_fb _ _ _ _ _ MI _ (proj2 SZNINJ)). lia. *)
(*   split. generalize (Int.unsigned_range o'); lia. *)
(*   etransitivity. *)
(*   2: apply next_addr_mu. 2: apply COMP. *)
(*   etransitivity. 2: apply BndL1. *)
(*   apply Z.add_le_mono_l. *)
(*   rewrite Forall_forall in SZNINJ. *)
(*   specialize (SZNINJ _ i1). *)
(*   change (two_power_nat 3) with 8. *)
(*   generalize (sinj_fb _ _ _ _ _ MI _ (proj2 SZNINJ)). red in IB'; rewrite Mem.size_block_snd in IB'; lia.         *)
(*   split. lia.  *)
(*   etransitivity. *)
(*   2: apply next_addr_mu. 2: apply COMP. *)
(*   etransitivity. 2: apply BndL1. *)
(*   generalize (two_power_nat_pos 3); lia. *)
(*   rewrite <- Z.add_assoc. *)
(*   etransitivity. apply align_le with (y := two_power_nat 3); auto. *)
(*   generalize (two_power_nat_pos 3) (Int.unsigned_range o); nia. *)
  
(*   erewrite make_cm_other'; eauto. *)
(*   eapply nooverlap_after_cm1; eauto. *)
(*   eapply make_cm_in; eauto. *)
(*   generalize (pos_length peq _ _ i0); erewrite make_cm_lengths; eauto.  *)
(*   eapply make_cm_in; eauto. *)
(* Qed. *)

(* Lemma forget_compat_case_2: *)
(*   forall f m1 m2 sil *)
(*     (MI : sinj f m1 m2 sil nil) *)
(*     cm2 *)
(*     (COMP : Mem.compat_m m2 Mem.M32 cm2) *)
(*     (g : next_addr m2 cm2 > Mem.size_mem m2), *)
(*    exists cm1, *)
(*      Mem.compat_m m1 Mem.M32 cm1 /\ *)
(*      (forall b b', f b = Some b' -> cm1 b = cm2 b'). *)
(* Proof. *)
(*   intros. *)
(*   assert (NUMFORGOTTEN := inj_number_blocks_forgotten _ _ _ _ MI). *)
(*   set (F := length sil) in *. *)
(*   assert (PERM_INJ := perm_inj_filter_map _ _ _ _ MI). *)
(*   destruct (part_inj (Mem.mk_block_list m1) f) eqn:PI. *)
(*   assert (SZM1: Mem.size_mem m1 = Alloc.size_mem_aux MA (l ++ l0)). *)
(*   { *)
(*     unfold Mem.size_mem, Alloc.size_mem_aux. *)
(*     apply Alloc.size_mem_al_permut. auto. *)
(*     unfold part_inj in PI; apply partition_app_perm in PI. auto. *)
(*   } *)
(*   assert (SZM2: Mem.size_mem m2 = Alloc.size_mem_aux MA l). *)
(*   { *)
(*     unfold Mem.size_mem, Alloc.size_mem_aux. *)
(*     eapply size_mem_al_permut'. 2: eauto. 2: eauto. *)
(*     apply Permutation_sym. *)
(*     generalize (part_inj_permut' _ _ _ _ MI). *)
(*     unfold part_inj in PI; rewrite PI. intro A; apply A. *)
(*     apply partition_app_perm in PI. auto. *)
(*     rewrite Forall_forall. intros x IN.  *)
(*     des x. unfold Mem.mk_block_list in IN. apply Alloc.mbla_in in IN. subst. *)
(*     apply Zle_ge. apply Mem.size_block_pos. *)
(*     rewrite Forall_forall. intros x IN.  *)
(*     des x. rewrite in_partition_l in IN. 2: unfold part_inj in PI; eauto. des IN. *)
(*     unfold Mem.mk_block_list in i. apply Alloc.mbla_in in i. subst. *)
(*     apply Zle_ge. apply Mem.size_block_pos. *)
(*   } *)
(*   assert (Fspec := Fspec_szmem _ _ _ _ MI _ NUMFORGOTTEN _ _ PI SZM1 SZM2). *)
(*   destruct (list_of_forgotten _ _ _ _ PI _ Fspec) as [lf [LEN [SZNINJ [LNR SPEClf]]]]. *)
(*   (* lf is the list of all non-empty blocks that are not injected *) *)

(*   assert (IM := mem_is_memory m2 cm2 COMP). *)
(*   generalize (AddBlock (proj1 MA_bound) eq_refl eq_refl IM eq_refl). *)
  
(*   intros [cm1 [IMA [HMB CFA]]]. *)
(*   generalize (amem_free_addr_szmem m2 cm2). *)
(*   generalize (cmem_free_addr_nextaddr _ _ COMP). *)
(*   intros A B. *)
(*   assert ( AMEM_LE_CMEM:  (amem_free_addr MA (spec_of_acmem (acm_of_mem m2 cm2)) <= *)
(*                            next_box 3 (cmem_free_addr (acm_of_mem m2 cm2)))%nat). *)
(*   { *)
(*     rewrite Nat2Z.inj_le. *)
(*     (* transitivity (Mem.size_mem m2 - two_power_nat MA). lia. *) *)
(*     rewrite next_box_align. *)
(*     rewrite Z2Nat.id. *)
(*     rewrite <- A, <- B in g.  *)
(*     etransitivity. *)
(*     2: apply align_le; auto. generalize (two_power_nat_pos MA); lia. *)
(*     etransitivity; [|apply align_le; auto]. lia. *)
(*   } *)
(*   assert (DIFFeq: *)
(*     (diff (amem_free_addr MA (spec_of_acmem (acm_of_mem m2 cm2))) *)
(*           (next_box 3 (cmem_free_addr (acm_of_mem m2 cm2)))) = *)
(*     (Z.to_nat (align (next_addr m2 cm2) (two_power_nat 3)) - *)
(*      Z.to_nat *)
(*        (Mem.size_mem m2 - two_power_nat MA))%nat). *)
(*   { *)
(*     rewrite diff_inv; auto. *)
(*     rewrite <- A, <- B. *)
(*     rewrite <- Z2Nat.inj_sub. *)
(*     - rewrite next_box_align. *)
(*       rewrite Z2Nat.inj_sub. f_equal. *)
(*       rewrite <- (Nat2Z.id (amem_free_addr _ _)) at 1. *)
(*       f_equal. lia. *)
(*       lia. *)
(*     - lia. *)
(*   } *)
(*   rewrite DIFFeq in HMB. *)
(*   rewrite Max.max_r in CFA by auto. *)
(*   destruct (szmem_next_addr_spec m2 cm2) as [X [Y [C D]]]. lia. *)
(*   assert (diffsup:= diff_sup_X m2 cm2 X Y C D). *)
(*   generalize (has_more_box_le (N':= X + NPeano.pow 2 (MA - 3)) (proj1 MA_bound) IM IMA HMB). *)
(*   intro E; trim E. etransitivity. apply div_sup_X. apply NPeano.Nat.div_le_mono. *)
(*   eapply sz_box_not_zero. apply (proj1 MA_bound). lia. *)
(*   rename cm1 into old_cm1. *)
(*   destruct E as [cm1 [HMB' SL]]. *)
(*   exploit has_more_box_spec. apply HMB'. eapply is_memory_sublist. *)
(*   apply (proj1 MA_bound). *)
(*   2: eauto. eauto. *)
(*   intros [l1 [LENl1 [ISBOX [LNR1 [SCA [SL1 [INimpl INimpl2]]]]]]]. *)
(*   (* l1 is the list of available boxes in cm2, up to next_addr cm2 *) *)

(*   assert (L1PROP: exists l1', (length l1' >= X)%nat /\ *)
(*                  Forall (fun x => is_box 3 x /\ ac_addr x <> O) l1' /\ *)
(*                  list_norepet l1' /\ *)
(*                  sorted_ca l1' /\ *)
(*                  sublist l1' cm1 /\ *)
(*                  (forall x, In x l1' -> In x cm1) /\ *)
(*                  (forall x, In x l1' -> ~ In x (acm_of_mem m2 cm2))). *)
(*   { *)
(*     exists (filter (fun x => negb (beq_nat (ac_addr x) O)) l1). *)
(*     repSplit. *)
(*     - inv SCA. contradict LENl1. simpl. *)
(*       cut (1 <= NPeano.pow 2 (MA - 3))%nat. lia. *)
(*       apply two_power. *)
(*       simpl in LENl1. *)
(*       simpl. *)
(*       destr. *)
(*       generalize (two_power (MA - 3)); lia. *)
(*       generalize (two_power (MA - 3)); lia. *)
(*       simpl. *)
(*       destr. destr. *)
(*       rewrite length_filter_true. *)
(*       generalize (two_power (MA - 3)); lia. *)
(*       eapply Forall_impl. *)
(*       2: apply sorted_ca_Forall. 2: apply SORTEDTAIL. simpl. *)
(*       intros. *)
(*       nattac'. lia. *)
(*       nattac'. lia. *)
(*       nattac'. inv ISBOX. inv H1. *)
(*       generalize (sz_box_not_zero (proj1 MA_bound)). lia. *)
(*       rewrite length_filter_true. *)
(*       generalize (two_power (MA - 3)); lia. *)
(*       eapply Forall_impl. *)
(*       2: apply sorted_ca_Forall. 2: apply SORTEDTAIL. simpl. *)
(*       intros. *)
(*       nattac'. lia. *)
(*     -  *)
(*       apply Forall_and. *)
(*       apply Forall_filter; auto. *)
(*       rewrite Forall_forall. *)
(*       intros x IN. *)
(*       rewrite filter_In in IN. intro E; rewrite E in IN. *)
(*       rewrite <- beq_nat_refl in IN. destr. *)
(*     - apply lnr_filter. auto. *)
(*     - apply sorted_ca_filter; auto. *)
(*     - revert SL1; clear. *)
(*       induction 1; simpl; intros; eauto. constructor. *)
(*       destr; constructor; auto. *)
(*       constructor; auto. *)
(*     -  intros x IN. rewrite filter_In in IN. apply INimpl. destr. *)
(*     -  intros x IN. rewrite filter_In in IN. apply INimpl2. destr. *)
(*   } *)
(*   assert (exists l1', (length l1' = X)%nat /\ *)
(*                  Forall (fun x => is_box 3 x /\ ac_addr x <> O) l1' /\ *)
(*                  list_norepet l1' /\ *)
(*                  sorted_ca l1' /\ *)
(*                  sublist l1' cm1 /\ *)
(*                  (forall x, In x l1' -> In x cm1) /\ *)
(*                  (forall x, In x l1' -> ~ In x (acm_of_mem m2 cm2))). *)
(*   { *)
(*     clear - L1PROP. *)
(*     destruct L1PROP as [l1' [LEN [F [LNR [SCA [SL [II II2]]]]]]]. *)
    
(*     exists (take X l1'). *)
(*     repSplit. *)
(*     - apply take_length. auto. *)
(*     - apply take_Forall; auto. *)
(*     - apply take_lnr; auto. *)
(*     - apply take_sca; auto. *)
(*     - eapply sublist_trans. *)
(*       apply take_sublist. destr. *)
(*     - intros. *)
(*       apply take_In in H. apply II; auto. *)
(*     - intros. *)
(*       apply take_In in H. apply II2; auto. *)
(*   } *)
(*   clear L1PROP. clear l1 LENl1 ISBOX LNR1 SCA SL1 INimpl INimpl2. *)
(*   destruct H as [l1 [LEN1 [F' [lnr' [sca' [sl' [in' in2']]]]]]]. *)
(*   assert (BndL1: Forall (fun x => Z.of_nat (ac_addr x) + two_power_nat 3 <= next_addr m2 cm2 ) l1). *)
(*   { *)
(*     rewrite Forall_forall; intros x IN. *)
(*     rewrite <- A. *)
(*     generalize (cmem_free_addr_spec l1 sca'); *)
(*       rewrite (Forall_forall (fun x => _ <= _)%nat); intro E. *)
(*     trim E. *)
(*     revert F'. *)
(*     apply Forall_impl. intros a [IB ACA]; inv IB; destr. *)
(*     rewrite is_box_size; eapply sz_box_not_zero; eauto. *)
(*     specialize (E _ IN). *)
(*     apply Nat2Z.inj_le in E.  *)
(*     eapply Z.le_trans. *)
(*     rewrite Nat2Z.inj_add in E. *)
(*     rewrite Forall_forall in F'. specialize (F' _ IN). destruct F'. *)
(*     inv H. rewrite is_box_size in E. *)
(*     change (Z.of_nat (sz_box 3)) with (two_power_nat 3). *)
(*     apply E. *)
(*     apply inj_le. *)
(*     etransitivity. *)
(*     apply (cmem_free_addr_In _ _ sl'). eapply sublist_sorted. *)
(*     3: eauto. apply MA_bound. *)
(*     eapply is_sorted; eauto. *)
(*     etransitivity. *)
(*     apply (cmem_free_addr_In _ _ SL).  *)
(*     eapply is_sorted; eauto. *)
(*     eapply cmem_free_addr_slack. eauto. auto. auto. apply CFA. *)
(*   } *)

  
(*   set (cm1' := fun b => *)
(*                  match f b with *)
(*                    Some b' => cm2 b' *)
(*                  | None => Int.zero *)
(*                  end). *)

(*   assert (AddrSpace: *)
(*             forall b o, *)
(*               NormaliseSpec.in_bound (Int.unsigned o) (Mem.bounds_of_block m1 b) -> *)
(*               0 < *)
(*               Int.unsigned *)
(*                 (Int.add *)
(*                    (realloc_blocks cm1' lf l1 *)
(*                                    (Int.repr (align (next_addr m2 cm2) (two_power_nat 3))) b) o) < *)
(*               Mem.comp_size Mem.M32). *)
(*   { *)
(*     intros b o IB. *)
(*     eapply realloc_blocks_ind with *)
(*     (P := fun m i => 0 < Int.unsigned (Int.add i o) < Mem.comp_size Mem.M32) (m:= m1). *)
(*     + revert SZNINJ. *)
(*       apply Forall_impl. *)
(*       intros. *)
(*       destruct (sinj_fb _ _ _ _ _ MI _ (proj2 H)). destr. *)
(*     + unfold cm1'; intros NIN. *)
(*       destr.  *)
(*       eapply NormaliseSpec.addr_space. eauto. *)
(*       eapply in_bound_sinj; eauto. *)
(*       elim NIN. apply SPEClf. auto. eapply in_bound_size_not_null; eauto. *)
(*     + intros x INF IN BNDS. *)
(*       rewrite Forall_forall in BndL1. *)
(*       specialize (BndL1 _ IN). *)
(*       generalize (next_addr_mu _ _ COMP). intro NAM. *)
(*       red in IB. *)
(*       rewrite Mem.bounds_lo_0 in IB. *)
(*       rewrite Mem.size_block_snd in IB. *)
(*       split. *)
(*       unfold Int.add. rewrite (Int.unsigned_repr (Z.of_nat _)). *)
(*       rewrite Int.unsigned_repr. *)
(*       rewrite Forall_forall in F'. specialize (F' _ IN). generalize (Int.unsigned_range o); lia. *)
(*       split. lia. etransitivity. 2: apply next_addr_mu. 2: apply COMP. *)
(*       etransitivity. apply Zplus_le_compat_l. rewrite Z.lt_eq_cases. left; apply IB. *)
(*       etransitivity. apply Zplus_le_compat_l. apply BNDS. auto. *)
(*       lia. *)
(*       unfold Int.add. rewrite (Int.unsigned_repr (Z.of_nat _)). *)
(*       rewrite Int.unsigned_repr. *)
(*       rewrite Forall_forall in F'. specialize (F' _ IN). *)
(*       eapply Z.lt_le_trans. *)
(*       apply Zplus_lt_compat_l. apply IB. unfold Mem.comp_size. *)
(*       etransitivity. apply Zplus_le_compat_l. apply BNDS. auto. *)
(*       split. lia. etransitivity. 2: apply next_addr_mu. 2: apply COMP. *)
(*       etransitivity. apply Zplus_le_compat_l. rewrite Z.lt_eq_cases. left; apply IB. *)
(*       etransitivity. apply Zplus_le_compat_l.  apply BNDS. auto. *)
(*       split. lia. etransitivity. 2: apply next_addr_mu. 2: apply COMP. *)
(*       generalize (two_power_nat_pos 3); lia. *)
(*     + intro RNG. rewrite <- A. *)
(*       rewrite LEN1, LEN. *)
(*       intros. *)
(*       unfold Int.add. *)
(*       cut (0 < *)
(*            Int.unsigned *)
(*              (Int.repr *)
(*                 (align (Z.of_nat (cmem_free_addr (acm_of_mem m2 cm2))) *)
(*                        (two_power_nat 3) + *)
(*                  Z.of_nat M * two_power_nat 3)) + Int.unsigned o < *)
(*            Mem.comp_size Mem.M32). *)
(*       intros; rewrite Int.unsigned_repr; unfold Mem.comp_size in *. lia. lia. *)
(*       cut (0 < align *)
(*                  (Z.of_nat (cmem_free_addr (acm_of_mem m2 cm2))) *)
(*                  (two_power_nat 3) + *)
(*                Z.of_nat M * two_power_nat 3 + Int.unsigned o < Int.max_unsigned). *)
(*       intro AA. *)
(*       rewrite Int.unsigned_repr. unfold Mem.comp_size; lia. *)
(*       split; [|generalize (Int.unsigned_range o); lia]. *)
(*       apply add_pos_pos. *)
(*       etransitivity. 2: apply align_le; auto. lia. *)
(*       generalize (two_power_nat_pos 3); nia. *)
(*       destruct (le_dec F X). *)
(*       assert (F - X = O)%nat by lia. lia. *)
(*       rewrite Forall_forall in SZNINJ. *)
(*       specialize (SZNINJ _ H0). *)
(*       assert (Bnd: Mem.size_block m1 b <= 8). *)
(*       { *)
(*         destruct (sinj_fb _ _ _ _ _ MI b). destr.  destr. *)
(*       } *)
(*       assert (IB': Int.unsigned o < 8). *)
(*       { *)
(*         red in IB. *)
(*         rewrite Mem.bounds_lo_0 in IB. *)
(*         rewrite Mem.size_block_snd in IB. lia. *)
(*       } *)
(*       clear -  C D A NUMFORGOTTEN n H IB'. *)
(*       rewrite A. clear A. *)
(*       split. *)
(*       * eapply Z.lt_le_trans. *)
(*         2: apply Z.add_le_mono. *)
(*         2: apply Z.add_le_mono. *)
(*         2: apply align_le; auto. *)
(*         2: instantiate (1:=0); generalize (two_power_nat_pos 3); nia. *)
(*         2: instantiate (1:=0); generalize (Int.unsigned_range o); lia. *)
(*         ring_simplify. *)
(*         rewrite <- C. *)
(*         eapply Z.lt_le_trans. *)
(*         2: rewrite <- Z.add_assoc; apply Z.add_le_mono. *)
(*         2: apply szmem_bndinf. *)
(*         2: instantiate (1:=0); generalize (two_power_nat_pos 3); nia. *)
(*         generalize (two_power_nat_pos MA); lia. *)
(*       * *)
(*         match goal with *)
(*           |- ?a < ?b => cut (a <= Mem.size_mem m1 + two_power_nat MA) *)
(*         end. *)
(*         generalize (Mem.mem_lemu m1); unfold Mem.__szmem, Mem.comp_size. lia. *)
(*         transitivity (align (next_addr m2 cm2) (two_power_nat 3) + *)
(*                       Z.of_nat (F - X - 1) * two_power_nat 3 + Int.unsigned o). *)
(*         apply Z.add_le_mono_r. *)
(*         apply Z.add_le_mono. lia. *)
(*         apply Z.mul_le_mono_nonneg_r. generalize (two_power_nat_pos 3); lia. *)
(*         apply Nat2Z.inj_le. lia. *)
(*         rewrite <- NUMFORGOTTEN; clear NUMFORGOTTEN. *)
(*         rewrite <- C; clear C. *)
(*         transitivity (Mem.size_mem m2 + two_power_nat 3 * Z.of_nat X *)
(*                       + two_power_nat 3 + Z.of_nat (F - X - 1) * two_power_nat 3 + *)
(*                       Int.unsigned o). *)
(*         rewrite size_mem_aligned_3. *)
(*         rewrite <- ! Z.add_assoc. rewrite <- Mem.align_distr; auto. *)
(*         rewrite <- ! Z.add_assoc.  *)
(*         apply Z.add_le_mono_l. *)
(*         rewrite Z.mul_comm. rewrite <- Mem.align_mul; auto. *)
(*         rewrite <- Mem.align_distr; auto. *)
(*         rewrite <- ! Z.add_assoc. apply Z.add_le_mono_l. *)
(*         apply Z.add_le_mono_r. *)
(*         destruct (zlt 0 Y). *)
(*         rewrite Mem.align_small; lia. *)
(*         assert (Y = 0) by lia. subst. *)
(*         rewrite align_0; auto. *)
(*         lia. *)
(*         cut (two_power_nat 3 * (Z.of_nat X + 1 + Z.of_nat (F - X - 1)) + *)
(*              Int.unsigned o <= *)
(*              two_power_nat MA * (Z.of_nat F + 1)). lia. *)
(*         replace (Z.of_nat X + 1 + Z.of_nat (F - X - 1)) *)
(*         with (Z.of_nat F) by lia. *)
(*         transitivity (two_power_nat 3 * (Z.of_nat F + 1)). *)
(*         rewrite Z.mul_add_distr_l. *)
(*         apply Z.add_le_mono_l. change (two_power_nat 3 * 1) with 8; lia. *)
(*         apply Z.mul_le_mono_nonneg. *)
(*         generalize (two_power_nat_pos 3); lia. *)
(*         rewrite ! two_power_nat_two_p. apply two_p_monotone. *)
(*         generalize (MA_bound); lia. lia. lia. *)
(*     + *)
(*       rewrite LEN1, LEN. *)
(*       clear -  C D NUMFORGOTTEN COMP. *)
(*       split. *)
(*       erewrite <- cmem_free_addr_nextaddr; eauto. lia. *)
(*       destruct (le_dec F X). *)
(*       assert (F - X = 0)%nat by lia. rewrite H in *. ring_simplify. *)
(*       apply next_addr_mu. auto. *)
(*       rewrite <- C. *)
(*       cut (Mem.size_mem m2 + two_power_nat 3 * (Z.of_nat X + Z.of_nat (F - X) + 1)  <= Int.max_unsigned). lia. *)
(*       replace (Z.of_nat X + Z.of_nat (F - X) + 1) with (Z.of_nat F + 1) by lia. *)
(*       match goal with *)
(*         |- ?a <= ?b => cut (a <= Mem.size_mem m1 + two_power_nat MA) *)
(*       end. *)
(*       generalize (Mem.mem_lemu m1); unfold Mem.__szmem, Mem.comp_size. lia. *)
(*       rewrite <- NUMFORGOTTEN. *)
(*       rewrite <- Z.add_assoc. *)
(*       apply Z.add_le_mono_l. *)
(*       transitivity (two_power_nat MA * (Z.of_nat F + 1)). *)
(*       apply Z.mul_le_mono_nonneg_r. lia. *)
(*       rewrite ! two_power_nat_two_p. apply two_p_monotone. *)
(*       generalize (MA_bound); lia. lia.  *)
(*     + auto. *)
(*   } *)

(*   exists (realloc_blocks cm1' lf l1 *)
(*                     (Int.repr (align (next_addr m2 cm2) (two_power_nat 3)))). *)
(*   split. *)
      
(*   { *)
(*     constructor. *)
(*     - apply AddrSpace. *)
(*     - assert (next_addr_rng: *)
(*                 0 <= next_addr m2 cm2 <= *)
(*                 Int.max_unsigned *)
(*                 - two_power_nat 3 * Z.of_nat (length lf - length l1)). *)
(*       { *)
(*         rewrite LEN1, LEN. *)
(*         clear -  C D  NUMFORGOTTEN COMP. *)
(*         split. *)
(*         erewrite <- cmem_free_addr_nextaddr; eauto. lia. *)
(*         destruct (le_dec F X). *)
(*         assert (F - X = 0)%nat by lia. rewrite H in *. ring_simplify. *)
(*         apply next_addr_mu. auto. *)
(*         rewrite <- C. *)
(*         cut (Mem.size_mem m2 + two_power_nat 3 * (Z.of_nat X + Z.of_nat (F - X) + 1)  <= Int.max_unsigned). lia. *)
(*         replace (Z.of_nat X + Z.of_nat (F - X) + 1) with (Z.of_nat F + 1) by lia. *)
(*         match goal with *)
(*           |- ?a <= ?b => cut (a <= Mem.size_mem m1 + two_power_nat MA) *)
(*         end. *)
(*         generalize (Mem.mem_lemu m1); unfold Mem.__szmem, Mem.comp_size. lia. *)
(*         rewrite <- NUMFORGOTTEN. *)
(*         rewrite <- Z.add_assoc. *)
(*         apply Z.add_le_mono_l. *)
(*         transitivity (two_power_nat MA * (Z.of_nat F + 1)). *)
(*         apply Z.mul_le_mono_nonneg_r. lia. *)
(*         rewrite ! two_power_nat_two_p. apply two_p_monotone. *)
(*         generalize (MA_bound); lia. lia. *)
(*       } *)
(*       clear - next_addr_rng BndL1 LEN LEN1 F' COMP MI SPEClf sca' lnr' in' in2' IMA SL HMB' SZNINJ AddrSpace LNR. *)
(*       intros b b' o o' n IB IB'. *)
(*       unfold realloc_blocks. *)
(*       destr. *)
(*         assert (forall b z, *)
(*                    In b l -> *)
(*                    0 <= z < two_power_nat 3 -> *)
(*                    0 <= *)
(*                    align (next_addr m2 cm2) (two_power_nat 3) + *)
(*                    Z.of_nat (pos peq b l) * two_power_nat 3 +  *)
(*                    z <= Int.max_unsigned). *)
(*         { *)
(*           intros b0 z IN0 RNG. *)
(*           split. *)
(*           apply add_pos_pos. *)
(*           etransitivity. *)
(*           2: apply Z.add_le_mono_r. *)
(*           2: apply align_le; auto. *)
(*           generalize (two_power_nat_pos 3); nia. lia. *)

(*           generalize (pos_length peq _ _ IN0). *)
(*           generalize (pos peq b0 l) as M. intros M Mbnd. *)
(*           destruct (align_divides (next_addr m2 cm2) _ (two_power_nat_pos 3)) *)
(*             as [x EQ]. *)
(*           rewrite EQ. *)
(*           transitivity (two_power_nat 3 * (x + Z.of_nat M) + z). lia.           *)
(*           rewrite (Z_div_mod_eq  Int.max_unsigned _ (two_power_nat_pos 3)). *)
(*           change (Int.max_unsigned mod two_power_nat 3) with 7. *)
          
(*           etransitivity. apply Zplus_le_compat_l. instantiate (1:=7). *)
(*           revert RNG; change (two_power_nat 3) with 8; lia. *)
(*           apply align_slack. 2: change (two_power_nat 3) with 8; lia. *)
(*           rewrite (Z_div_mod_eq  Int.max_unsigned _ (two_power_nat_pos 3)) *)
(*             in next_addr_rng. *)
(*           change (Int.max_unsigned mod two_power_nat 3) with 7 in next_addr_rng. *)
(*           assert (next_addr m2 cm2 + two_power_nat 3 * Z.of_nat (length lf - length l1) <= *)
(*                   (two_power_nat 3 * (Int.max_unsigned / two_power_nat 3) + 7)).  lia. *)
(*           erewrite make_cm_lengths in Mbnd; eauto. *)
(*           revert H. *)
(*           rewrite (Z_div_mod_eq (next_addr m2 cm2) _ (two_power_nat_pos 3)). *)
(*           apply Nat2Z.inj_lt in Mbnd. *)
(*           cut (next_addr m2 cm2 / two_power_nat 3 <= x). *)

(*           generalize (Z.mod_pos_bound (next_addr m2 cm2) _ (Z.gt_lt _ _ (two_power_nat_pos 3))). *)
(*           intros.  *)
(*           etransitivity. 2:apply H1. *)
(*           rewrite Z.mul_add_distr_l. *)
(*           transitivity (two_power_nat 3 * (next_addr m2 cm2/two_power_nat 3 + 1) + (next_addr m2 cm2 mod two_power_nat 3) + *)
(*                         two_power_nat 3 * (Z.of_nat (length lf - length l1) - 1)). *)
(*           2: lia. *)
(*           apply Z.add_le_mono. *)
(*           rewrite Z.mul_comm, <- EQ. *)
(*           etransitivity. apply align_pessimistic; auto. lia. *)
(*           rewrite Z.mul_add_distr_l. ring_simplify. *)
(*           rewrite (Z_div_mod_eq (next_addr m2 cm2) _ (two_power_nat_pos 3)) at 1. lia. *)
(*           apply Z.mul_le_mono_nonneg_l. *)
(*           generalize (two_power_nat_pos 3); lia. *)
(*           lia. *)
(*           rewrite Z.mul_le_mono_pos_l with (p:=two_power_nat 3). *)
(*           rewrite (Z.mul_comm _ x). rewrite <- EQ. *)
(*           unfold align. *)
(*           assert (forall p q r, p <= q -> r >= 0 -> p <= q + r) by (intros; lia). *)
(*           rewrite Z.mul_comm. *)
(*           rewrite <- Z.mul_le_mono_pos_r. *)
(*           apply Z.div_le_mono. generalize (two_power_nat_pos 3); lia. *)
(*           change (two_power_nat 3) with 8; lia. *)
(*           generalize (two_power_nat_pos 3); lia. *)
(*           generalize (two_power_nat_pos 3); lia. *)
(*         } *)

(*         assert (forall b o, In b l -> *)
(*                        NormaliseSpec.in_bound (Int.unsigned o) (Mem.bounds_of_block m1 b) -> *)
(*                        0 <= Int.unsigned o < two_power_nat 3). *)
(*         { *)
(*           clear - SZNINJ MI Heqp. *)
(*           intros b o i1 IB'. *)
(*           red in IB'. rewrite Mem.bounds_lo_0 in IB'. rewrite Mem.size_block_snd in IB'. *)
(*           rewrite Forall_forall in SZNINJ. *)
(*           specialize (SZNINJ _ (make_cm_in _ _ _ _ _ Heqp _ i1)). *)
(*           change (two_power_nat 3) with 8. *)
(*           destruct (sinj_fb _ _ _ _ _ MI _ (proj2 SZNINJ)). lia.  *)
(*         } *)
(*       destruct (in_dec peq b l); *)
(*         destruct (in_dec peq b' l). *)
(*       + *)

(*         exploit make_cm_lnr. 2: apply Heqp. eauto. intro LNRL. *)
(*         assert (Lsmall: Z.of_nat (length l) * two_power_nat 3 <= Int.max_unsigned). *)
(*         { *)
(*           erewrite make_cm_lengths. 2: eauto. lia. *)
(*         } *)
(*         rewrite add_blocks_after_in; auto. *)
(*         rewrite add_blocks_after_in; auto. *)
(*         rewrite ! Values_symbolic.Val.int_add_repr. *)
(*         unfold Int.add. *)

(*         rewrite (Int.unsigned_repr (align _ _ + _)). *)
(*         Focus 2. *)
(*         trim (H _ 0 i0). vm_compute; destr. rewrite Z.add_0_r in H; auto. *)
(*         rewrite Int.unsigned_repr. *)
(*         Focus 2. *)
(*         apply H. auto. *)
(*         red in IB. rewrite Mem.bounds_lo_0 in IB. rewrite Mem.size_block_snd in IB. *)
(*         rewrite Forall_forall in SZNINJ. *)
(*         specialize (SZNINJ _ (make_cm_in _ _ _ _ _ Heqp _ i0)). *)
(*         change (two_power_nat 3) with 8. *)
(*         destruct (sinj_fb _ _ _ _ _ MI _ (proj2 SZNINJ)). lia.  *)
(*         rewrite (Int.unsigned_repr (align _ _ + _)). *)
(*         Focus 2. *)
(*         trim (H _ 0 i1). vm_compute; destr. rewrite Z.add_0_r in H; auto. *)
(*         rewrite Int.unsigned_repr. *)
(*         Focus 2. *)
(*         apply H. auto. *)
(*         red in IB'. rewrite Mem.bounds_lo_0 in IB'. rewrite Mem.size_block_snd in IB'. *)
(*         rewrite Forall_forall in SZNINJ. *)
(*         specialize (SZNINJ _ (make_cm_in _ _ _ _ _ Heqp _ i1)). *)
(*         change (two_power_nat 3) with 8. *)
(*         destruct (sinj_fb _ _ _ _ _ MI _ (proj2 SZNINJ)). lia.  *)

(*         rewrite <- ! Z.add_assoc. *)
(*         apply neq_add. *)

(*         generalize (H0 _ _ i0 IB) (H0 _ _ i1 IB'). clear H0 H. *)
(*         intros RNG1 RNG2 EQ. *)
(*         assert (two_power_nat 3 * (Z.of_nat (pos peq b l) - Z.of_nat (pos peq b' l)) = *)
(*                 Int.unsigned o' - Int.unsigned o). lia. *)
(*         assert (-7 <= Int.unsigned o' - Int.unsigned o <= 7). *)
(*         change (two_power_nat 3) with 8 in *; lia. *)
(*         rewrite <- H in H0. *)
(*         assert (Z.of_nat (pos peq b l) = Z.of_nat (pos peq b' l)) by nia. *)
(*         apply f_equal with (f:= Z.to_nat) in H1. *)
(*         rewrite ! Nat2Z.id in H1. *)
(*         revert H1. *)
(*         apply pos_diff; auto. *)
(*       + eapply nooverlap_add_blocks_after; eauto. *)
(*       + apply not_eq_sym. *)
(*         eapply nooverlap_add_blocks_after; eauto. *)
(*       + rewrite add_blocks_after_other; auto. *)
(*         rewrite add_blocks_after_other; auto. *)

(*         Lemma make_cm_in'': *)
(*           forall lb lh cm cm' lb' *)
(*             (MC: make_cm cm lb lh = (cm', lb')) *)
(*             b *)
(*             (i1: In b lb) *)
(*             (n1: ~ In b lb') *)
(*             b' *)
(*             (i2: In b' lb) *)
(*             (n2: ~ In b' lb') *)
(*             (lnrh: list_norepet lh) *)
(*             (d: b <> b'), *)
(*           exists h1 h2, *)
(*             h1 <> h2 /\ *)
(*             cm' b = Int.repr (Z.of_nat (ac_addr h1)) /\ In h1 lh /\ *)
(*             cm' b' = Int.repr (Z.of_nat (ac_addr h2)) /\ In h2 lh. *)
(*         Proof. *)
(*           induction lb; simpl; intros; eauto. *)
(*           easy. *)
(*           destr_in MC. *)
(*           - inv MC. des (peq a b). *)
(*           - destr_in MC. inv MC. *)
(*             unfold update. *)
(*             repeat destr. *)
(*             + subst. clear i1. des i2. *)
(*               exists a0. *)
(*               destruct (make_cm_in' _ _ _ _ _ Heqp _ i0 n2) as [h2 [EQ IN]]; *)
(*                 exists h2; rewrite EQ; repSplit; auto. *)
(*               intro; subst. inv lnrh; auto. *)
(*             + des i1. clear i2. *)
(*               destruct (make_cm_in' _ _ _ _ _ Heqp _ i0 n1) as [h1 [EQ IN]]; *)
(*                 exists h1, a0; rewrite EQ; repSplit; auto. *)
(*               intro; subst. inv lnrh; auto. *)
(*             + des i1. des i2. *)
(*               inv lnrh. *)
(*               destruct (IHlb _ _ _ _ Heqp _ i0 n1 _ i1 n2 H2 d) *)
(*                 as [h1 [h2 [d' [EQ1 [IN1 [EQ2 IN2]]]]]]. *)
(*               exists h1, h2; repSplit; auto. *)
(*         Qed. *)
        
(*         destruct (in_dec peq b lf); destruct (in_dec peq b' lf). *)
(*         * destruct (make_cm_in'' _ _ _ _ _ Heqp _ i0 n0 _ i1 n1 lnr' n) *)
(*             as (h1 & h2 & d & EQ1 & IN1 & EQ2 & IN2). *)
(*           rewrite EQ1, EQ2.  *)
(*           exploit make_cm_lnr. 2: apply Heqp. eauto. intro LNRL. *)
(*           unfold Int.add. *)
(*           move BndL1 at bottom. *)
(*           rewrite (Int.unsigned_repr (Z.of_nat _)). *)
(*           Focus 2. *)

(*           Ltac useForall F IN N := *)
(*             let H := fresh N in *)
(*             generalize F; intro H; rewrite Forall_forall in H; *)
(*             specialize (H _ IN). *)
(*           useForall BndL1 IN1 B. *)
(*           split. lia. etransitivity. 2: eapply next_addr_mu; eauto. *)
(*           etransitivity. 2: apply B. generalize (two_power_nat_pos 3); lia. *)

(*           rewrite (Int.unsigned_repr (Z.of_nat _)). *)
(*           Focus 2. *)
(*           useForall BndL1 IN2 B. *)
(*           split. lia. etransitivity. 2: eapply next_addr_mu; eauto. *)
(*           etransitivity. 2: apply B. generalize (two_power_nat_pos 3); lia. *)

(*           rewrite (Int.unsigned_repr). *)
(*           Focus 2. *)
(*           useForall BndL1 IN1 B. *)
(*           split. generalize (Int.unsigned_range o); lia. *)
(*           etransitivity. 2: eapply next_addr_mu; eauto. *)
(*           etransitivity. 2: apply B. apply Z.add_le_mono_l. *)
(*           red in IB; rewrite Mem.bounds_lo_0, Mem.size_block_snd in IB. *)
(*           useForall SZNINJ i0 C. change (two_power_nat 3) with 8. *)
(*           destruct (sinj_fb _ _ _ _ _ MI _ (proj2 C)). lia.  *)

(*           rewrite (Int.unsigned_repr). *)
(*           Focus 2. *)
(*           useForall BndL1 IN2 B. *)
(*           split. generalize (Int.unsigned_range o'); lia. *)
(*           etransitivity. 2: eapply next_addr_mu; eauto. *)
(*           etransitivity. 2: apply B. apply Z.add_le_mono_l. *)
(*           red in IB'; rewrite Mem.bounds_lo_0, Mem.size_block_snd in IB'. *)
(*           useForall SZNINJ i1 C. change (two_power_nat 3) with 8. *)
(*           destruct (sinj_fb _ _ _ _ _ MI _ (proj2 C)). lia.  *)


(*           useForall F' IN1 B. *)
(*           useForall F' IN2 C. *)
(*           Ltac find_bounds IB SZNINJ MI IN := *)
(*             let H'' := fresh in *)
(*             match type of IB with *)
(*               NormaliseSpec.in_bound ?i _ => *)
(*               assert (H'' : 0 <= i < two_power_nat 3); *)
(*                 [ *)
(*                   let H := fresh in *)
(*                   generalize IB; intro H; *)
(*                   red in H; rewrite Mem.bounds_lo_0, Mem.size_block_snd in H; *)
(*                   let H' := fresh in  *)
(*                   useForall SZNINJ IN H'; change (two_power_nat 3) with 8 in *; *)
(*                   destruct (sinj_fb _ _ _ _ _ MI _ (proj2 H')); lia  *)
(*                  |] *)
(*             end. *)
          
(*           find_bounds IB SZNINJ MI i0. *)
(*           find_bounds IB' SZNINJ MI i1. *)
(*           destruct (proj1 B), (proj1 C). *)
(*           destruct (addr_aligned_mult (proj1 MA_bound) is_box_aligned). *)
(*           destruct (addr_aligned_mult (proj1 MA_bound) is_box_aligned0). *)
(*           rewrite <- H3, <- H4. *)
(*           rewrite ! Nat2Z.inj_mul. *)
(*           change (Z.of_nat (NPeano.pow 2 3)) with 8. intro EQ. *)
(*           assert (8 * (Z.of_nat x - Z.of_nat x0) = Int.unsigned o' - Int.unsigned o) by lia. *)
(*           assert (-7 <= Int.unsigned o' - Int.unsigned o <= 7). *)
(*           change (two_power_nat 3) with 8 in *; lia. *)
(*           rewrite <- H5 in H6. *)
(*           assert (Z.of_nat x = Z.of_nat x0) by nia. *)
(*           apply f_equal with (f:= Z.to_nat) in H7. *)
(*           rewrite ! Nat2Z.id in H7. *)
(*           subst; apply d. des h1; des h2. *)
(*         * erewrite (make_cm_other' _ _ _ _ n2 _ _ Heqp). *)
(*           destruct (make_cm_in' _ _ _ _ _ Heqp _ i0 n0) as [x [EQ IN]]; rewrite EQ. *)
(*           eapply nooverlap_hole_cm1; eauto. *)
(*           useForall SZNINJ i0 A. *)
(*           destruct (sinj_fb _ _ _ _ _ MI _ (proj2 A)). lia.  *)
(*         * erewrite (make_cm_other' _ _ _ _ n2 _ _ Heqp). *)
(*           destruct (make_cm_in' _ _ _ _ _ Heqp _ i0 n1) as [x [EQ IN]]; rewrite EQ. *)
(*           apply not_eq_sym. *)
(*           eapply nooverlap_hole_cm1; eauto. *)
(*           useForall SZNINJ i0 A. *)
(*           destruct (sinj_fb _ _ _ _ _ MI _ (proj2 A)). lia.  *)
(*         * rewrite (make_cm_other' _ _ _ _ n2 _ _ Heqp). *)
(*           rewrite (make_cm_other' _ _ _ _ n3 _ _ Heqp). *)
(*           unfold cm1'. *)
(*           destr.  *)
(*           destr.  *)
(*           intros; eapply NormaliseSpec.overlap; eauto. *)
(*           intro; subst. *)
(*           exploit sinj_injective. eauto. eexact Heqo0. eexact Heqo1. destr. *)
(*           eapply in_bound_sinj; eauto. *)
(*           eapply in_bound_sinj; eauto. *)
(*           exfalso; apply n3; apply SPEClf; auto. *)
(*           eapply in_bound_size_not_null; eauto. *)
(*           exfalso; apply n2; apply SPEClf; auto. *)
(*           eapply in_bound_size_not_null; eauto. *)
         
(*     - intros. *)
(*       eapply realloc_blocks_ind with (m:=m1). *)
(*       + revert SZNINJ; apply Forall_impl. *)
(*         intros a W. destruct (sinj_fb _ _ _ _ _ MI _ (proj2 W)). lia.  *)
(*       + unfold cm1'. destr. destr. *)
(*         intros. *)
(*         cut (Mem.mask m1 b <= Mem.mask m2 b0)%nat. intro LEMASK. *)
(*         rewrite <- (NormaliseSpec.alignment _ _ _ _ COMP b0). *)
(*         IntFacts.solve_int. *)
(*         unfold Mem.nat_mask. *)
(*         rewrite ! Int.bits_not; auto. *)
(*         rewrite ! Int.testbit_repr; auto. *)
(*         rewrite ! two_power_nat_two_p. *)
(*         rewrite ! Int.Ztestbit_two_p_m1; auto. *)
(*         repeat destr; try lia. rewrite ! andb_false_r; auto. *)
(*         rewrite andb_false_r. reflexivity. *)
(*         rewrite ! andb_true_r; auto. *)
(*         lia. lia. *)
(*         eapply sinj_mask'; eauto. *)

(*       + intros h INF IN SZB. *)
(*         rewrite Forall_forall in F'; specialize (F' _ IN). destruct F' as [E F']. *)
(*         rewrite Forall_forall in SZNINJ; specialize (SZNINJ _ INF). *)
(*         destruct SZNINJ as [J K]. *)
(*         inv E. *)
(*         replace (Z.of_nat (ac_addr h)) with (align (Z.of_nat (ac_addr h)) *)
(*                                                    (two_power_nat 3)). *)
(*         unfold Mem.nat_mask. *)
(*         des (f b).  *)
(*         apply align_and'. *)
(*         apply (sinj_fb _ _ _ _ _ MI _ Heqo). *)
(*         eapply max_aligned_box in is_box_aligned. *)
(*         2: apply MA_bound. *)
(*         dex; rewrite <- is_box_aligned. *)
(*         rewrite Nat2Z.inj_mul. *)
(*         rewrite Mem.align_mul. auto. auto. *)
(*       + intros RNG M MLEN INF. *)
(*         rewrite Forall_forall in SZNINJ; specialize (SZNINJ _ INF). *)
(*         destruct SZNINJ as [J K]. *)
(*         unfold Mem.nat_mask. *)
(*         des (f b). *)
(*         rewrite <- Mem.align_mul; auto. *)
(*         rewrite Mem.align_distr. *)
(*         apply align_and'. apply (sinj_fb _ _ _ _ _ MI _ Heqo). auto. *)
(*       + *)
(*         rewrite LEN1, LEN. *)
(*         clear -  C D NUMFORGOTTEN COMP. *)
(*         split. *)
(*         erewrite <- cmem_free_addr_nextaddr; eauto. lia. *)

(*         destruct (le_dec F X). *)
(*         assert (F - X = 0)%nat by lia. rewrite H in *. ring_simplify. *)
(*         apply next_addr_mu. auto. *)
(*         rewrite <- C. *)
(*         cut (Mem.size_mem m2 + two_power_nat 3 * (Z.of_nat X + Z.of_nat (F - X) + 1)  <= Int.max_unsigned). lia. *)
(*         replace (Z.of_nat X + Z.of_nat (F - X) + 1) with (Z.of_nat F + 1) by lia. *)
(*         match goal with *)
(*           |- ?a <= ?b => cut (a <= Mem.size_mem m1 + two_power_nat MA) *)
(*         end. *)
(*         generalize (Mem.mem_lemu m1); unfold Mem.__szmem, Mem.comp_size. lia. *)
(*         rewrite <- NUMFORGOTTEN. *)
(*         rewrite <- Z.add_assoc. *)
(*         apply Z.add_le_mono_l. *)
(*         transitivity (two_power_nat MA * (Z.of_nat F + 1)). *)
(*         apply Z.mul_le_mono_nonneg_r. lia. *)
(*         rewrite ! two_power_nat_two_p. apply two_p_monotone. *)
(*         generalize (MA_bound); lia. lia.  *)
(*       + auto.  *)
(*   } *)
(*   { *)
(*     intros b b' FB'. *)
(*     unfold realloc_blocks. *)
    
(*     destr. *)
(*     cut (~ In b lf). intro NIN. *)
(*     rewrite add_blocks_after_other; auto. *)
(*     erewrite make_cm_other'. 3: eauto. *)
(*     unfold cm1'; rewrite FB'. auto. *)
(*     auto. *)
(*     intro IN; eapply make_cm_in in IN; eauto. *)

(*     intro IN. rewrite Forall_forall in SZNINJ. *)
(*     apply SZNINJ in IN. rewrite FB' in IN. destr.     *)
(*   } *)

(* Qed. *)
 

(* Theorem forget_compat: *)
(*   forall (f : simpl_inj) (m1 m2 : mem) sil *)
(*     (MI: sinj f m1 m2 sil nil) *)
(*     cm2 *)
(*     (COMP: Mem.compat_m m2 Mem.M32 cm2), *)
(*   exists cm1, *)
(*     Mem.compat_m m1 Mem.M32 cm1 /\ *)
(*     (forall b b' : block, f b = Some b' -> cm1 b = cm2 b'). *)
(* Proof. *)
(*   intros. *)

(*   destruct (zle (next_addr m2 cm2) (Mem.size_mem m2)). *)
(*   (* If next_addr <= size_mem, then we can put the forgotten blocks after size_mem *) *)
(*   - destruct (Mem.alloc_compat m1) as [cm1 [AMEM COMP']]. *)
(*     unfold Mem.alloc_mem in AMEM. *)
(*     unfold Alloc.alloc_blocks in AMEM. *)
(*     repeat destr_in AMEM. inv AMEM. *)
(*     apply Alloc.alloc_size_mem_aux in Heqp. *)
(*     destruct (part_inj (Mem.mk_block_list m1) f) eqn:?. *)
(*     generalize (partition_app_perm (is_injected f) _ _ _ Heqp0). intro P. *)
(*     rewrite (Alloc.size_mem_aux_permut MA _ _ P) in Heqp. *)

(*     assert (exists al', Alloc.alloc_mem_aux MA (l1 ++ l2) = (z,al')). *)
(*     { *)
(*       destruct (Alloc.alloc_mem_aux MA (l1 ++ l2)) eqn:?. *)
(*       apply Alloc.alloc_size_mem_aux in Heqp1. eexists; eauto. f_equal.  *)
(*       congruence. *)
(*     } *)
(*     generalize (Alloc.compat_alloc'' *)
(*                   _ (proj1 MA_bound) _ szmem_mu *)
(*                   (Mem.bounds_of_block m1) (Alloc.get_size (Mem.mem_blocksize m1)) *)
(*                   (Mem.nat_mask m1)). *)
(*     intro A. trim A. *)
(*     unfold Mem.nat_mask. intros; eexists; split. 2: eauto. *)
(*     unfold Mem.mask. destr. 2: lia. eapply Mem.alignment_ok; eauto. *)
(*     trim A. intros; unfold Mem.bounds_of_block. *)
(*     destr. 2: lia. destr. eapply Mem.bounds_lo_inf0 in Heqo. *)
(*     destruct Heqo; subst; lia. *)
(*     trim A. unfold Alloc.get_size, Mem.bounds_of_block. intros; repeat destr. *)
(*     inv Heqp1; lia. *)
(*     dex. *)
(*     specialize (A (pred (Pos.to_nat (Mem.nextblock m1))) (fun b => Int.repr (al' b))). *)
(*     trim A. intros. *)
(*     unfold Mem.bounds_of_block. *)
(*     rewrite Mem.bounds_mask_consistency. auto. *)
(*     apply Mem.msk_valid. intro PLT. *)
(*     apply Pos2Nat.inj_lt in PLT. lia. *)
(*     specialize (A (fun l => let (a,b) := part_inj l f in (a++b))). *)
(*     trim A. *)
(*     intros. destr. *)
(*     eapply partition_app_perm. unfold part_inj in Heqp1. apply Heqp1. *)
(*     trim A. *)
(*     unfold Alloc.alloc_blocks, Mem.mk_block_list in *.  *)
(*     destr_in A. destr_in Heqp1.  unfold Mem.size_block in Heqp0. *)
(*     assert ((l1, l2) = (l3,l4)). *)
(*     { *)
(*       rewrite <- Heqp0, <- Heqp. f_equal. *)
(*     } *)
(*     inv H0. *)
(*     rewrite Heqp1 in *. inv H. *)
(*     destr. *)
    
(*     exists (fun b1 => match f b1 with *)
(*                 Some b2 => cm2 b2 *)
(*               | None => (fun b => Int.repr (al' b)) b1 *)
(*               end). *)
(*     split; [|intros b b' E; rewrite E; auto]. *)
(*     constructor. *)
(*     + intros. destruct (f b) eqn:?. *)
(*       eapply in_bound_sinj in H0; eauto. *)
(*       eapply NormaliseSpec.addr_space; eauto. *)
(*       exploit NormaliseSpec.addr_space. apply Mem.compat31_32. apply A. apply H0. *)
(*       simpl. auto. *)
(*     + intros. *)
(*       destruct (f b) eqn:?.  *)
(*       destruct (f b') eqn:?.  *)
(*       * eapply in_bound_sinj in H1; eauto. *)
(*         eapply in_bound_sinj in H2; eauto. *)
(*         eapply NormaliseSpec.overlap; eauto. *)
(*         intro; subst. elim H0. eapply sinj_injective; eauto. *)
(*         (* exploit Mem.mi_no_overlap'; eauto. *) *)
(*         (* intro B. *) *)
(*         (* eapply Mem.mi_bounds in H1 ; try solve [inv MI; eauto]. *) *)
(*         (* eapply Mem.mi_bounds in H2 ; try solve [inv MI; eauto]. *) *)
(*         (* erewrite (O2O _ _ _ Heqo0) in *; eauto. *) *)
(*         (* erewrite (O2O _ _ _ Heqo1) in *; eauto. *) *)
(*         (* rewrite ! Z.add_0_r in *. *) *)
(*         (* destruct (peq b0 b1). *) *)
(*         (* 2: eapply NormaliseSpec.overlap; eauto. *) *)
(*         (* subst. destruct B. congruence. *) *)
(*         (* intro EQQ.  *) *)
(*         (* unfold Int.add in EQQ. *) *)
(*         (* rewrite ! Int.unsigned_repr_eq in EQQ. *) *)
(*         (* apply H3. clear - EQQ. *) *)
(*         (* cut (Int.unsigned o mod Int.modulus = Int.unsigned o' mod Int.modulus). *) *)
(*         (* rewrite ! Zmod_small; auto. *) *)
(*         (* apply Int.unsigned_range. *) *)
(*         (* apply Int.unsigned_range. *) *)
(*         (* unfold Z.modulo in *. *) *)
(*         (* destr_in EQQ. destr_in Heqp. *) *)
(*         (* repeat destr. *) *)
        
(*         (* generalize (Z_div_mod_full (Int.unsigned (cm2 b1) + Int.unsigned o') *) *)
(*         (*                           Int.modulus). rewrite Heqp0. *) *)
(*         (* generalize (Z_div_mod_full (Int.unsigned (cm2 b1) + Int.unsigned o) *) *)
(*         (*                           Int.modulus). rewrite Heqp.   *) *)
(*         (* generalize (Z_div_mod_full (Int.unsigned o) *) *)
(*         (*                           Int.modulus). rewrite Heqp1.     *) *)
(*         (* generalize (Z_div_mod_full (Int.unsigned o') *) *)
(*         (*                           Int.modulus). rewrite Heqp2. *) *)
(*         (* assert (Int.modulus <> 0) by (vm_compute; destr). *) *)
(*         (* Opaque Int.modulus. *) *)
(*         (* intuition. *) *)
(*         (* rewrite H1 in H2. *) *)
(*         (* rewrite H0 in H3. *) *)
(*         (* assert (Int.modulus * (z - z2) + z1 - z3 = Int.modulus * (z0 - z4) + z1 - z5). *) *)
(*         (* lia. *) *)
(*         (* assert (z3 - z5 = Int.modulus * (z - z2 - z0 + z4)). lia. *) *)
(*         (* clear - H5 H6 H9. *) *)
(*         (* unfold Remainder in *. *) *)
(*         (* assert (0 < Int.modulus) by (vm_compute; destr). *) *)
(*         (* destruct H5; try lia. *) *)
(*         (* destruct H6; try lia. *) *)
(*         (* change Int.modulus with 4294967296 in *. *) *)
(*         (* ppsimpl; lia. *) *)
(*       * eapply in_bound_sinj in H1; eauto.  *)
(*         generalize (part_inj_cm_below _ _ COMP l _ _ H1). *)
(*         generalize (part_inj_cm_above *)
(*                       _ _ _ _ *)
(*                       MI _ _ Heqp0). *)
(*         unfold Alloc.alloc_blocks. rewrite H. *)
(*         destr. *)
(*         intro B. specialize (B _ eq_refl). simpl in B. *)
(*         cut (In b' (map fst l2)). *)
(*         { *)
(*           intro IN. specialize (B _ IN). *)
(*           revert B. *)
(*           clear - H2. *)
(*           unfold Int.add. *)
(*           intros [A1 A2] B C. *)
(*           specialize (A2 _ H2). clear H2. *)
(*           rewrite (Int.unsigned_repr (Int.unsigned (Int.repr (al' b')) + Int.unsigned o')) in C. *)
(*           2: split; auto. *)
(*           2: generalize (Int.unsigned_range (Int.repr (al' b'))) *)
(*                         (Int.unsigned_range (o')); lia. *)
(*           rewrite (Int.unsigned_repr (Int.unsigned (cm2 b0) + Int.unsigned o)) in C. *)
(*           generalize (Int.unsigned_range o'); lia. *)
(*           split. *)
(*           generalize (Int.unsigned_range (cm2 b0)) (Int.unsigned_range o); lia. *)
(*           transitivity (Mem.size_mem m2). lia. *)
(*           rewrite Z.le_lteq. left. *)
(*           eapply Z.lt_le_trans. apply Mem.mem_lemu. *)
(*           apply szmem_mu. *)
(*         } *)
(*         { *)
(*           rewrite in_map_iff. *)
(*           exists (b', Mem.size_block m1 b'); split; destr. *)
(*           rewrite in_partition_r. *)
(*           2: unfold part_inj in Heqp0; eauto. *)
(*           unfold is_injected; simpl; rewrite Heqo1. split; auto. *)
(*           eapply in_bound_in_list'; eauto. *)
(*         } *)
(*       * destr.  *)
(*         { *)
(*           eapply in_bound_sinj in H2; eauto. *)
(*           generalize (part_inj_cm_below _ _ COMP l _ _ H2). *)
(*           generalize (part_inj_cm_above *)
(*                         _ _ _ _ *)
(*                         MI _ _ Heqp0). *)
(*           unfold Alloc.alloc_blocks. rewrite H. *)
(*           destr. *)
(*           intro B. specialize (B _ eq_refl). simpl in B. *)
(*           cut (In b (map fst l2)). *)
(*           { *)
(*             intro IN. specialize (B _ IN). *)
(*             revert B. *)
(*             clear - H1. *)
(*             unfold Int.add. *)
(*             intros [A1 A2] B C. *)
(*             specialize (A2 _ H1). clear H1. *)
(*             rewrite (Int.unsigned_repr (Int.unsigned (Int.repr (al' b)) + Int.unsigned o)) in C. *)
(*             2: split; auto. *)
(*             2: generalize (Int.unsigned_range (Int.repr (al' b))) *)
(*                           (Int.unsigned_range (o)); lia. *)
(*             rewrite (Int.unsigned_repr (Int.unsigned (cm2 b0) + Int.unsigned o')) in C. *)
(*             generalize (Int.unsigned_range o); lia. *)
(*             split. *)
(*             generalize (Int.unsigned_range (cm2 b0)) (Int.unsigned_range o'); lia. *)
(*             transitivity (Mem.size_mem m2). lia. *)
(*             rewrite Z.le_lteq. left. *)
(*             eapply Z.lt_le_trans. apply Mem.mem_lemu. *)
(*             apply szmem_mu. *)
(*           } *)
(*           { *)
(*             rewrite in_map_iff. *)
(*             exists (b, Mem.size_block m1 b); split; destr. *)
(*             rewrite in_partition_r. *)
(*             2: unfold part_inj in Heqp0; eauto. *)
(*             unfold is_injected; simpl; rewrite Heqo0. split; auto. *)
(*             eapply in_bound_in_list'; eauto. *)
(*           } *)
(*         } *)
(*         { *)
(*           generalize (NormaliseSpec.overlap _ _ _ _ A _ _ _ _ H0 H1 H2). auto. *)
(*         } *)
(*     + intros. repeat destr. *)
(*       *  *)
(*         generalize (NormaliseSpec.alignment _ _ _ _ COMP b0). *)
(*         unfold Mem.nat_mask. *)
(*         intros C. *)
(*         Require Import IntFacts. *)
(*         replace (cm2 b0) with (Int.add (cm2 b0) Int.zero). *)
(*         eapply alignment_inj; eauto. *)
(*         rewrite two_p_abs; auto. *)
(*         eapply sinj_mask'; eauto. *)
(*         apply Int.add_zero. *)
(*       * inv A; auto. *)
(*   - eapply forget_compat_case_2; eauto.  *)
(* Qed. *)
(* *) *)

