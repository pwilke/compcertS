(* Require Import Coqlib. *)
(* Require Import Errors. *)
(* Require Import AST. *)
(* Require Import Integers. *)
(* Require Import Values. *)
(* Require Import Op. *)
(* Require Import NormaliseSpec. *)
(* Require Import Memory. *)
(* Require Import Events. *)
(* Require Import Globalenvs. *)
(* Require Import Smallstep. *)
(* Require Import Locations. *)
(* Require Import LTL. *)
(* Require Import Linear. *)
(* Require Import Lineartyping. *)
(* Require Import Mach. *)
(* Require Import Bounds. *)
(* Require Import Conventions. *)
(* Require Import Stacklayout. *)
(* (* Require Import Stacking. *) *)

(* Require Import Psatz. *)
(* Require Import PP.PpsimplZ. *)


(* Require Import Values_symbolictype. *)
(* Require Import Values_symbolic. *)

(* Ltac genAlloc := Mem.genAlloc. *)

(* (*  *)
(*  * Injection of a sz-byte stack block (sp) into a bigger (sz' bytes) stack block sp'. *)
(*  * sp is injected at offset delta. *)
(*  * We have n extra bytes that we inject before and after sp in sp' to fill the spaces. *)
(*  * We build upon injection j. *)
(*  *) *)

(* Definition inject j (sp sp' : block) (x x' y: nat) (b: block) : option (block*Z) := *)
(*   if plt b sp then j b *)
(*   else *)
(*     if peq b sp then Some (sp',8*Z.of_nat x) *)
(*     else *)
(*       (* blocks before delta *) *)
(*       if zle (Z.pos b - Z.pos sp) (Z.of_nat x) *)
(*       then Some (sp', 8*(Z.pos b - Z.pos sp - 1)) *)
(*       else *)
(*         (* blocks after delta and injected in sp' *) *)
(*         if zle (Z.pos b - Z.pos sp) (Z.of_nat (x+(y-x'))) *)
(*         then Some (sp', 8*(Z.pos b - Z.pos sp - 1 - Z.of_nat x + Z.of_nat x')) *)
(*         else None. *)

(* (* if zle (Z.pos b) (Z.pos sp + Z.of_nat n) *) *)
(*              (* then Some (Pos.add sp' (Z.to_pos ((Z.pos b - Z.pos sp) - (sz' - sz))), 0) *) *)
(*              (* else None *) *)

(* (* Tests using an Ocaml tool to print memories and injections. *) *)
(* (* Definition my_inject := inject (fun _ => None) xH xH 3 10 5 12. *) *)
(* (* Definition my_list := map (fun i => (i,my_inject i)) (1::2::3::4::5::6::7::8::9::10::11::12::nil)%positive. *) *)
(* (* Require Import ExtrOcamlBasic. *) *)
(* (* Require Import ExtrOcamlString. *) *)
(* (* Separate Extraction my_list. *) *)
(* (* Eval vm_compute in my_list. *) *)


(* Lemma inject_is_incr: *)
(*   forall j m m' ei (MINJ: Mem.inject ei j m m')  sp' x x' y, *)
(*     inject_incr j (inject j (Mem.nextblock m) sp' x x' y). *)
(* Proof. *)
(*   clear; intros. *)
(*   red; intros. *)
(*   unfold inject. *)
(*   generalize (Mem.mi_freeblocks _ _ _ _ MINJ b). *)
(*   rewrite H. *)
(*   unfold Mem.valid_block. *)
(*   destr. *)
(* Qed. *)

(* Lemma diff_thr: *)
(*   forall a b c, *)
(*     a < c -> c <= b ->  *)
(*     a <> b. *)
(* Proof. *)
(*   intros; lia.  *)
(* Qed. *)



(* Lemma diff_thr': *)
(*   forall a b c, *)
(*     a <= c -> c < b ->  *)
(*     a <> b. *)
(* Proof. *)
(*   intros; lia.  *)
(* Qed. *)



(* Lemma alloc_alloc_bytes_inject_no_overlap: *)
(*   forall j m1 m1' (MINJ : Mem.inject expr_inj_se j m1 m1') *)
(*     m2 sp sz (ALLOC : Mem.alloc m1 0 sz Normal = Some (m2, sp)) *)
(*     m3 n l (AB : Mem.alloc_bytes m2 n = Some (m3, l)) *)
(*     x x' y *)
(*     (ORD: (x <= x' <= y)%nat) *)
(*     (EQ: 8 * Z.of_nat x + align sz 8 = 8 * Z.of_nat x') *)
(*     m2' sp' *)
(*     (ALLOC' : Mem.alloc m1' 0 (8*Z.of_nat y) Normal = Some (m2', sp')), *)
(*     Mem.meminj_no_overlap' (inject j sp sp' x x' y) *)
(*                                    m3. *)
(* Proof. *)
(*   Opaque Z.add Z.sub Z.mul. *)
(*   clear. *)
(*   intros. *)
(*   red. intros b1 b1' delta1 b2 b2' delta2 ofs1 ofs2 Bdiff INJ1 INJ2 IB1 IB2.   *)
(*   unfold inject in INJ1, INJ2. *)
(*   rewrite (Mem.alloc_alloc_bytes_bound _ _ _ _ _ _ _ _ ALLOC AB) in IB1, IB2. *)
(*   genAlloc. clear NA NA0 NA1 . *)
(*   destruct (plt b1 (Mem.nextblock m1)) , (plt b2 (Mem.nextblock m1)). *)
(*   - destruct IB1 as [[IB1 | [A B]]|[A [B C]]]; *)
(*     destruct IB2 as [[IB2 | [D E]]|[D [E F]]]; subst; try (ppsimpl; lia); try congruence. *)
(*     apply (Mem.mi_no_overlap' _ _ _ _ MINJ _ _ _ _ _ _ _ _ Bdiff INJ1 INJ2); auto.   *)
(*   - generalize (Mem.mi_mappedblocks _ _ _ _ MINJ _ _ _ INJ1). *)
(*     unfold Mem.valid_block. *)
(*     left. intro; subst. cut (Ple (Mem.nextblock m1') b2'). ppsimpl; lia. *)
(*     clear - INJ2. *)
(*     assert (b2' = Mem.nextblock m1'). *)
(*     repeat (revert INJ2; destr); inv INJ2. subst; clear. ppsimpl; lia. *)
(*   - generalize (Mem.mi_mappedblocks _ _ _ _ MINJ _ _ _ INJ2). *)
(*     unfold Mem.valid_block. *)
(*     left. intro; subst. cut (Mem.nextblock m1' = b2'). intro; subst. contradict H; clear; ppsimpl; lia. *)
(*     clear - INJ1. *)
(*     repeat (revert INJ1; destr); inv INJ1. *)
(*   - assert (~ Mem.in_bound_m ofs1 m1 b1). *)
(*     intro CONT. apply Mem.in_bound_valid in CONT. unfold Mem.valid_block in CONT. auto. *)
(*     assert (~ Mem.in_bound_m ofs2 m1 b2). *)
(*     intro CONT. apply Mem.in_bound_valid in CONT. unfold Mem.valid_block in CONT. auto. *)
(*     destruct IB1 as [[IB1|[A B]]|[A [B C]]]. congruence. *)
(*     + rewrite Zmax_r in B by lia. subst. rewrite peq_true in INJ1. *)
(*       destruct IB2 as [[IB2|[C D]]|[D [E F]]]. congruence. subst; congruence. *)
(*       rewrite peq_false in INJ2 by (ppsimpl; lia). *)
(*       inv INJ1. *)
(*       destruct (zle (Z.pos b2 - Z.pos (Mem.nextblock m1)) (Z.of_nat x)). *)
(*       * inv INJ2. *)
(*         right. *)
(*         ppsimpl; lia. *)
(*       * destruct (zle (Z.pos b2 - Z.pos (Mem.nextblock m1)) (Z.of_nat (x+(y-x')))); inv INJ2. *)
(*         right. *)
(*         apply diff_thr with (8*Z.of_nat x + sz). lia. *)
(*         rewrite Zmult_plus_distr_r. *)
(*         rewrite ! Zmult_minus_distr_l. *)
(*         rewrite <- EQ. *)
(*         cut (8*Z.of_nat x + sz <= ofs2 - 8 + 8*(Z.pos b2 - Z.pos (Mem.nextblock m1)) + align sz 8). lia. *)

(*         clear - g B F. *)
(*         revert g. *)
(*         generalize (Z.pos b2 - Z.pos (Mem.nextblock m1)). *)
(*         clear - B F; intros. *)
(*         assert (D: z-1 >= Z.of_nat x). lia. *)
(*         apply (Zmult_ge_compat_l _ (Z.of_nat x) 8) in D; try lia. *)
(*         apply Zge_le in D. *)
(*         generalize (align_le sz 8). *)
(*         lia. *)
(*     + destruct (peq b1 (Mem.nextblock m1)); [ppsimpl; lia|]. *)
(*       destruct IB2 as [[IB2|[D E]]|[D [E F]]]. congruence.  *)
(*       subst. *)
(*       * rewrite peq_true in INJ2. inv INJ2. *)
(*         right. *)
(*         destruct (zle (Z.pos b1 - Z.pos (Mem.nextblock m1)) (Z.of_nat x)). *)
(*         inv INJ1. *)
(*         ppsimpl; lia. *)
(*         destruct (zle (Z.pos b1 - Z.pos (Mem.nextblock m1)) (Z.of_nat (x+(y-x')))). *)
(*         inv INJ1. *)
(*         apply not_eq_sym. *)
(*         apply diff_thr with (8*Z.of_nat x + sz). lia. *)
(*         rewrite Zmult_plus_distr_r. *)
(*         rewrite ! Zmult_minus_distr_l. *)
(*         rewrite <- EQ. *)
(*         cut (8*Z.of_nat x + sz <= ofs1 - 8 + 8*(Z.pos b1 - Z.pos (Mem.nextblock m1)) + align sz 8). lia. *)
(*         rewrite Zmax_r in E by lia. *)
(*         clear - g C E. *)
(*         revert g. *)
(*         generalize (Z.pos b1 - Z.pos (Mem.nextblock m1)). *)
(*         clear - C E; intros. *)
(*         assert (D: z-1 >= Z.of_nat x). lia. *)
(*         apply (Zmult_ge_compat_l _ (Z.of_nat x) 8) in D; try lia. *)
(*         apply Zge_le in D. *)
(*         generalize (align_le sz 8). *)
(*         lia. *)
(*         congruence. *)
(*       * rewrite peq_false in INJ2. *)
(*         right. *)
(*         { *)
(*           destruct (zle (Z.pos b1 - Z.pos (Mem.nextblock m1)) (Z.of_nat x)). *)
(*           - inv INJ1. *)
(*             destruct (zle (Z.pos b2 - Z.pos (Mem.nextblock m1)) (Z.of_nat x)). *)
(*             + inv INJ2. cut (ofs1 + 8*Z.pos b1 <> ofs2 + 8 * Z.pos b2). lia. *)
(*               clear - C F Bdiff. *)
(*               cut (ofs1 - ofs2 <> 8* (Z.pos b2 - Z.pos b1)). lia. *)
(*               destruct (plt b1 b2). *)
(*               apply diff_thr with 8. lia. ppsimpl; lia. *)
(*               apply not_eq_sym. apply diff_thr' with (-8). 2:lia. *)
(*               unfold block in *. ppsimpl; lia. *)
(*             + destruct (zle (Z.pos b2 - Z.pos (Mem.nextblock m1)) (Z.of_nat (x+(y-x')))); inv INJ2. *)
(*               ppsimpl; lia. *)
(*           - destruct (zle (Z.pos b1 - Z.pos (Mem.nextblock m1)) (Z.of_nat (x+(y-x')))); inv INJ1. *)
(*             destruct (zle (Z.pos b2 - Z.pos (Mem.nextblock m1)) (Z.of_nat x)). *)
(*             + inv INJ2. ppsimpl; lia. *)
(*             + destruct (zle (Z.pos b2 - Z.pos (Mem.nextblock m1)) (Z.of_nat (x+(y-x')))); inv INJ2. *)
(*               cut (ofs1 + 8*Z.pos b1 <> ofs2 + 8 * Z.pos b2). lia. *)
(*               clear - C F Bdiff. *)
(*               cut (ofs1 - ofs2 <> 8* (Z.pos b2 - Z.pos b1)). lia. *)
(*               destruct (plt b1 b2). *)
(*               apply diff_thr with 8. lia. ppsimpl; lia. *)
(*               apply not_eq_sym. apply diff_thr' with (-8). 2:lia. *)
(*               unfold block in *. ppsimpl; lia. *)
(*         } *)
(*         intro; subst. *)
(*         contradict D; clear; ppsimpl; lia. *)
(* Qed. *)


(* Lemma align_mul: *)
(*   forall x y, *)
(*     y > 0 -> *)
(*     align (y*x) y = y*x. *)
(* Proof. *)
(*   intros. *)
(*   Transparent align. *)
(*   unfold align. *)
(*   replace (y*x + y - 1) with (y * (x + 1) - 1) by lia. *)
(*   IntFacts.elim_div. *)
(*   intros. cut (x = z). intros -> . lia.  *)
(*   trim H0. lia. *)
(*   destr; [|lia]. *)
(*   assert (y * (x + 1 - z) = z0 + 1) by lia. clear H1. *)
(*   destruct (zle 0 (x + 1 - z)). *)
(*   - cut (z0 + 1 = y * 1). *)
(*     intro A; rewrite A in H0. *)
(*     rewrite Z.mul_cancel_l in H0. lia. lia. *)
(*     cut (x+1-z = 0 \/ x+1-z = 1). intros [A|A]; rewrite A in *; lia. *)
(*     assert ((x+1-z)*y <= 1*y) by lia. *)
(*     apply Zmult_le_reg_r in H1; lia. *)
(*   -  *)
(*     assert (0 < y) by lia. *)
(*     generalize (Z.mul_nonneg_cancel_r (x+1-z) _ H1). *)
(*     destr. *)
(*     lia. *)
(* Qed. *)

(* Parameter MA_3 : MA = 3%nat. *)

(* Ltac use_ma_3 := repeat rewrite MA_3 in *; change (two_power_nat 3) with 8 in *. *)

(* Lemma alloc_alloc_bytes_bigger_alloc_succeeds: *)
(*   forall m1 m1' (MINJ: Mem.size_mem m1' <= Mem.size_mem m1) *)
(*     m2 b sz  (SZpos: 0 <= sz)  (ALLOC: Mem.alloc m1 0 sz Normal = Some (m2,b)) *)
(*     m3 n l (AB: Mem.alloc_bytes m2 n = Some (m3,l)) *)
(*     sz' (RNG: sz <= sz' <= sz + 8*Z.of_nat n), *)
(*   exists m2' b', *)
(*     Mem.alloc m1' 0 sz' Normal = Some (m2',b'). (*  /\ *) *)
(*     (* Mem.alloc_bytes m2' (n - NPeano.div (Z.to_nat (sz' - sz)) 8) = Some (m3',l'). *) *)
(* Proof. *)
(*   clear; intros. *)
(*   destruct (Mem.alloc m1' 0 sz' Normal) as [[m2' b']|] eqn:?. *)
(*   - exists m2', b'. eauto.  *)
(*   - exfalso. *)
(*     apply Mem.alloc_none_gemu in Heqo. *)
(*     generalize (Mem.mem_lemu m3). *)
(*     eapply Mem.alloc_bytes_size_mem in AB. rewrite AB. clear AB. *)
(*     eapply Mem.alloc_size_mem' in ALLOC. rewrite ALLOC. clear ALLOC. *)
(*     intros. *)
(*     cut (align (Z.max 0 sz') 8 <= align (Z.max 0 sz) 8 + 8*Z.of_nat n). *)
(*     use_ma_3. lia.  *)
(*     clear - SZpos RNG. destruct RNG as [R1 R2]. *)
(*     rewrite ! Zmax_r by lia. *)
(*     rewrite <- align_mul by lia. *)
(*     rewrite Mem.align_distr. *)
(*     apply Align.align_add. lia. *)
(*     generalize (align_le sz 8). lia. lia. *)
(* Qed. *)


(* Lemma rew_if_same {A B: Prop} {C: Type} (a: sumbool A B) (b: C): *)
(*   (if a then b else b) = b. *)
(* Proof. *)
(*   destruct a; auto. *)
(* Qed. *)

(* Lemma rew_if_same_bool {C: Type} (a: bool) (b: C): *)
(*   (if a then b else b) = b. *)
(* Proof. *)
(*   destruct a; auto. *)
(* Qed. *)

(* Lemma alloc_alloc_bytes_inject: *)
(*   forall j m1 (ABI: Mem.all_blocks_injected j m1) *)
(*     m1' (MINJ: Mem.inject expr_inj_se j m1 m1') *)
(*     m2 sp sz (ALLOC: Mem.alloc m1 0 sz Normal = Some (m2,sp)) *)
(*     (x x' y: nat) *)
(*     m3  l (AB: Mem.alloc_bytes m2 (y-x'+x) = Some (m3,l)) *)
(*     (SZpos: 0 <= sz) *)
(*     (Aligned: sz = align sz 8) *)

(*     (EQ: align sz 8 + 8 * Z.of_nat x = 8 * Z.of_nat x') *)
(*     (ORD: (x <= x' <= y)%nat) *)
(* , *)
(*   exists m2' sp', *)
(*     Mem.alloc m1' 0 (8*Z.of_nat y) Normal = Some (m2',sp') /\ *)
(*     exists j', *)
(*       j' = inject j sp sp' x x' y /\ *)
(*       j' sp = Some (sp',8*Z.of_nat x) /\ *)
(*       Mem.inject expr_inj_se j' m3 m2' /\ *)
(*       inject_incr j j'. *)
(* Proof. *)
(*   intros. *)
  
(*   destruct (fun pf => alloc_alloc_bytes_bigger_alloc_succeeds m1 m1' pf m2 sp sz SZpos ALLOC m3 _ l AB *)
(*                                                                (8*Z.of_nat y)) *)
(*     as [m2' [sp' ALLOC' ]].  *)
(*   apply (Mem.mi_size_mem _ _ _ _ (Mem.mi_inj _ _ _ _ MINJ)). *)
(*   split. generalize (align_le sz 8); lia. *)
(*   rewrite Nat2Z.inj_add. *)
(*   rewrite Nat2Z.inj_sub by lia. *)
(*   rewrite Z.mul_add_distr_l. *)
(*   rewrite Z.mul_sub_distr_l. *)
(*   cut (0 <= sz + 8 * Z.of_nat x - 8 * Z.of_nat x' ). lia. *)
(*   rewrite <- EQ. lia. *)
(*   exists m2', sp'. repSplit; auto. *)
(*   clear Aligned. *)
(*   eexists; repSplit. reflexivity. *)
(*   - unfold inject. rewrite peq_true. destr. clear - p. xomega. *)
(*   - { *)
(*       constructor. *)
(*       - constructor. *)
(*         + Opaque Z.add Z.sub. *)
(*           intros. *)
(*           rewrite (Mem.alloc_alloc_bytes_perm _ _ _ _ _ _ _ _ ALLOC AB) in H0. *)
(*           destr. *)
(*           * assert (Plt b1 sp). *)
(*             apply Mem.alloc_result in ALLOC. subst sp. *)
(*             eapply Mem.perm_valid_block; eauto. *)
(*             unfold inject in H; des (plt b1 sp). *)
(*             generalize  (Mem.mi_perm _ _ _ _ (Mem.mi_inj _ _ _ _ MINJ) _ _ _ _ _ _ H H0). *)
(*             eapply Mem.perm_alloc_1; eauto. *)
(*           * subst b1. *)
(*             unfold inject in H. *)
(*             des (plt sp sp). clear - p0. xomega. *)
(*             rewrite peq_true in H. *)
(*             symmetry in H; inv H. *)
(*             eapply Mem.perm_implies. eapply Mem.perm_alloc_2; eauto. *)
(*             split. lia. *)
(*             apply Z.lt_le_trans with (m:=8*Z.of_nat x'). *)
(*             2: ppsimpl; lia. *)
(*             2: constructor. *)
(*             rewrite <- EQ. *)
(*             generalize (align_le sz 8); lia. *)
(*           * unfold inject in H. *)
(*             assert (Plt sp (Mem.nextblock m2)). *)
(*             { erewrite Mem.nextblock_alloc; eauto. *)
(*               erewrite <- Mem.alloc_result; eauto. clear. xomega. } *)
(*             des (plt b1 sp). genAlloc. ppsimpl; lia.  *)
(*             des (peq b1 sp). genAlloc. ppsimpl; lia.  *)
(*             { *)
(*               destruct (zle ((Z.pos b1 - Z.pos sp)) (Z.of_nat x)); destr. *)
(*               - inv H. *)
(*                 eapply Mem.perm_implies. *)
(*                 eapply Mem.perm_alloc_2; eauto. ppsimpl; lia. *)
(*                 constructor. *)
(*               - destruct (zle ((Z.pos b1 - Z.pos sp)) (Z.of_nat (x+(y-x')))); inv H. *)
(*                 eapply Mem.perm_implies. *)
(*                 eapply Mem.perm_alloc_2; eauto. *)
(*                 split. lia. *)
(*                 cut (ofs + 8 * (Z.pos b1 - Z.pos sp) - 8 < 8 * Z.of_nat (x+ (y-x'))). lia. *)
(*                 eapply Z.lt_le_trans. 2: apply Zmult_le_compat_l; eauto. lia. *)
(*                 constructor. *)
(*             } *)

(*         + intros. *)
(*           rewrite (Mem.alloc_alloc_bytes_bound _ _ _ _ _ _ _ _ ALLOC AB) in H0. *)
(*           destr. *)
(*           * assert (Plt b1 sp). *)
(*             apply Mem.alloc_result in ALLOC; subst. *)
(*             eapply Mem.in_bound_valid; eauto. *)
(*             unfold inject in H; des (plt b1 sp). *)
(*             generalize  (Mem.mi_bounds _ _ _ _ (Mem.mi_inj _ _ _ _ MINJ) _ _ _ _ H H0). *)
(*             eapply Mem.alloc_in_bound'; eauto. *)
(*           * subst. *)
(*             unfold inject in H. *)
(*             des (plt sp sp). clear - p; exfalso; xomega. *)
(*             rewrite peq_true in H. *)
(*             symmetry in H; inv H. *)
(*             red. *)
(*             erewrite Mem.bounds_of_block_alloc; eauto. *)
(*             red; simpl. rewrite Zmax_r by lia. *)
(*             split. lia. *)
(*             apply Z.lt_le_trans with (m:=8*Z.of_nat x'). *)
(*             2: ppsimpl; lia. *)
(*             rewrite <- EQ. *)
(*             generalize (align_le sz 8); lia. *)
            
(*           * unfold inject in H. *)
(*             assert (Plt sp (Mem.nextblock m2)). *)
(*             { erewrite Mem.nextblock_alloc; eauto. *)
(*               erewrite <- Mem.alloc_result; eauto. clear; xomega. } *)
(*             des (plt b1 sp). ppsimpl; lia. *)
(*             des (peq b1 sp). clear - H5 H0; xomega. *)
(*             { *)
(*               destruct (zle (Z.pos b1 - Z.pos sp) (Z.of_nat x)); destr. *)
(*               - inv H. *)
(*                 red. *)
(*                 erewrite Mem.bounds_of_block_alloc; eauto. *)
(*                 red; simpl. ppsimpl; lia. *)
(*               - destruct (zle (Z.pos b1 - Z.pos sp) (Z.of_nat (x+(y-x')))); inv H. *)
(*                 red. *)
(*                 erewrite Mem.bounds_of_block_alloc; eauto. *)
(*                 red; simpl. ppsimpl; lia. *)
(*             } *)
(*         + intros. *)
(*           rewrite (Mem.aab_mask _ _ _ _ _ ALLOC _ _ _ AB) ; auto. *)
(*           rewrite (Mem.a_mask _ _ _ _ _ ALLOC').            *)
(*           unfold inject in H. *)
(*           { *)
(*             destruct (plt b sp). *)
(*             - generalize (Mem.mi_align' _ _ _ _ (Mem.mi_inj _ _ _ _ MINJ) _ _ _ H). *)
(*               intros [A B]. *)
(*               split; auto. *)
(*               generalize (Mem.mi_mappedblocks _ _ _ _ MINJ _ _ _ H). *)
(*               unfold Mem.valid_block. *)
(*               generalize (Mem.alloc_result _ _ _ _ _ _ ALLOC'). *)
(*               intro; subst. *)
(*               destr. *)
(*             - destruct (peq b sp); subst. *)
(*               + clear n; inv H. *)
(*                 destr_cond_match. clear - p; xomega. *)
(*                 clear n Heqs. *)
(*                 rewrite peq_true. *)
(*                 split. apply Mem.alignment_of_size_inj. *)
(*                 rewrite  ! Zmax_r by lia. *)
(*                 apply Zle_ge. etransitivity. *)
(*                 apply (align_le sz 8); try lia. *)
(*                 transitivity (8*Z.of_nat x'). lia. lia. *)
(*                 eapply Z.divide_trans. *)
(*                 apply IntFacts.two_p_inj_div. instantiate (1:=3). *)
(*                 unfold Alloc.alignment_of_size; repeat destr; lia. *)
(*                 exists (Z.of_nat x). change (two_p 3) with 8; lia. *)
(*               + *)
(*                 assert (b0=sp'). *)
(*                 repeat (revert H; destr); inv H. *)
(*                 subst. *)
(*                 rewrite pred_dec_false by (ppsimpl; lia). *)
(*                 rewrite peq_true. *)
(*                 destr_cond_match. *)
(*                 * *)
(*                   split. *)
(*                   assert (Plt sp b). ppsimpl; lia. *)
(*                   revert H; destr. inv H. *)
(*                   assert (y > 0)%nat. ppsimpl; lia. *)
(*                   assert (8 * Z.of_nat y >= 8). ppsimpl; lia. *)
(*                   unfold Alloc.alignment_of_size. repeat destr; lia. *)
(*                   revert H; destr; inv H. *)
(*                   assert (8 * Z.of_nat y >= 8). ppsimpl; lia. *)
(*                   unfold Alloc.alignment_of_size.  clear - H. repeat destr; lia. *)
(*                   change (two_p (Z.of_nat 3)) with 8. *)
(*                   repeat (revert H; destr); inv H; eexists; rewrite Z.mul_comm; eauto. *)
(*                 * change (two_p (Z.of_nat 0)) with 1. *)
(*                   split. lia. exists z; lia. *)
(*           } *)

(*         + intros. *)
(*           rewrite (Mem.aab_mem_contents _ _ _ _ _ ALLOC _ _ _ AB). *)
(*           rewrite (Mem.a_mem_contents' _ _ _ _ _ ALLOC'). *)
(*           rewrite Maps.PMap.gsspec. *)
(*           unfold inject in H. *)
(*           eapply (Mem.alloc_alloc_bytes_perm _ _ _ _ _ _ _ _ ALLOC AB) in H0; eauto. *)
(*           { *)
(*             destruct (plt b1 sp). *)
(*             - assert (Plt b2 sp'). *)
(*               { genAlloc. *)
(*                 eapply Mem.mi_mappedblocks; eauto. } *)
(*               destruct (peq b2 sp'); subst. contradict H1; clear; ppsimpl; lia. *)
(*               destruct (plt b2 sp'); [|ppsimpl; lia]. *)
(*               eapply memval_inject_incr. auto. *)
(*               eapply Mem.mi_memval; eauto. inv MINJ; auto. *)
(*               destr; subst. ppsimpl; lia. *)
(*               genAlloc. ppsimpl; lia. *)
(*               genAlloc. eapply inject_is_incr. eauto. *)
(*             - destruct (peq b1 sp); subst. *)
(*               + clear H0. inv H. *)
(*                 rewrite peq_true. *)
(*                 (* destr.  *) *)
(*                 (* { *) *)
(*                 (*   rewrite Mem.get_init_block. constructor. *) *)
(*                 (*   apply gnp_inject. auto. *) *)
(*                 (*   eexists; eexists; repSplit; try reflexivity. *) *)
(*                 (*   replace (Int.repr (ofs + 8 * Z.of_nat x)) with *) *)
(*                 (*   (Int.add (Int.repr ofs) (Int.repr (8 * Z.of_nat x))). *) *)
(*                 (*   constructor. unfold inject. destr. *) *)
(*                 (*   (* rewrite peq_true. auto. *) *) *)
(*                 (*   apply Val.int_add_repr. auto. *) *)
(*                 (*   apply Mem.zle_zlt in Heqb. split. *) *)
(*                 (*   ppsimpl; lia. *) *)
(*                 (*   replace (8 * Z.of_nat x) with (8 * Z.of_nat x' - align sz 8) by lia. *) *)
(*                 (*   cut (ofs - align sz 8 < 0). lia. *) *)
(*                 (*   generalize (align_le sz 8). lia. *) *)
(*                 (* } *) *)
(*                 (* { *) *)
(*                 destruct (Maps.ZMap.get (ofs + 8 * Z.of_nat x) *)
(*                                         (Mem.init_block 0 (8*Z.of_nat y) b2)). *)
(*                 rewrite rew_if_same_bool. *)
(*                 constructor. *)
(*                 apply wf_inj_undef. auto. *)
(*                   red; intros. rewrite gnp_rew; simpl; auto. *)
(*                   right. *)
(*                   red; intros. rewrite gnp_rew; simpl; auto. *)

(*               + genAlloc. clear NA NA0 NA1. *)
(*                 destruct H0. *)
(*                 destruct H0. *)
(*                 eapply Mem.perm_valid_block in H0. clear - H0 n n0. exfalso. *)
(*                 unfold Mem.valid_block in H0. xomega. *)
(*                 destr. *)
(*                 destr. *)
(*                 { *)
(*                   match goal with *)
(*                     |- memval_inject _ _ _ ?x => destruct x *)
(*                   end.  *)
(*                   constructor. *)
(*                   apply wf_inj_undef. auto. *)
(*                   red; intros. rewrite gnp_rew; simpl; auto. *)
(*                   right. *)
(*                   red; intros. rewrite gnp_rew; simpl; auto. *)
(*                 } *)
(*           } *)
          
(*         + rewrite (Mem.alloc_bytes_size_mem _ _ _ _ AB). *)
(*           rewrite (Mem.alloc_size_mem' _ _ _ _ _ _ ALLOC'). *)
(*           rewrite (Mem.alloc_size_mem' _ _ _ _ _ _ ALLOC). *)
(*           assert (sp = Mem.nextblock m1) by (genAlloc; destr). *)
(*           clear AB ALLOC ALLOC'. *)
(*           generalize (Mem.mi_size_mem _ _ _ _ (Mem.mi_inj _ _ _ _ MINJ)). *)
(*           rewrite ! Zmax_r by lia. *)
(*           use_ma_3. *)
(*           rewrite align_mul by lia. *)
(*           rewrite ! Nat2Z.inj_add. *)
(*           rewrite ! Nat2Z.inj_sub by lia. *)
(*           cut (0 <= align sz 8 - 8 * Z.of_nat x' + 8*Z.of_nat x + 8). lia. *)
(*           rewrite <- EQ. *)
(*           lia. *)

(*       - intros. unfold Mem.valid_block in H. *)
(*         genAlloc. *)
(*         clear NA NA0 NA1. *)
(*         unfold inject. *)
(*         destr. exfalso; clear - H p. ppsimpl; lia. *)
(*         destr. subst. exfalso; clear -  H. ppsimpl; lia. *)
(*         destr. exfalso; clear -  l0 H H1 H0 n n0. ppsimpl; lia. *)
(*         destr. exfalso; clear -  l0 H H1 H0 n0 n. ppsimpl; lia. *)

(*       - intros. *)
(*         unfold Mem.valid_block. *)
(*         genAlloc. *)
(*         clear NA NA0 NA1. *)
(*         unfold inject in H. *)
(*         repeat (revert H; destr). *)
(*         + generalize (Mem.mi_mappedblocks _ _ _ _ MINJ _ _ _ H). *)
(*           unfold Mem.valid_block. clear; ppsimpl; lia. *)
(*         + inv H. ppsimpl; lia. *)
(*         + inv H. clear; ppsimpl; lia. *)
(*         + inv H. clear; ppsimpl; lia. *)
          
(*       - eapply alloc_alloc_bytes_inject_no_overlap; eauto. *)
(*         lia. *)
        
(*       - unfold inject. *)
(*         intros b b' delta0 A. *)
(*         repeat (revert A; destr); inv A. *)
(*         + eapply Mem.mi_delta_pos; eauto. *)
(*         + lia. *)
(*         + clear - n n0. unfold block in *. ppsimpl; lia. *)
(*         +  *)
(*           rewrite ! Z.mul_add_distr_l. *)
(*           rewrite ! Z.mul_sub_distr_l. *)
(*           rewrite <- EQ. *)
(*           cut (8* (Z.pos b - Z.pos sp) - 8 + align sz 8 >= 0). lia. *)
(*           generalize (align_le sz 8). lia. *)
(*       - intros. *)
(*         rewrite <- Mem.is_block_dynamic_alloc_bytes; eauto. *)
(*         rewrite <- Mem.is_block_dynamic_alloc; eauto. *)
(*         rewrite <- Mem.is_block_dynamic_alloc with (m':=m2'); eauto. *)
(*         rewrite (Mem.alloc_bytes_bounds_eq _ _ _ _ AB). *)
(*         rewrite (Mem.bounds_of_block_alloc_eq _ _ _ _ _ _ ALLOC), *)
(*         (Mem.bounds_of_block_alloc_eq _ _ _ _ _ _ ALLOC'). *)
(*         revert H. genAlloc. *)
(*         unfold inject. *)
(*         intros A. *)
(*         Require Import Tactics. *)
(*         destr_in A. *)
(*         + exploit Mem.mi_inj_dynamic; eauto.   *)
(*           intros [B [C D]]; repSplit; destr. *)
(*           * intro DYN; trim C; auto. split; destr. *)
(*             subst. red in DYN; rewrite Mem.blocktype_valid in DYN; auto. destr. xomega. *)
(*             destr. subst. rewrite B  in DYN. *)
(*             red in DYN; rewrite Mem.blocktype_valid in DYN; auto. destr. xomega. *)
(*             destr. *)
(*             eapply Mem.mi_mappedblocks in A; eauto. red in A. xomega. *)
(*           * erewrite Mem.mi_freeblocks in A; destr. eauto. unfold Mem.valid_block; xomega. *)
(*           * intro DYN; trim D; auto. intros. *)
(*             destr_in H. eapply D in H; eauto. *)
(*             destr_in H. inv H. eapply Mem.mi_mappedblocks in A; eauto; red in A; xomega. *)
(*             destr_in H. inv H. eapply Mem.mi_mappedblocks in A; eauto; red in A. clear - A; xomega. *)
(*             destr_in H. inv H. eapply Mem.mi_mappedblocks in A; eauto; red in A. clear - A; xomega. *)
(*         + destr_in A. *)
(*           * inv A. *)
(*             repSplit; destr. *)
(*             unfold Mem.is_dynamic_block. rewrite ! Mem.blocktype_valid. destr. xomega. xomega. *)
(*             unfold Mem.is_dynamic_block. rewrite ! Mem.blocktype_valid. destr. xomega.  *)
(*             unfold Mem.is_dynamic_block. rewrite ! Mem.blocktype_valid. destr. xomega. *)
(*             unfold Mem.is_dynamic_block. rewrite ! Mem.blocktype_valid. destr. xomega. *)
(*           * destr_in A. inv A. *)
(*             unfold Mem.is_dynamic_block. rewrite ! Mem.blocktype_valid. destr. clear; xomega. *)
(*             auto. *)
(*             destr_in A. inv A. *)
(*             unfold Mem.is_dynamic_block. rewrite ! Mem.blocktype_valid. destr. clear; xomega. *)
(*             auto.  *)
(*     } *)
(*   - genAlloc. eapply inject_is_incr; eauto. *)
(* Qed. *)

(* Lemma inject_is_separated: *)
(*   forall j m1 m1' (MINJ: Mem.inject expr_inj_se j m1 m1') *)
(*     x x' y, *)
(*     inject_separated *)
(*       j *)
(*       (inject j (Mem.nextblock m1) (Mem.nextblock m1') x x' y) *)
(*       m1 m1'. *)
(* Proof. *)
(*   clear. *)
(*   red; intros. *)
(*   unfold inject in H0. *)
(*   unfold Mem.valid_block. *)
(*   destruct (plt b1 (Mem.nextblock m1)). *)
(*   congruence. *)
(*   assert (b2 = Mem.nextblock m1'). *)
(*   repeat destr_in H0; inv H0.  *)
(*   clear H0. subst. unfold block in *. xomega.  *)
(* Qed. *)